# Rust

## 1ã€å…¥é—¨æŒ‡å—

```rust
println!("hello world") // æ‰“å°æ–‡æœ¬
```

+ rustçš„ç¼©è¿›æ˜¯4ä¸ªç©ºæ ¼ï¼Œè€Œä¸æ˜¯tab
+ println!æ˜¯ä¸€ä¸ªrust macroï¼Œå¦‚æœæ˜¯å‡½æ•°çš„è¯ï¼Œå°±æ²¡æœ‰!
+ rustæ–‡ä»¶å‘½åè§„åˆ™ä¸ºä¸‹åˆ’çº¿å‘½åæ³•
+ cargo build [--release]
  + ç¼–è¯‘rustæºä»£ç å¹¶ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Œ--releaseä¼šåœ¨ç¼–è¯‘æ—¶å¯¹ä»£ç è¿›è¡Œä¼˜åŒ–
+ cargo check
  + æ£€æŸ¥ä»£ç ï¼Œç¡®ä¿ä»£ç å¯ä»¥é€šè¿‡ç¼–è¯‘ï¼Œä½†æ˜¯ä¸ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶
+ cargo run
  + ç¼–è¯‘rustæºä»£ç å¹¶æ‰§è¡Œå¯æ‰§è¡Œæ–‡ä»¶ï¼Œå¦‚æœå·²ç»å¯¹æºä»£ç è¿›è¡Œè¿‡ç¼–è¯‘ä¸”æ²¡æœ‰å¯¹æºä»£ç è¿›è¡Œä¿®æ”¹ï¼Œè¿™ä¼šç›´æ¥è·³è¿‡ç¼–è¯‘ï¼Œæ‰§è¡Œå¯æ‰§è¡Œæ–‡ä»¶

## 2ã€çŒœæ•°æ¸¸æˆ

```rust
use rand::Rng;
use std::io; // trait
             // use rand::thread_rng;
use std::cmp::Ordering;

fn main() {
    println!("çŒœæ•°ï¼");
    let secret_number = rand::thread_rng().gen_range(1..101); // i32 u32 i64 u64
    println!("ç¥ç§˜æ•°å­—æ˜¯ï¼š{}", secret_number);

    loop {
        println!("çŒœæµ‹ä¸€ä¸ªæ•°");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess).expect("æ— æ³•è¯»å–è¡Œ");

        // shadow
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("ä½ çŒœæµ‹çš„æ•°æ˜¯ï¼š{}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small"), // arm
            Ordering::Greater => println!("Too large"),
            Ordering::Equal => {
                println!("You win");
                break;
            }
        }
    }
}

```



+ ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œrustä¼šå°†preludeæ¨¡å—å¯¼å…¥åˆ°æ¯ä¸€ä¸ªç¨‹åºçš„ä½œç”¨åŸŸä¸­
+ ä½¿ç”¨useå…³é”®å­—å¯¼å…¥éœ€è¦çš„åº“ï¼Œä¾‹å¦‚ï¼š`use std::io;`
+ letå…³é”®å­—ç”¨æ¥å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œä½†æ˜¯è¿™ä¸ªå˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼Œå¦‚æœæƒ³è¦ä¿®æ”¹è¿™ä¸ªå˜é‡ï¼Œéœ€è¦åœ¨letåé¢åŠ ä¸Š`mut`ï¼ˆmutableï¼‰å…³é”®å­—ï¼Œä¾‹å¦‚ï¼š`let mut a = 1;`
+ String::new()å°†è¿”å›ä¸€ä¸ªç©ºç™½çš„å­—ç¬¦ä¸²ï¼Œnew()æ˜¯Stringç±»å‹çš„å…³è”å‡½æ•°ï¼Œç±»ä¼¼äºJavaä¸­çš„é™æ€æ–¹æ³•
+ io::stdin()å°†è¿”å›ä¸€ä¸ªStdinç±»å‹çš„å®ä¾‹ï¼Œè¯¥å®ä¾‹ä¼šè¢«ç”¨ä½œå¥æŸ„ï¼ˆhandleï¼‰ç”¨æ¥å¤„ç†ç»ˆç«¯ä¸­çš„è¾“å…¥
+ `&mut`è¡¨ç¤ºè·å–guessçš„å¼•ç”¨ï¼Œrustä¸­å¼•ç”¨é»˜è®¤åŒæ ·æ˜¯ä¸å¯å˜å¾—ï¼Œå› æ­¤åŒæ ·éœ€è¦åŠ ä¸Šmut
+ read_lineæ–¹æ³•ä¼šè¿”å›io::Result\<usize\>ç±»å‹ï¼Œè¿™ä¸ªç±»å‹æ˜¯ä¸€ä¸ªenumsç±»å‹ï¼Œå…¶å…±æœ‰ä¸¤ä¸ªå€¼ï¼šOkã€Errï¼Œå½“ç¨‹åºå‘ç”Ÿå¼‚å¸¸æ—¶ï¼Œä¼šè°ƒç”¨expectæ–¹æ³•ï¼Œå¹¶å°†å…¶ä¸­çš„å­—ç¬¦ä¸²æ˜¾ç¤ºç»™ç”¨æˆ·
+ rand::Rngæ˜¯ä¸€ä¸ª`trait`ï¼Œç±»ä¼¼äºJavaä¸­çš„æ¥å£ï¼Œé€šè¿‡rand::thread_rng()è¿”å›Rngçš„å®ç°ThreadRngç±»å‹
+ matchè¡¨è¾¾å¼å¯ä»¥é€šè¿‡guess.cmp()è¿”å›çš„Orderingç±»å‹ï¼ˆenumsç±»å‹ï¼‰çš„å€¼æ¥å†³å®šä¸‹ä¸€æ­¥æ‰§è¡Œçš„åˆ†æ”¯ï¼ˆarmï¼‰ï¼Œå› æ­¤ä¹Ÿå¸¸è¢«ç”¨ä½œå¤„ç†å¯èƒ½ä¼šå‘ç”Ÿçš„å¼‚å¸¸çš„æ‰‹æ®µ
+ loopè¡¨è¾¾å¼è¡¨ç¤ºæ— é™å¾ªç¯ï¼Œä¸è¦ä½¿ç”¨while trueæ¥å®ç°æ— é™å¾ªç¯ï¼Œwhileå¾ªç¯ä¾§é‡äºwhile conditionï¼Œè€Œä¸æ˜¯ç›´æ¥çš„while trueï¼Œè¿™æ›´ç¬¦åˆwhileçš„è¯­ä¹‰
+ Err(\_)ï¼Œ\_ä¸ºé€šé…ç¬¦ï¼Œå› ä¸ºè¿™é‡Œä¸éœ€è¦é”™è¯¯ä¿¡æ¯ï¼Œå› æ­¤ä½¿ç”¨é€šé…ç¬¦è¡¨ç¤º

## 3ã€é€šç”¨ç¼–ç¨‹æ¦‚å¿µ

### 3.1 å˜é‡ä¸å¯å˜æ€§

```rust
const MAX_POINTS: u32 = 100_000;
println!("The maximum number of {}", MAX_POINTS);

let mut x = 5;
println!("The value of x is {}", x);

x = 6;
println!("The value of x is {}", x);

let y = 5;
let y = y + 1;
let y = y * 2;
println!("The value of y is {}", y);

let spaces = "        ";
let spaces = spaces.len();
println!("{}", spaces);
```



#### 3.1.1 å˜é‡

+ å£°æ˜å˜é‡ä½¿ç”¨`let`å…³é”®å­—
+ é»˜è®¤æƒ…å†µä¸‹ï¼Œå˜é‡æ˜¯ä¸å¯å˜çš„ï¼ˆImmutableï¼‰
+ å£°æ˜å˜é‡æ—¶ï¼Œåœ¨å˜é‡å‰åŠ ä¸Š`mut`ï¼ˆmutableï¼‰å…³é”®å­—ï¼Œå°±å¯ä»¥ä½¿å˜é‡å¯å˜

#### 3.1.2 å¸¸é‡ï¼ˆconstantï¼‰

+ å¸¸é‡åœ¨ç»‘å®šå€¼ä¹‹åä¹Ÿæ˜¯ä¸å¯å˜çš„ï¼Œä½†æ˜¯å®ƒä¸ä¸å¯å˜çš„å˜é‡æœ‰å¾ˆå¤šåŒºåˆ«ï¼š
  + å¸¸é‡ä¸å¯ä»¥ä½¿ç”¨`mut`å…³é”®å­—ä¿®é¥°ï¼Œå¸¸é‡æ°¸è¿œéƒ½æ˜¯ä¸å¯å˜çš„
  + å£°æ˜å¸¸é‡ä½¿ç”¨`const`å…³é”®å­—ï¼Œå…¶ç±»å‹å¿…é¡»è¢«æ ‡æ³¨
  + å¸¸é‡å¯ä»¥åœ¨ä»»ä½•ä½œç”¨åŸŸå†…è¿›è¡Œå£°æ˜ï¼ŒåŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸ
  + å¸¸é‡åªå¯ä»¥ç»‘å®šåˆ°å¸¸é‡è¡¨è¾¾å¼ï¼Œæ— æ³•ç»‘å®šåˆ°å‡½æ•°çš„è°ƒç”¨ç»“æœæˆ–åªèƒ½åœ¨è¿è¡Œæ—¶æ‰èƒ½è®¡ç®—å‡ºçš„å€¼
+ åœ¨ç¨‹åºè¿è¡ŒæœŸé—´ï¼Œå¸¸é‡åœ¨å…¶å£°æ˜çš„ä½œç”¨åŸŸå†…ä¸€ç›´æœ‰æ•ˆ
+ Rustä¸­å¸¸é‡ä½¿ç”¨å…¨å¤§å†™å­—æ¯ï¼Œæ¯ä¸ªå•è¯ä¹‹é—´ç”¨ä¸‹åˆ’çº¿åˆ†å¼€
+ ä¾‹å­ï¼š`const MAX_POINTS : u32 = 100_000;`

#### 3.1.3 éšè—ï¼ˆshadowingï¼‰

+ å¯ä»¥ä½¿ç”¨ç›¸åŒçš„åå­—å£°æ˜æ–°çš„å˜é‡ï¼Œæ–°çš„å˜é‡å°±ä¼šshadowï¼ˆéšè—ï¼‰ä¹‹å‰å£°æ˜çš„åŒåå˜é‡
+ shadowå’ŒæŠŠå˜é‡æ ‡è®°ä¸º`mut`æ˜¯ä¸ä¸€æ ·çš„ï¼š
  + å¦‚æœä¸ä½¿ç”¨`let `å…³é”®å­—ï¼Œé‚£ä¹ˆé‡æ–°ç»™é`mut`çš„å˜é‡èµ‹å€¼ä¼šå¯¼è‡´ç¼–è¯‘æ—¶é”™è¯¯
  + è€Œä½¿ç”¨`let`å£°æ˜çš„åŒåæ–°å˜é‡ï¼Œä¹Ÿæ˜¯ä¸å¯å˜çš„
  + ä½¿ç”¨`let`å£°æ˜çš„åŒåæ–°å˜é‡ï¼Œå…¶ç±»å‹å¯ä»¥ä¸ä¹‹å‰çš„ä¸åŒ



### 3.2 æ•°æ®ç±»å‹

#### 3.2.1 æ ‡é‡ç±»å‹

> ä¸€ä¸ªæ ‡é‡ç±»å‹ä»£è¡¨ä¸€ä¸ªå•ä¸ªçš„å€¼

> Rustæœ‰å››ä¸ªä¸»è¦çš„æ ‡é‡ç±»å‹ï¼š
>
> + æ•´æ•°ç±»å‹
> + æµ®ç‚¹ç±»å‹
> + å¸ƒå°”ç±»å‹
> + å­—ç¬¦ç±»å‹

+ **æ•´æ•°ç±»å‹**

  + æ•´æ•°ç±»å‹æ²¡æœ‰å°æ•°éƒ¨åˆ†

  + ä¾‹å¦‚u32å°±æ˜¯ä¸€ä¸ªæ— ç¬¦å·çš„æ•´æ•°ç±»å‹ï¼Œå æ®32ä½çš„ç©ºé—´

  + æ— ç¬¦å·æ•´æ•°ç±»å‹ä»¥uå¼€å¤´

  + æœ‰ç¬¦å·æ•´æ•°ç±»å‹ä»¥iå¼€å¤´

  + Rustçš„æ•´æ•°ç±»å‹åˆ—è¡¨å¦‚ä¸‹ï¼š

    | Length  | Signed  | Unsigned |
    | ------- | ------- | -------- |
    | 8-bit   | `i8`    | `u8`     |
    | 16-bit  | `i16`   | `u16`    |
    | 32-bit  | `i32`   | `u32`    |
    | 64-bit  | `i64`   | `u64`    |
    | 128-bit | `i128`  | `u128`   |
    | arch    | `isize` | `usize`  |

  + isizeå’Œusizeç±»å‹

    + isizeå’Œusizeç±»å‹çš„ä½æ•°ç”±ç¨‹åºè¿è¡Œçš„è®¡ç®—æœºçš„æ¶æ„æ‰€å†³å®šï¼šå¦‚æœæ˜¯64ä½çš„è®¡ç®—æœºï¼Œé‚£å°±æ˜¯64ä½çš„
    + ä½¿ç”¨isizeå’Œusizeçš„ä¸»è¦åœºæ™¯æ˜¯å¯¹æŸç§é›†åˆè¿›è¡Œç´¢å¼•æ“ä½œ

  + æ•´æ•°å­—é¢å€¼

    | Number Literals               | Example       |
    | ----------------------------- | ------------- |
    | Decimal (åè¿›åˆ¶)              | `98_222`      |
    | Hex (åå…­è¿›åˆ¶)                | `0xff`        |
    | Octal (å…«è¿›åˆ¶)                | `0o77`        |
    | Binary (äºŒè¿›åˆ¶)               | `0b1111_0000` |
    | Byte (å•å­—èŠ‚å­—ç¬¦)(ä»…é™äº`u8`) | `b'A'`        |

    + é™¤äº†byteç±»å‹å¤–ï¼Œæ‰€æœ‰çš„æ•°å€¼å­—é¢å€¼éƒ½å…è®¸ä½¿ç”¨ç±»å‹åç¼€ï¼šä¾‹å¦‚ 57u8
    + å¦‚æœä½ ä¸å¤ªæ¸…æ¥šåº”è¯¥ä½¿ç”¨å“ªç§ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨Rustå“åº”çš„é»˜è®¤ç±»å‹
    + æ•´æ•°çš„é»˜è®¤ç±»å‹å°±æ˜¯i32ï¼šæ€»ä½“ä¸Šæ¥è¯´i32çš„é€Ÿåº¦å¾ˆå¿«ï¼Œå³ä½¿åœ¨64ä½ç³»ç»Ÿä¸­

  + æ•´æ•°æº¢å‡º

    + ä¾‹å¦‚ï¼šu8çš„èŒƒå›´æ˜¯0-255ï¼Œå¦‚æœæŠŠä¸€ä¸ªu8å˜é‡çš„å€¼è®¾ä¸º256ï¼Œé‚£ä¹ˆï¼š
      + è°ƒè¯•æ¨¡å¼ä¸‹ç¼–è¯‘ï¼šRustä¼šæ£€æŸ¥æ•´æ•°æº¢å‡ºï¼Œå¦‚æœå‘ç”Ÿæº¢å‡ºï¼Œç¨‹åºåœ¨è¿è¡Œæ—¶å°±ä¼španic
      + å‘å¸ƒæ¨¡å¼ä¸‹ï¼ˆ--releaseï¼‰ç¼–è¯‘ï¼šRustä¸ä¼šæ£€æŸ¥å¯èƒ½å¯¼è‡´panicçš„æ•´æ•°æº¢å‡º
        + å¦‚æœå‘ç”Ÿæº¢å‡ºï¼šRustä¼šæ‰§è¡Œâ€œç¯ç»•â€æ“ä½œï¼š256å˜æˆ0ï¼Œ257å˜æˆ1...

  ```rust
  let guess: u32 = "42".parse().expect("Not a number");
  println!("{}", guess);
  ```

+ **æµ®ç‚¹ç±»å‹**
  + Rustæœ‰ä¸¤ç§åŸºç¡€çš„æµ®ç‚¹ç±»å‹ï¼Œä¹Ÿå°±æ˜¯å«æœ‰å°æ•°éƒ¨åˆ†çš„ç±»å‹
    + f32ï¼Œ32ä½ï¼Œå•ç²¾åº¦
    + f64ï¼Œ64ä½ï¼ŒåŒç²¾åº¦
    
  + Rustçš„æµ®ç‚¹ç±»å‹ä½¿ç”¨äº†IEEE-754æ ‡å‡†æ¥è¡¨è¿°
  
  + f64æ˜¯é»˜è®¤ç±»å‹ï¼Œå› ä¸ºåœ¨ç°ä»£CPUä¸Šf64å’Œf32çš„é€Ÿåº¦å·®ä¸å¤šï¼Œè€Œä¸”ç²¾åº¦æ›´é«˜
  
    ```rust
    let x = 2.0;
    let y: f32 = 3.0;
    ```

+ æ•°å€¼æ“ä½œ
  + åŠ å‡ä¹˜é™¤ä½™

+ **å¸ƒå°”ç±»å‹**
  + Rustå¸ƒå°”ç±»å‹ä¹Ÿæœ‰ä¸¤ä¸ªå€¼ï¼štrueå’Œfalse
  
  + ä¸€ä¸ªå­—èŠ‚å¤§å°
  
  + ç¬¦å·æ˜¯`bool`
  
    ```rust
    let t = true;
    let f: bool = false;
    ```

+ **å­—ç¬¦ç±»å‹**
  + Rustä¸­å›½charç±»å‹è¢«ç”¨æ¥æè¿°è¯­è¨€ä¸­æœ€åŸºç¡€çš„å•ä¸ªå­—ç¬¦
  
  + å­—ç¬¦ç±»å‹çš„å­—é¢å€¼ä½¿ç”¨å•å¼•å·
  
  + å ç”¨4ä¸ªå­—èŠ‚å¤§å°
  
  + æ˜¯Unicodeæ ‡é‡å€¼ï¼Œå¯ä»¥è¡¨ç¤ºæ¯”ASCIIå¤šå¾—å¤šçš„å­—ç¬¦å†…å®¹ï¼šæ‹¼éŸ³ã€ä¸­æ—¥éŸ©æ–‡ã€é›¶é•¿åº¦ç©ºç™½å­—ç¬¦ã€emojiè¡¨æƒ…ç­‰
    + U+0000åˆ°U+D7FF
    + U+E000åˆ°U+10FFFF
    
  + ä½†æ˜¯Unicodeä¸­å¹¶æ²¡æœ‰â€œå­—ç¬¦â€çš„æ¦‚å¿µï¼Œæ‰€ä»¥ç›´æ¥ä¸Šè®¤è¯†çš„å­—ç¬¦ä¹Ÿè®¸ä¸Rustä¸­çš„æ¦‚å¿µå¹¶ä¸ç›¸ç¬¦
  
    ```rust
    let x = 'x';
    let y: char = 'å';
    let z = 'ğŸ˜‚';
    ```

#### 3.2.2 å¤åˆç±»å‹

+ å¤åˆç±»å‹å¯ä»¥å°†å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹é‡Œ

+ Rustæä¾›äº†ä¸¤ç§åŸºç¡€çš„å¤åˆç±»å‹ï¼šå…ƒç»„ï¼ˆTupleï¼‰ã€æ•°ç»„

+ **Tuple**
  + Tupleå¯ä»¥å°†å¤šä¸ªç±»å‹çš„å¤šä¸ªå€¼æ”¾åœ¨åŒä¸€ä¸ªç±»å‹é‡Œ
  
  + Tupleçš„é•¿åº¦æ˜¯å›ºå®šçš„ï¼šä¸€æ—¦å£°æ˜å°±æ— æ³•æ”¹å˜
  
  + åˆ›å»ºTuple
    + åœ¨å°æ‹¬å·é‡Œï¼Œå°†å€¼ç”¨é€—å·åˆ†å¼€
    + Tupleä¸­çš„æ¯ä¸ªä½ç½®éƒ½å¯¹åº”ä¸€ä¸ªç±»å‹ï¼ŒTupleä¸­å„å…ƒç´ çš„ç±»å‹ä¸å¿…ç›¸åŒ
    
  + è·å–Tupleçš„å…ƒç´ å€¼
    + å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥è§£æ„ï¼ˆ*destructuring*ï¼‰ä¸€ä¸ªTupleæ¥è·å–å…ƒç´ çš„å€¼
    
  + è®¿é—®Tupleçš„å…ƒç´ 
    + åœ¨Tupleå˜é‡ä½¿ç”¨ç‚¹æ ‡è®°æ³•ï¼Œåæ¥å…ƒç´ çš„ç´¢å¼•å·
    
  + ä¸å¸¦ä»»ä½•å€¼çš„å…ƒç»„æœ‰ä¸ªç‰¹æ®Šçš„åç§°ï¼Œå«åš **å•å…ƒï¼ˆunitï¼‰** å…ƒç»„ã€‚è¿™ç§å€¼ä»¥åŠå¯¹åº”çš„ç±»å‹éƒ½å†™ä½œ `()`ï¼Œè¡¨ç¤ºç©ºå€¼æˆ–ç©ºçš„è¿”å›ç±»å‹ã€‚å¦‚æœè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å…¶ä»–å€¼ï¼Œåˆ™ä¼šéšå¼è¿”å›å•å…ƒå€¼
  
  ```rust
  let tup: (i32, f64, u8) = (500, 6.3, 1);
  
  let (x, y, z) = tup;
  println!("{}, {}, {}", x, y, z);
  
  println!("{}, {}, {}", tup.0, tup.1, tup.2);
  ```
  
+ **æ•°ç»„**
  + æ•°ç»„ä¹Ÿå¯ä»¥å°†å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹é‡Œ
  
  + æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ çš„ç±»å‹å¿…é¡»ç›¸åŒ
  
  + æ•°ç»„çš„é•¿åº¦ä¹Ÿæ˜¯å›ºå®šçš„
  
  + å£°æ˜ä¸€ä¸ªæ•°ç»„
    + åœ¨ä¸­æ‹¬å·é‡Œï¼Œå„å€¼ç”¨é€—å·åˆ†å¼€
    
  + æ•°ç»„çš„ç”¨å¤„
    + å¦‚æœæƒ³è®©ä½ çš„æ•°æ®å­˜æ”¾åœ¨stackï¼ˆæ ˆï¼‰ä¸Šè€Œä¸æ˜¯heapï¼ˆå †ï¼‰ä¸Šï¼Œæˆ–è€…æƒ³ä¿è¯æœ‰å›ºå®šæ•°é‡çš„å…ƒç´ ï¼Œè¿™æ—¶ä½¿ç”¨æ•°ç»„æ›´æœ‰å¥½å¤„
    
  + æ•°ç»„æ²¡æœ‰Vectorçµæ´»
    + Vectorå’Œæ•°ç»„ç±»ä¼¼ï¼Œå®ƒç”±æ ‡å‡†åº“æä¾›
    + Vectorçš„é•¿åº¦å¯ä»¥æ”¹å˜
    + å¦‚æœä½ ä¸ç¡®å®šåº”è¯¥ç”¨æ•°ç»„è¿˜æ˜¯Vectorï¼Œé‚£ä¹ˆä¼°è®¡ä½ åº”è¯¥ç”¨Vector
    
  + æ•°ç»„çš„ç±»å‹
    + æ•°ç»„çš„ç±»å‹ä»¥è¿™ç§å½¢å¼è¡¨ç¤ºï¼š[ç±»å‹; é•¿åº¦]ï¼Œä¾‹å¦‚ï¼š `let a: [i32; 5] = [1, 2, 3, 4, 5];`
    
  + å¦ä¸€ç§å£°æ˜æ•°ç»„çš„æ–¹æ³•
    + å¦‚æœæ•°ç»„çš„æ¯ä¸ªå…ƒç´ å€¼éƒ½ç›¸åŒï¼Œé‚£ä¹ˆå¯ä»¥åœ¨ï¼š
      + åœ¨ä¸­æ‹¬å·é‡ŒæŒ‡å®šåˆå§‹å€¼
      + ç„¶åæ˜¯ä¸€ä¸ª â€œ ; â€
      + æœ€åæ˜¯æ•°ç»„çš„é•¿åº¦
      + ä¾‹å¦‚ï¼š`let a = [3; 5];`å®ƒå°±ç›¸å½“äºï¼š`let a = [3, 3, 3, 3, 3]`
    
  + è®¿é—®æ•°ç»„çš„å…ƒç´ 
    + æ•°ç»„æ˜¯åœ¨Stackä¸Šåˆ†é…çš„å•ä¸ªå—çš„å†…å­˜
    + å¯ä»¥ä½¿ç”¨ç´¢å¼•æ¥è®¿é—®æ•°ç»„çš„å…ƒç´ 
    + å¦‚æœè®¿é—®çš„ç´¢å¼•è¶…å‡ºäº†æ•°ç»„ç´¢å¼•çš„èŒƒå›´ï¼Œé‚£ä¹ˆï¼š
      + cargo checkä¼šé€šè¿‡
      + ç¼–è¯‘è¿è¡Œæ—¶ä¼šæŠ¥é”™ï¼ˆindex out of boundsï¼‰ï¼ŒRustä¸ä¼šå…è®¸å…¶ç»§ç»­è®¿é—®ç›¸åº”åœ°å€çš„å†…å­˜
    
    ```rust
    let a = [1, 2, 3, 4, 5];
    let b: [i32; 5] = [1, 2, 3, 4, 5];
    let c = [3; 5];
    
    let first = a[0];
    let second = a[1];
    let third = a[27]; // index out of bounds
    ```
    
    

### 3.3 å‡½æ•°ä¸æ³¨é‡Š

#### 3.3.1 å‡½æ•°

+ å£°æ˜å‡½æ•°ä½¿ç”¨`fn`å…³é”®å­—

+ é’ˆå¯¹å‡½æ•°å’Œå˜é‡åï¼ŒRustä½¿ç”¨snake caseå‘½åè§„èŒƒï¼šæ‰€æœ‰çš„å­—æ¯éƒ½æ˜¯å°å†™çš„ï¼Œå•è¯ä¹‹é—´ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†å¼€

+ **å‡½æ•°çš„å‚æ•°**
  + parametersã€arguments
  
  + åœ¨å‡½æ•°ç­¾åé‡Œï¼Œå¿…é¡»å£°æ˜æ¯ä¸ªå‚æ•°çš„ç±»å‹
  
    ```rust
    fn another_function(x: i32, y: i32) {
        println!("Another function!");
        println!("the value of x and y is: {}, {}", x, y);
    }
    ```

+ **å‡½æ•°ä½“ä¸­çš„è¯­å¥ä¸è¡¨è¾¾å¼**
  
  + å‡½æ•°ä½“ç”±ä¸€ç³»åˆ—è¯­å¥ç»„æˆï¼Œå¯é€‰çš„æœ‰ä¸€ä¸ªè¡¨è¾¾å¼ç»“æŸ
  
  + Rustæ˜¯ä¸€ä¸ªåŸºäºè¡¨è¾¾å¼çš„è¯­è¨€
  
  + è¯­å¥æ˜¯æ‰§è¡Œä¸€äº›åŠ¨ä½œçš„æŒ‡ä»¤
  
  + è¡¨è¾¾å¼ä¼šè®¡ç®—äº§ç”Ÿä¸€ä¸ªå€¼
  
  + å‡½æ•°çš„å®šä¹‰ä¹Ÿæ˜¯è¯­å¥
  
  + è¯­å¥ä¸è¿”å›å€¼ï¼Œæ‰€ä»¥ä¸å¯ä»¥ä½¿ç”¨`let`å°†è¯­å¥èµ‹å€¼ ç»™ä¸€ä¸ªå˜é‡
  
    ```rust
    // let x = (let y = 6); // expected expression, found statement (`let`)
    
    let y = {
        let x = 1;
        x + 3
    };
    ```
  
+ å‡½æ•°çš„è¿”å›å€¼
  + åœ¨ `->`ç¬¦å·åé¢å£°æ˜å‡½æ•°è¿”å›å€¼çš„ç±»å‹ï¼Œä½†æ˜¯ä¸å¯ä»¥ä¸ºè¿”å›å€¼å‘½å
  
  + åœ¨Rustä¸­ï¼Œè¿”å›å€¼å°±æ˜¯å‡½æ•°ä½“é‡Œé¢æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼
  
  + è‹¥æƒ³æå‰è¿”å›ï¼Œéœ€ä½¿ç”¨returnå…³é”®å­—ï¼Œå¹¶æŒ‡å®šä¸€ä¸ªå€¼
    + å¤§å¤šæ•°å‡½æ•°éƒ½æ˜¯é»˜è®¤ä½¿ç”¨æœ€åä¸€ä¸ªè¡¨è¾¾å¼ä½œä¸ºè¿”å›å€¼
    
      ```rust
      fn five(x: i32) -> i32 {
          5 + x
      }
      let x = five(6);
      println!("The value of x is {}", x);
      ```

#### 3.3.2 æ³¨é‡Š

> ä¸Cå’ŒJavaä¸€æ ·



### 3.4 æµç¨‹æ§åˆ¶

#### 3.4.1 ifè¡¨è¾¾å¼

+ `if`è¡¨è¾¾å¼å…è®¸ä½ æ ¹æ®æ¡ä»¶æ¥æ‰§è¡Œä¸åŒçš„ä»£ç åˆ†æ”¯
  + è¿™ä¸ªæ¡ä»¶å¿…é¡»æ˜¯boolç±»å‹
  
+ `if`è¡¨è¾¾å¼ä¸­ï¼Œä¸æ¡ä»¶ç›¸å…³è”çš„ä»£ç å—å°±å«åšåˆ†æ”¯ï¼ˆarmï¼‰

+ å¯é€‰çš„ï¼Œå¯ä»¥åœ¨åé¢åŠ ä¸Šä¸€ä¸ª`else`è¡¨è¾¾å¼

  ```rust
  let number = 3;
  
  if number < 5 {
      println!("condition was true");
  } else {
      println!("condition was false");
  }
  ```

+ ä½¿ç”¨`else if`å¤„ç†å¤šé‡æ¡ä»¶
  + å¦‚æœä½¿ç”¨äº†å¤šäºä¸€ä¸ª`else if`ï¼Œé‚£ä¹ˆæœ€å¥½ä½¿ç”¨`match`æ¥é‡æ„ä»£ç 
  
+ åœ¨`let`è¯­å¥ä¸­ä½¿ç”¨`if`
  + å› ä¸º`if`æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæ‰€ä»¥å¯ä»¥å°†å®ƒæ”¾åœ¨`let`è¯­å¥ä¸­ç­‰å·çš„å³è¾¹
  
    ```rust
    let condition = true;
    let number = if condition {5} else {6};
    println!("The value of number is: {}", number);
    ```

#### 3.4.2 å¾ªç¯

+ Rustæä¾›äº†3ç§å¾ªç¯ï¼š`loop`ã€`while`å’Œ`for`

+ **loopå¾ªç¯**
  + `loop`å…³é”®å­—å‘Šè¯‰Ruståå¤æ‰§è¡Œä¸€å—ä»£ç ï¼Œç›´åˆ°ä½ å–Šåœ
  
  + å¯ä»¥åœ¨`loop`å¾ªç¯ä¸­ä½¿ç”¨`break`å…³é”®å­—æ¥å‘Šè¯‰ç¨‹åºä½•æ—¶åœæ­¢å¾ªç¯
  
    ```rust
    let mut counter = 0;
    
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2
        }
    };
    
    println!("The result is: {}", result);
    ```

+ **whileæ¡ä»¶å¾ªç¯**
  + å¦å¤–çš„ä¸€ç§å¸¸è§çš„å¾ªç¯æ¨¡å¼æ˜¯æ¯æ¬¡æ‰§è¡Œå¾ªç¯ä½“ä¹‹å‰éƒ½åˆ¤æ–­ä¸€æ¬¡æ¡ä»¶
  
    ```rust
    let mut number = 3;
    while number != 0 {
        println!("{}!", number);
    
        number = number - 1;
    }
    
    println!("LIFTOFF!!!")
    ```

+ **ä½¿ç”¨forå¾ªç¯éå†é›†åˆ**
  + å¯ä»¥ä½¿ç”¨`while`æˆ–`loop`æ¥éå†é›†åˆï¼Œä½†æ˜¯æ˜“é”™ä¸”ä½æ•ˆ
  
  + ä½¿ç”¨`for`å¾ªç¯æ›´ç®€æ´ç´§å‡‘ï¼Œå®ƒå¯ä»¥é’ˆå¯¹é›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ æ¥æ‰§è¡Œä¸€äº›ä»£ç 
  
  + ç”±äº`for`å¾ªç¯çš„å®‰å…¨ã€ç®€æ´æ€§ï¼Œæ‰€ä»¥å®ƒåœ¨Rusté‡Œç”¨çš„æœ€å¤š
  
    ```rust
    let a = [10, 20, 30, 40, 50, 60];
    let mut index = 0;
    while index < a.len() {
        println!("The value is: {}", a[index]);
        index += 1;
    }
    
    for element in a.iter() {
        println!("The value is: {}", element);
    }
    ```

+ **Range**
  + ç”±æ ‡å‡†åº“æä¾›
  
  + æŒ‡å®šä¸€ä¸ªå¼€å§‹æ•°å­—å’Œä¸€ä¸ªç»“æŸæ•°å­—ï¼Œ`Range`å¯ä»¥ç”Ÿæˆå®ƒä»¬ä¹‹é—´çš„æ•°å­—ï¼ˆä¸å«ç»“æŸï¼‰
  
  + `rev`æ–¹æ³•å¯ä»¥åè½¬`Range`
  
    ```rust
    for number in (1 .. 4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
    ```
  
    

## 4ã€è®¤è¯†æ‰€æœ‰æƒ

### 4.1 ä»€ä¹ˆæ˜¯æ‰€æœ‰æƒ

> æ‰€æœ‰æƒæ˜¯Rustæœ€ç‹¬ç‰¹çš„ç‰¹æ€§ï¼Œå®ƒè®©Rustæ— éœ€GCå°±å¯ä»¥ä¿è¯å†…å­˜å®‰å…¨

+ Rustçš„æ ¸å¿ƒç‰¹æ€§å°±æ˜¯æ‰€æœ‰æƒ
+ æ‰€æœ‰çš„ç¨‹åºåœ¨è¿è¡Œæ—¶éƒ½å¿…é¡»ç®¡ç†å®ƒä»¬ä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„æ–¹å¼
  + æœ‰äº›è¯­è¨€æœ‰åƒåœ¾å›æ”¶æœºåˆ¶ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶ï¼Œå®ƒä»¬ä¼šä¸æ–­åœ°å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜
  + åœ¨å…¶å®ƒè¯­è¨€ä¸­ï¼Œç¨‹åºå‘˜å¿…é¡»æ˜¾å¼åœ°åˆ†é…å’Œé‡Šæ”¾å†…å­˜
+ Rusté‡‡ç”¨äº†ç¬¬ä¸‰ç§æ–¹å¼
  + å†…å­˜é€šè¿‡ä¸€ä¸ªæ‰€æœ‰æƒç³»ç»Ÿæ¥ç®¡ç†çš„ï¼Œå…¶ä¸­åŒ…å«ä¸€ç»„ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥çš„è§„åˆ™
  + å½“å†…å­˜è¿è¡Œæ—¶ï¼Œæ‰€æœ‰æƒç‰¹æ€§ä¸ä¼šå‡æ…¢ç¨‹åºçš„è¿è¡Œé€Ÿåº¦

#### 4.1.1 Stack vs Heap

+ åœ¨åƒ Rust è¿™æ ·çš„ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå€¼æ˜¯ä½äºæ ˆä¸Šè¿˜æ˜¯å †ä¸Šåœ¨æ›´å¤§ç¨‹åº¦ä¸Šå½±å“äº†è¯­è¨€çš„è¡Œä¸ºä»¥åŠä¸ºä½•å¿…é¡»åšå‡ºè¿™æ ·çš„æŠ‰æ‹©
+ åœ¨ä½ çš„ä»£ç è¿è¡Œçš„æ—¶å€™ï¼Œæ ˆå’Œå †éƒ½æ˜¯ä»£ç åœ¨è¿è¡Œæ—¶å¯ä¾›ä½¿ç”¨çš„å†…å­˜ï¼Œä½†æ˜¯å®ƒä»¬çš„ç»“æ„ä¸åŒ
+ æ ˆä»¥æ”¾å…¥å€¼çš„é¡ºåºå­˜å‚¨å€¼å¹¶ä»¥ç›¸åé¡ºåºå–å‡ºå€¼ã€‚è¿™ä¹Ÿè¢«ç§°ä½œ **åè¿›å…ˆå‡º**ï¼ˆ*last in, first out*ï¼‰
  + å¢åŠ æ•°æ®å«åš **è¿›æ ˆ**ï¼ˆ*pushing onto the stack*ï¼‰ï¼Œè€Œç§»å‡ºæ•°æ®å«åš **å‡ºæ ˆ**ï¼ˆ*popping off the stack*ï¼‰
  + æ ˆä¸­çš„æ‰€æœ‰æ•°æ®éƒ½å¿…é¡»å ç”¨å·²çŸ¥ä¸”å›ºå®šçš„å¤§å°ã€‚
  + åœ¨ç¼–è¯‘æ—¶å¤§å°æœªçŸ¥æˆ–å¤§å°å¯èƒ½å˜åŒ–çš„æ•°æ®ï¼Œè¦æ”¹ä¸ºå­˜å‚¨åœ¨å †ä¸Šã€‚ 
+ å †æ˜¯ç¼ºä¹ç»„ç»‡çš„
  + å½“å‘å †æ”¾å…¥æ•°æ®æ—¶ï¼Œä½ è¦è¯·æ±‚ä¸€å®šå¤§å°çš„ç©ºé—´ã€‚
  + å†…å­˜åˆ†é…å™¨ï¼ˆmemory allocatorï¼‰åœ¨å †çš„æŸå¤„æ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„ç©ºä½ï¼ŒæŠŠå®ƒæ ‡è®°ä¸ºå·²ä½¿ç”¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªè¡¨ç¤ºè¯¥ä½ç½®åœ°å€çš„ **æŒ‡é’ˆ**ï¼ˆ*pointer*ï¼‰ã€‚è¿™ä¸ªè¿‡ç¨‹ç§°ä½œ **åœ¨å †ä¸Šåˆ†é…å†…å­˜**ï¼ˆ*allocating on the heap*ï¼‰ï¼Œæœ‰æ—¶ç®€ç§°ä¸º â€œåˆ†é…â€ï¼ˆallocatingï¼‰å†…å­˜åˆ†é…å™¨ï¼ˆmemory allocatorï¼‰åœ¨å †çš„æŸå¤„æ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„ç©ºä½ï¼ŒæŠŠå®ƒæ ‡è®°ä¸ºå·²ä½¿ç”¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªè¡¨ç¤ºè¯¥ä½ç½®åœ°å€çš„ **æŒ‡é’ˆ**ï¼ˆ*pointer*ï¼‰ã€‚è¿™ä¸ªè¿‡ç¨‹ç§°ä½œ **åœ¨å †ä¸Šåˆ†é…å†…å­˜**ï¼ˆ*allocating on the heap*ï¼‰ï¼Œæœ‰æ—¶ç®€ç§°ä¸º â€œåˆ†é…â€ï¼ˆallocatingï¼‰
+ æŠŠå€¼å‹åˆ°stackä¸Šä¸å«åˆ†é…ï¼Œå› ä¸ºæŒ‡é’ˆçš„å¤§å°æ˜¯å·²çŸ¥å›ºå®šçš„ï¼Œå¯ä»¥æŠŠæŒ‡é’ˆå­˜æ”¾åœ¨stackä¸Š
  + ä½†å¦‚æœæƒ³è¦è®¿é—®å®é™…æ•°æ®ï¼Œåˆ™å¿…é¡»ä½¿ç”¨æŒ‡é’ˆæ¥å®šä½
+ å…¥æ ˆæ¯”åœ¨å †ä¸Šåˆ†é…å†…å­˜è¦å¿«
  + å› ä¸ºï¼ˆå…¥æ ˆæ—¶ï¼‰åˆ†é…å™¨æ— éœ€ä¸ºå­˜å‚¨æ–°æ•°æ®å»æœç´¢å†…å­˜ç©ºé—´ï¼›å…¶ä½ç½®æ€»æ˜¯åœ¨æ ˆé¡¶
  + ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨å †ä¸Šåˆ†é…å†…å­˜åˆ™éœ€è¦æ›´å¤šçš„å·¥ä½œï¼Œè¿™æ˜¯å› ä¸ºåˆ†é…å™¨å¿…é¡»é¦–å…ˆæ‰¾åˆ°ä¸€å—è¶³å¤Ÿå­˜æ”¾æ•°æ®çš„å†…å­˜ç©ºé—´ï¼Œå¹¶æ¥ç€åšä¸€äº›è®°å½•ä¸ºä¸‹ä¸€æ¬¡åˆ†é…åšå‡†å¤‡ã€‚
+ è®¿é—®å †ä¸Šçš„æ•°æ®æ¯”è®¿é—®æ ˆä¸Šçš„æ•°æ®æ…¢ï¼Œå› ä¸ºå¿…é¡»é€šè¿‡æŒ‡é’ˆæ¥è®¿é—®
  + å¯¹äºç°ä»£çš„å¤„ç†å™¨æ¥è¯´ï¼Œç”±äºç¼“å­˜çš„ç¼˜æ•…ï¼Œå¦‚æœæŒ‡ä»¤åœ¨å†…å­˜ä¸­è·³è½¬çš„æ¬¡æ•°è¶Šå°‘ï¼Œé‚£ä¹ˆé€Ÿåº¦å°±è¶Šå¿«
+ å‡ºäºåŒæ ·åŸå› ï¼Œå¤„ç†å™¨åœ¨å¤„ç†çš„æ•°æ®å½¼æ­¤è¾ƒè¿‘çš„æ—¶å€™ï¼ˆæ¯”å¦‚åœ¨æ ˆä¸Šï¼‰æ¯”è¾ƒè¿œçš„æ—¶å€™ï¼ˆæ¯”å¦‚å¯èƒ½åœ¨å †ä¸Šï¼‰èƒ½æ›´å¥½çš„å·¥ä½œã€‚
  + åœ¨heapä¸Šåˆ†é…å¤§é‡çš„ç©ºé—´ä¹Ÿæ˜¯éœ€è¦æ—¶é—´çš„
+ å½“ä½ çš„ä»£ç è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œä¼ é€’ç»™å‡½æ•°çš„å€¼ï¼ˆåŒ…æ‹¬å¯èƒ½æŒ‡å‘å †ä¸Šæ•°æ®çš„æŒ‡é’ˆï¼‰å’Œå‡½æ•°çš„å±€éƒ¨å˜é‡è¢«å‹å…¥æ ˆä¸­ã€‚å½“å‡½æ•°ç»“æŸæ—¶ï¼Œè¿™äº›å€¼è¢«ç§»å‡ºæ ˆã€‚

#### 4.1.2 æ‰€æœ‰æƒå­˜åœ¨çš„åŸå› 

+ æ‰€æœ‰æƒè§£å†³çš„é—®é¢˜
  + è·Ÿè¸ªä»£ç çš„å“ªäº›éƒ¨åˆ†æ­£åœ¨ä½¿ç”¨heapçš„å“ªäº›æ•°æ®
  + æœ€å°åŒ–heapä¸Šçš„é‡å¤æ•°æ®é‡
  + æ¸…ç†heapä¸Šæœªä½¿ç”¨çš„æ•°æ®ä»¥é¿å…ç©ºé—´ä¸è¶³
+ ä¸€æ—¦ç†è§£äº†æ‰€æœ‰æƒï¼Œä½ å°±ä¸éœ€è¦ç»å¸¸è€ƒè™‘æ ˆå’Œå †äº†ï¼Œä¸è¿‡æ˜ç™½äº†æ‰€æœ‰æƒçš„ä¸»è¦ç›®çš„å°±æ˜¯ä¸ºäº†ç®¡ç†å †æ•°æ®ï¼Œè¿™ä¹Ÿèƒ½å¤Ÿå¸®åŠ©è§£é‡Šä¸ºä»€ä¹ˆæ‰€æœ‰æƒè¦ä»¥è¿™ç§æ–¹å¼å·¥ä½œã€‚

#### 4.1.3 æ‰€æœ‰æƒè§„åˆ™

+ æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡ï¼Œè¿™ä¸ªå˜é‡æ˜¯è¯¥å€¼çš„æ‰€æœ‰è€…ï¼ˆownerï¼‰
+ æ¯ä¸ªå€¼åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
+ å½“æ‰€æœ‰è€…ç¦»å¼€ä½œç”¨åŸŸï¼ˆscopeï¼‰æ—¶ï¼Œè¯¥å€¼å°†è¢«åˆ é™¤

#### 4.1.4 å˜é‡ä½œç”¨åŸŸ

+ `Scope`å°±æ˜¯ç¨‹åºä¸­ä¸€ä¸ªé¡¹ï¼ˆitemï¼‰åœ¨ç¨‹åºä¸­çš„æœ‰æ•ˆèŒƒå›´

  ```rust
  fn main() {
      // s ä¸å¯ç”¨
      let s = "hello"; // s å¯ç”¨
      // å¯ä»¥å¯¹ s è¿›è¡Œç›¸å…³çš„æ“ä½œ
  } // ä½œç”¨åŸŸåˆ°æ­¤ç»“æŸï¼Œs ä¸å†å¯ç”¨
  ```

#### 4.1.5 Stringç±»å‹

+ `String`æ¯”åŸºç¡€æ ‡é‡æ•°æ®ç±»å‹æ›´å¤æ‚

+ å­—ç¬¦ä¸²å­—é¢å€¼ï¼šç¨‹åºé‡Œæ‰‹å†™çš„é‚£äº›å­—ç¬¦ä¸²å€¼ã€‚å®ƒä»¬æ˜¯ä¸å¯å˜çš„

+ Rustè¿˜æœ‰ç¬¬äºŒç§å­—ç¬¦ä¸²ç±»å‹ï¼šString

  + `String`ç±»å‹ç®¡ç†è¢«åˆ†é…åˆ°å †ä¸Šçš„æ•°æ®ï¼Œæ‰€ä»¥èƒ½å¤Ÿå­˜å‚¨åœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„æ–‡æœ¬

+ åˆ›å»º`String`ç±»å‹çš„å€¼

  + å¯ä»¥ä½¿ç”¨ `from` å‡½æ•°åŸºäºå­—ç¬¦ä¸²å­—é¢å€¼æ¥åˆ›å»º `String`

  + `let s = String::from("hello")`

    + `::` æ˜¯è¿ç®—ç¬¦ï¼Œå…è®¸å°†ç‰¹å®šçš„ `from` å‡½æ•°ç½®äº `String` ç±»å‹çš„å‘½åç©ºé—´ï¼ˆnamespaceï¼‰ä¸‹ï¼Œè€Œä¸éœ€è¦ä½¿ç”¨ç±»ä¼¼ `string_from` è¿™æ ·çš„åå­—ï¼Œä¹Ÿå°±æ˜¯`from`æ˜¯`String`ç±»å‹ä¸‹çš„å‡½æ•°

    + è¿™ç±»å­—ç¬¦ä¸²æ˜¯å¯ä»¥è¢«ä¿®æ”¹çš„

      ```rust
      fn main() {
          let mut s = String::from("hello");
      
          s.push_str(", world");
      
          println!("{}", s);
      }
      ```

    + ä¸ºä»€ä¹ˆ`String`ç±»å‹çš„å€¼å¯ä»¥ä¿®æ”¹ï¼Œè€Œå­—ç¬¦ä¸²å­—é¢å€¼å´ä¸èƒ½ä¿®æ”¹ï¼Ÿ
      + å› ä¸ºå®ƒä»¬å¤„ç†å†…å­˜çš„æ–¹å¼ä¸åŒ

#### 4.1.6 å†…å­˜ä¸åˆ†é…

+ å°±å­—ç¬¦ä¸²å­—é¢å€¼æ¥è¯´ï¼Œæˆ‘ä»¬åœ¨ç¼–è¯‘æ—¶å°±çŸ¥é“å…¶å†…å®¹ï¼Œæ‰€ä»¥æ–‡æœ¬è¢«ç›´æ¥ç¡¬ç¼–ç è¿›æœ€ç»ˆçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸­

  + è¿™ä½¿å¾—å­—ç¬¦ä¸²å­—é¢å€¼å¿«é€Ÿä¸”é«˜æ•ˆï¼Œè¿™äº›ç‰¹æ€§éƒ½åªå¾—ç›Šäºå­—ç¬¦ä¸²å­—é¢å€¼çš„ä¸å¯å˜æ€§

+ å¯¹äº `String` ç±»å‹ï¼Œä¸ºäº†æ”¯æŒä¸€ä¸ªå¯å˜ï¼Œå¯å¢é•¿çš„æ–‡æœ¬ç‰‡æ®µï¼Œéœ€è¦åœ¨å †ä¸Šåˆ†é…ä¸€å—åœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„å†…å­˜æ¥å­˜æ”¾å†…å®¹

  + å¿…é¡»åœ¨è¿è¡Œæ—¶å‘å†…å­˜åˆ†é…å™¨ï¼ˆmemory allocatorï¼‰è¯·æ±‚å†…å­˜

    + â€‹	è¿™æ­¥é€šè¿‡è°ƒç”¨`String::from`æ¥å®ç°

  + å½“æˆ‘ä»¬å¤„ç†å®Œ `String` æ—¶ï¼Œéœ€è¦ä½¿ç”¨æŸç§æ–¹å¼å°†å†…å­˜è¿”å›ç»™åˆ†é…å™¨

    + åœ¨æœ‰ **åƒåœ¾å›æ”¶**ï¼ˆ*garbage collector*ï¼Œ*GC*ï¼‰çš„è¯­è¨€ä¸­ï¼Œ GC è®°å½•å¹¶æ¸…é™¤ä¸å†ä½¿ç”¨çš„å†…å­˜
    + åœ¨å¤§éƒ¨åˆ†æ²¡æœ‰ GC çš„è¯­è¨€ä¸­ï¼Œè¯†åˆ«å‡ºä¸å†ä½¿ç”¨çš„å†…å­˜å¹¶è°ƒç”¨ä»£ç æ˜¾å¼é‡Šæ”¾å°±æ˜¯æˆ‘ä»¬çš„è´£ä»»äº†
      + å¦‚æœå¿˜è®°å›æ”¶äº†ä¼šæµªè´¹å†…å­˜
      + å¦‚æœè¿‡æ—©å›æ”¶äº†ï¼Œå°†ä¼šå‡ºç°æ— æ•ˆå˜é‡ï¼Œå˜é‡å°±ä¼šéæ³•
      + å¦‚æœé‡å¤å›æ”¶ï¼Œè¿™ä¹Ÿæ˜¯ä¸ª bugã€‚æˆ‘ä»¬éœ€è¦ç²¾ç¡®çš„ä¸ºä¸€ä¸ª `allocate` é…å¯¹ä¸€ä¸ª `free`

  + Rust é‡‡å–äº†ä¸€ä¸ªä¸åŒçš„ç­–ç•¥ï¼šå†…å­˜åœ¨æ‹¥æœ‰å®ƒçš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸåå°±è¢«è‡ªåŠ¨é‡Šæ”¾ã€‚

    ```rust
    fn main() {
        {
            let s = String::from("hello"); // ä»æ­¤å¤„èµ·ï¼Œs æ˜¯æœ‰æ•ˆçš„
            // ä½¿ç”¨ s
        }                                  // æ­¤ä½œç”¨åŸŸå·²ç»“æŸ       
    }                                      // s ä¸å†æœ‰æ•ˆ
    ```
    
  + å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸï¼ŒRust ä¸ºæˆ‘ä»¬è°ƒç”¨ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°å«åš [`drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop)ï¼Œåœ¨è¿™é‡Œ `String` çš„ä½œè€…å¯ä»¥æ”¾ç½®é‡Šæ”¾å†…å­˜çš„ä»£ç ã€‚Rust åœ¨ç»“å°¾çš„ `}` å¤„è‡ªåŠ¨è°ƒç”¨ `drop`

#### 4.1.7 å˜é‡ä¸æ•°æ®äº¤äº’çš„æ–¹å¼

> åœ¨Rust ä¸­ï¼Œå¤šä¸ªå˜é‡å¯ä»¥é‡‡å–ä¸åŒçš„æ–¹å¼ä¸åŒä¸€æ•°æ®è¿›è¡Œäº¤äº’

+ ç§»åŠ¨

  ```rust
  fn main() {
      let x = 5;
      let y = x;
  }
  ```
  
  æ•´æ•°æ˜¯æœ‰å·²çŸ¥å›ºå®šå¤§å°çš„ç®€å•å€¼ï¼Œæ‰€ä»¥è¿™ä¸¤ä¸ª 5 è¢«æ”¾å…¥äº†æ ˆä¸­
  
  ```rust
  fn main() {
      let s1 = String::from("hello");
      let s2 = s1;
  }
  ```
  
  æƒ…å†µå’Œå‰é¢çš„ä¾‹å­ä¸åŒ
  
  + `String` ç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼Œè¿™ä¸€ç»„æ•°æ®å­˜å‚¨åœ¨æ ˆä¸Š
  
    + ä¸€ä¸ªæŒ‡å‘å­˜æ”¾å­—ç¬¦ä¸²å†…å®¹å†…å­˜çš„æŒ‡é’ˆ
    + ä¸€ä¸ªé•¿åº¦
    + ä¸€ä¸ªå®¹é‡
  
  + å­˜æ”¾å­—ç¬¦ä¸²å†…å®¹çš„éƒ¨åˆ†åœ¨heapä¸Š
  
  + é•¿åº¦lenï¼Œå°±æ˜¯å­˜æ”¾å­—ç¬¦ä¸²å†…å®¹æ‰€éœ€çš„å­—èŠ‚æ•°
  
  + å®¹é‡capacityæ˜¯æŒ‡`String`ä»å†…å­˜åˆ†é…å™¨æ€»å…±è·å¾—çš„å†…å­˜çš„æ€»å­—èŠ‚æ•°
  
  ![String in memory](assets/String_in_memory.svg)
  
  + å½“æˆ‘ä»¬å°† `s1` èµ‹å€¼ç»™ `s2`ï¼Œ`String` çš„æ•°æ®è¢«å¤åˆ¶äº†ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬ä»æ ˆä¸Šæ‹·è´äº†å®ƒçš„æŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡ã€‚æˆ‘ä»¬å¹¶æ²¡æœ‰å¤åˆ¶æŒ‡é’ˆæŒ‡å‘çš„å †ä¸Šæ•°æ®ã€‚
  
    ![the same value](the_same_value.svg)
  
  + å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸåï¼ŒRust è‡ªåŠ¨è°ƒç”¨ `drop` å‡½æ•°å¹¶æ¸…ç†å˜é‡çš„å †å†…å­˜
  
  + è¿™å°±æœ‰äº†ä¸€ä¸ªé—®é¢˜ï¼šå½“ `s2` å’Œ `s1` ç¦»å¼€ä½œç”¨åŸŸï¼Œä»–ä»¬éƒ½ä¼šå°è¯•é‡Šæ”¾ç›¸åŒçš„å†…å­˜
  
    + è¿™æ˜¯ä¸€ä¸ªå«åš **äºŒæ¬¡é‡Šæ”¾**ï¼ˆ*double free*ï¼‰çš„é”™è¯¯ï¼Œä¹Ÿæ˜¯ä¹‹å‰æåˆ°è¿‡çš„å†…å­˜å®‰å…¨æ€§ bug ä¹‹ä¸€
    + ä¸¤æ¬¡é‡Šæ”¾ï¼ˆç›¸åŒï¼‰å†…å­˜ä¼šå¯¼è‡´å†…å­˜æ±¡æŸ“ï¼Œå®ƒå¯èƒ½ä¼šå¯¼è‡´æ½œåœ¨çš„å®‰å…¨æ¼æ´
  
  + ç¡®ä¿å†…å­˜å®‰å…¨
  
    + Rustæ²¡æœ‰å°è¯•å¤åˆ¶è¢«åˆ†é…çš„å†…å­˜
    + Rust è®¤ä¸º `s1` ä¸å†æœ‰æ•ˆ
      + Rust ä¸éœ€è¦åœ¨ `s1` ç¦»å¼€ä½œç”¨åŸŸåæ¸…ç†ä»»ä½•ä¸œè¥¿
  
    ```rust
    fn main() {
        let s1 = String::from("hello");
        let s2 = s1;
    
        println!("{}, world!", s1);
    }
    ```
  
  + ä½ ä¼šå¾—åˆ°ä¸€ä¸ªç±»ä¼¼å¦‚ä¸‹çš„é”™è¯¯ï¼Œå› ä¸º Rust ç¦æ­¢ä½ ä½¿ç”¨æ— æ•ˆçš„å¼•ç”¨
  
    ```rust
    error[E0382]: borrow of moved value: `s1`
     --> src\main.rs:5:28
      |
    2 |     let s1 = String::from("hello");
      |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
    3 |     let s2 = s1;
      |              -- value moved here
    4 |
    5 |     println!("{}, world!", s1);
      |                            ^^ value borrowed here after move
      |
      = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
    
    For more information about this error, try `rustc --explain E0382`.
    warning: `owner` (bin "owner") generated 1 warning
    error: could not compile `owner` due to previous error; 1 warning emitted
    ```
  
  + å¦‚æœä½ åœ¨å…¶ä»–è¯­è¨€ä¸­å¬è¯´è¿‡æœ¯è¯­ **æµ…æ‹·è´**ï¼ˆ*shallow copy*ï¼‰å’Œ **æ·±æ‹·è´**ï¼ˆ*deep copy*ï¼‰ï¼Œé‚£ä¹ˆæ‹·è´æŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡è€Œä¸æ‹·è´æ•°æ®å¯èƒ½å¬èµ·æ¥åƒæµ…æ‹·è´ã€‚ä¸è¿‡å› ä¸º Rust åŒæ—¶ä½¿ç¬¬ä¸€ä¸ªå˜é‡æ— æ•ˆäº†ï¼Œè¿™ä¸ªæ“ä½œè¢«ç§°ä¸º **ç§»åŠ¨**ï¼ˆ*move*ï¼‰ï¼Œè€Œä¸æ˜¯æµ…æ‹·è´ã€‚ä¸Šé¢çš„ä¾‹å­å¯ä»¥è§£è¯»ä¸º `s1` è¢« **ç§»åŠ¨** åˆ°äº† `s2` ä¸­ã€‚
  
    ![s1 moved to s2](assets/s1_moved_to_s2.svg)
  
  + è¿™é‡Œè¿˜éšå«äº†ä¸€ä¸ªè®¾è®¡é€‰æ‹©ï¼šRust æ°¸è¿œä¹Ÿä¸ä¼šè‡ªåŠ¨åˆ›å»ºæ•°æ®çš„ â€œæ·±æ‹·è´â€ã€‚å› æ­¤ï¼Œä»»ä½• **è‡ªåŠ¨** çš„å¤åˆ¶å¯ä»¥è¢«è®¤ä¸ºå¯¹è¿è¡Œæ—¶æ€§èƒ½å½±å“è¾ƒå°
  
+ å…‹éš†

  + å¦‚æœæˆ‘ä»¬ **ç¡®å®** éœ€è¦æ·±åº¦å¤åˆ¶ `String` ä¸­å †ä¸Šçš„æ•°æ®ï¼Œè€Œä¸ä»…ä»…æ˜¯æ ˆä¸Šçš„æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªå«åš `clone` çš„é€šç”¨å‡½æ•°

    ```rust
    fn main() {
        let s1 = String::from("hello");
        let s2 = s1.clone();
    
        println!("s1 = {}, s2 = {}", s1, s2);
    }
    ```

  + åªåœ¨æ ˆä¸Šçš„æ•°æ®ï¼šæ‹·è´
  
    + è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªæ²¡æœ‰æåˆ°çš„å°çªé—¨ã€‚è¿™äº›ä»£ç ä½¿ç”¨äº†æ•´å‹å¹¶ä¸”æ˜¯æœ‰æ•ˆçš„
  
      ```rust
      fn main() {
          let x = 5;
          let y = x;
      
          println!("x = {}, y = {}", x, y);
      }
      ```
  
    + ä½†è¿™æ®µä»£ç ä¼¼ä¹ä¸æˆ‘ä»¬åˆšåˆšå­¦åˆ°çš„å†…å®¹ç›¸çŸ›ç›¾ï¼šæ²¡æœ‰è°ƒç”¨ `clone`ï¼Œä¸è¿‡ `x` ä¾ç„¶æœ‰æ•ˆä¸”æ²¡æœ‰è¢«ç§»åŠ¨åˆ° `y` ä¸­
    + åŸå› æ˜¯åƒæ•´å‹è¿™æ ·çš„åœ¨ç¼–è¯‘æ—¶å·²çŸ¥å¤§å°çš„ç±»å‹è¢«æ•´ä¸ªå­˜å‚¨åœ¨æ ˆä¸Šï¼Œæ‰€ä»¥æ‹·è´å…¶å®é™…çš„å€¼æ˜¯å¿«é€Ÿçš„ã€‚è¿™æ„å‘³ç€æ²¡æœ‰ç†ç”±åœ¨åˆ›å»ºå˜é‡ `y` åä½¿ `x` æ— æ•ˆã€‚æ¢å¥è¯è¯´ï¼Œè¿™é‡Œæ²¡æœ‰æ·±æµ…æ‹·è´çš„åŒºåˆ«ï¼Œæ‰€ä»¥è¿™é‡Œè°ƒç”¨ `clone` å¹¶ä¸ä¼šä¸é€šå¸¸çš„æµ…æ‹·è´æœ‰ä»€ä¹ˆä¸åŒï¼Œæˆ‘ä»¬å¯ä»¥ä¸ç”¨ç®¡å®ƒã€‚
    + Rust æœ‰ä¸€ä¸ªå«åš `Copy` trait çš„ç‰¹æ®Šæ³¨è§£ï¼Œå¯ä»¥ç”¨åœ¨ç±»ä¼¼æ•´å‹è¿™æ ·çš„å­˜å‚¨åœ¨æ ˆä¸Šçš„ç±»å‹ä¸Šï¼Œå¦‚æœä¸€ä¸ªç±»å‹å®ç°äº† `Copy` traitï¼Œé‚£ä¹ˆä¸€ä¸ªæ—§çš„å˜é‡åœ¨å°†å…¶èµ‹å€¼ç»™å…¶ä»–å˜é‡åä»ç„¶å¯ç”¨
    + å¦‚æœä¸€ä¸ªç±»å‹æˆ–è€…è¯¥ç±»å‹çš„ä¸€éƒ¨åˆ†å®ç°ç±» `Drop`traitï¼Œé‚£ä¹ˆRustä¸å…è®¸è®©å®ƒå†å»å®ç°`Copy`trait
      + ä»»ä½•ä¸€ç»„ç®€å•æ ‡é‡å€¼çš„ç»„åˆéƒ½å¯ä»¥å®ç° `Copy`
      + ä»»ä½•ä¸éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§å½¢å¼èµ„æºçš„ç±»å‹éƒ½å¯ä»¥å®ç° `Copy`
      + ä¸€äº›æ‹¥æœ‰`Copy`traitçš„ç±»å‹
        + æ‰€æœ‰æ•´æ•°ç±»å‹ï¼Œæ¯”å¦‚ `u32`ã€‚
        + å¸ƒå°”ç±»å‹ï¼Œ`bool`ï¼Œå®ƒçš„å€¼æ˜¯ `true` å’Œ `false`ã€‚
        + æ‰€æœ‰æµ®ç‚¹æ•°ç±»å‹ï¼Œæ¯”å¦‚ `f64`ã€‚
        + å­—ç¬¦ç±»å‹ï¼Œ`char`ã€‚
        + å…ƒç»„ï¼Œå½“ä¸”ä»…å½“å…¶åŒ…å«çš„ç±»å‹ä¹Ÿéƒ½å®ç° `Copy` çš„æ—¶å€™ã€‚æ¯”å¦‚ï¼Œ`(i32, i32)` å®ç°äº† `Copy`ï¼Œä½† `(i32, String)` å°±æ²¡æœ‰ã€‚
  

#### 4.1.8 æ‰€æœ‰æƒä¸å‡½æ•°

+ å°†å€¼ä¼ é€’ç»™å‡½æ•°ä¸ç»™å˜é‡èµ‹å€¼çš„åŸç†ç›¸ä¼¼

  + å°†å€¼ä¼ é€’ç»™å‡½æ•°å°†å‘ç”Ÿç§»åŠ¨æˆ–å¤åˆ¶

  ```rust
  fn main() {
      let s = String::from("hello");  // s è¿›å…¥ä½œç”¨åŸŸ
  
      takes_ownership(s);             // s çš„å€¼ç§»åŠ¨åˆ°å‡½æ•°é‡Œ ...
                                      // ... æ‰€ä»¥åˆ°è¿™é‡Œä¸å†æœ‰æ•ˆ
  
      let x = 5;                      // x è¿›å…¥ä½œç”¨åŸŸ
  
      makes_copy(x);                  // x åº”è¯¥ç§»åŠ¨å‡½æ•°é‡Œï¼Œ
                                      // ä½† i32 æ˜¯ Copy çš„ï¼Œ
                                      // æ‰€ä»¥åœ¨åé¢å¯ç»§ç»­ä½¿ç”¨ x
  
  } // è¿™é‡Œ, x å…ˆç§»å‡ºäº†ä½œç”¨åŸŸï¼Œç„¶åæ˜¯ sã€‚ä½†å› ä¸º s çš„å€¼å·²è¢«ç§»èµ°ï¼Œ
    // æ²¡æœ‰ç‰¹æ®Šä¹‹å¤„
  
  fn takes_ownership(some_string: String) { // some_string è¿›å…¥ä½œç”¨åŸŸ
      println!("{}", some_string);
  } // è¿™é‡Œï¼Œsome_string ç§»å‡ºä½œç”¨åŸŸå¹¶è°ƒç”¨ `drop` æ–¹æ³•ã€‚
    // å ç”¨çš„å†…å­˜è¢«é‡Šæ”¾
  
  fn makes_copy(some_integer: i32) { // some_integer è¿›å…¥ä½œç”¨åŸŸ
      println!("{}", some_integer);
  } // è¿™é‡Œï¼Œsome_integer ç§»å‡ºä½œç”¨åŸŸã€‚æ²¡æœ‰ç‰¹æ®Šä¹‹å¤„
  ```

#### 4.1.9 è¿”å›å€¼ä¸ä½œç”¨åŸŸ

+ å‡½æ•°åœ¨è¿”å›å€¼çš„è¿‡ç¨‹ä¸­åŒæ ·ä¹Ÿä¼šå‘ç”Ÿæ‰€æœ‰æƒçš„è½¬ç§»

  ```rust
  fn main() {
      let s1 = gives_ownership(); // gives_ownership å°†è¿”å›å€¼
                                      // è½¬ç§»ç»™ s1
  
      let s2 = String::from("hello"); // s2 è¿›å…¥ä½œç”¨åŸŸ
  
      let s3 = takes_and_gives_back(s2); // s2 è¢«ç§»åŠ¨åˆ°
                                         // takes_and_gives_back ä¸­,
                                         // å®ƒä¹Ÿå°†è¿”å›å€¼ç§»ç»™ s3
  } // è¿™é‡Œ, s3 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚s2 ä¹Ÿç§»å‡ºä½œç”¨åŸŸï¼Œä½†å·²è¢«ç§»èµ°ï¼Œ
    // æ‰€ä»¥ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿã€‚s1 ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ
  
  fn gives_ownership() -> String {
      // gives_ownership ä¼šå°†
      // è¿”å›å€¼ç§»åŠ¨ç»™
      // è°ƒç”¨å®ƒçš„å‡½æ•°
  
      let some_string = String::from("yours"); // some_string è¿›å…¥ä½œç”¨åŸŸ.
  
      some_string // è¿”å› some_string
                  // å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
                  //
  }
  
  // takes_and_gives_back å°†ä¼ å…¥å­—ç¬¦ä¸²å¹¶è¿”å›è¯¥å€¼
  fn takes_and_gives_back(a_string: String) -> String {
      // a_string è¿›å…¥ä½œç”¨åŸŸ
      //
  
      a_string // è¿”å› a_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
  }
  ```

+ ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒæ€»æ˜¯éµå¾ªåŒæ ·çš„æ¨¡å¼

  + æŠŠä¸€ä¸ªå€¼èµ‹ç»™å…¶å®ƒå˜é‡æ—¶å°±ä¼šå‘ç”Ÿç§»åŠ¨
  + å½“ä¸€ä¸ªåŒ…å«heapæ•°æ®çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒçš„å€¼å°±ä¼šè¢«`drop`å‡½æ•°æ¸…ç†ï¼Œé™¤éæ•°æ®çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°å¦ä¸€ä¸ªå˜é‡ä¸Šäº†

+ å¦‚æœæˆ‘ä»¬æƒ³è¦å‡½æ•°ä½¿ç”¨ä¸€ä¸ªå€¼ä½†ä¸è·å–æ‰€æœ‰æƒè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ

  ```rust
  fn main() {
      let s1 = String::from("hello");
  
      let (s2, len) = calculate_length(s1);
  
      println!("The length of '{}' is {}.", s2, len);
  }
  
  fn calculate_length(s: String) -> (String, usize) {
      let length = s.len(); // len() è¿”å›å­—ç¬¦ä¸²çš„é•¿åº¦
  
      (s, length)
  }
  ```

  ä½†æ˜¯è¿™æœªå…æœ‰äº›å½¢å¼ä¸»ä¹‰ï¼Œè€Œä¸”è¿™ç§åœºæ™¯åº”è¯¥å¾ˆå¸¸è§

+ Rust å¯¹æ­¤æä¾›äº†ä¸€ä¸ªä¸ç”¨è·å–æ‰€æœ‰æƒå°±å¯ä»¥ä½¿ç”¨å€¼çš„åŠŸèƒ½ï¼Œå«åš **å¼•ç”¨**ï¼ˆ*references*ï¼‰



### 4.2 å¼•ç”¨å’Œå€Ÿç”¨

#### 4.2.1 å¼•ç”¨ï¼ˆreferenceï¼‰

+ æˆ‘ä»¬å¯ä»¥æä¾›ä¸€ä¸ª `String` å€¼çš„å¼•ç”¨ï¼ˆreferenceï¼‰ã€‚**å¼•ç”¨**ï¼ˆ*reference*ï¼‰åƒä¸€ä¸ªæŒ‡é’ˆï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªåœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥ç”±æ­¤è®¿é—®å‚¨å­˜äºè¯¥åœ°å€çš„å±äºå…¶ä»–å˜é‡çš„æ•°æ®ã€‚ ä¸æŒ‡é’ˆä¸åŒï¼Œå¼•ç”¨ç¡®ä¿æŒ‡å‘æŸä¸ªç‰¹å®šç±»å‹çš„æœ‰æ•ˆå€¼ã€‚

  ```rust
  fn main() {
      let s1 = String::from("hello");
  
      let len = calculate_length(&s1);
  
      println!("The length of '{}' is {}.", s1, len);
  }
  
  fn calculate_length(s: &String) -> usize {
      s.len()
  }
  ```

+ æˆ‘ä»¬ä¼ é€’ `&s1` ç»™ `calculate_length`ï¼ŒåŒæ—¶åœ¨å‡½æ•°å®šä¹‰ä¸­ï¼Œæˆ‘ä»¬è·å– `&String` è€Œä¸æ˜¯ `String`ã€‚è¿™äº› & ç¬¦å·å°±æ˜¯ **å¼•ç”¨**ï¼Œå®ƒä»¬å…è®¸ä½ ä½¿ç”¨å€¼ä½†ä¸è·å–å…¶æ‰€æœ‰æƒ

  ![&String s pointing at String s1](assets/&String_s_pointing_at_String_s1.svg)

#### 4.2.2 å€Ÿç”¨ï¼ˆborrowingï¼‰

+ æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªå¼•ç”¨çš„è¡Œä¸ºç§°ä¸º **å€Ÿç”¨**ï¼ˆ*borrowing*ï¼‰ã€‚æ­£å¦‚ç°å®ç”Ÿæ´»ä¸­ï¼Œå¦‚æœä¸€ä¸ªäººæ‹¥æœ‰æŸæ ·ä¸œè¥¿ï¼Œä½ å¯ä»¥ä»ä»–é‚£é‡Œå€Ÿæ¥ã€‚å½“ä½ ä½¿ç”¨å®Œæ¯•ï¼Œå¿…é¡»è¿˜å›å»ã€‚æˆ‘ä»¬å¹¶ä¸æ‹¥æœ‰å®ƒ

+ å¦‚æœæˆ‘ä»¬å°è¯•ä¿®æ”¹å€Ÿç”¨çš„å˜é‡å‘¢ï¼Ÿ

  ```rust
  fn main() {
      let s = String::from("hello");
  
      change(&s);
  }
  
  fn change(some_string: &String) {
      some_string.push_str(", world");
  }
  ```

  ```rust
  $ cargo run
     Compiling ownership v0.1.0 (file:///projects/ownership)
  error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
   --> src/main.rs:8:5
    |
  7 | fn change(some_string: &String) {
    |                        ------- help: consider changing this to be a mutable reference: `&mut String`
  8 |     some_string.push_str(", world");
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable
  
  For more information about this error, try `rustc --explain E0596`.
  error: could not compile `ownership` due to previous error
  ```

  æ­£å¦‚å˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼Œå¼•ç”¨ä¹Ÿä¸€æ ·ã€‚ï¼ˆé»˜è®¤ï¼‰ä¸å…è®¸ä¿®æ”¹å¼•ç”¨çš„å€¼ï¼ˆå³ä¸èƒ½ä¹±ä¿®æ”¹å€Ÿæ¥çš„ä¸œè¥¿ï¼‰ã€‚

#### 4.2.3 å¯å˜å¼•ç”¨

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªå°è°ƒæ•´å°±èƒ½å…è®¸æˆ‘ä»¬ä¿®æ”¹ä¸€ä¸ªå€Ÿç”¨çš„å€¼ï¼Œè¿™å°±æ˜¯ **å¯å˜å¼•ç”¨**

+ é¦–å…ˆï¼Œæˆ‘ä»¬å¿…é¡»å°† `s` æ”¹ä¸º `mut`ã€‚ç„¶ååœ¨è°ƒç”¨ `change` å‡½æ•°çš„åœ°æ–¹åˆ›å»ºä¸€ä¸ªå¯å˜å¼•ç”¨ `&mut s`ï¼Œå¹¶æ›´æ–°å‡½æ•°ç­¾åä»¥æ¥å—ä¸€ä¸ªå¯å˜å¼•ç”¨ `some_string: &mut String`ã€‚è¿™å°±éå¸¸æ¸…æ¥šåœ°è¡¨æ˜ï¼Œ`change` å‡½æ•°å°†æ”¹å˜å®ƒæ‰€å€Ÿç”¨çš„å€¼ã€‚

+ å¯å˜å¼•ç”¨æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶ï¼šå¦‚æœä½ æœ‰ä¸€ä¸ªå¯¹è¯¥å˜é‡çš„å¯å˜å¼•ç”¨ï¼Œä½ å°±ä¸èƒ½å†åˆ›å»ºå¯¹è¯¥å˜é‡çš„å¼•ç”¨ã€‚è¿™äº›å°è¯•åˆ›å»ºä¸¤ä¸ª `s` çš„å¯å˜å¼•ç”¨çš„ä»£ç ä¼šå¤±è´¥

  ```rust
  fn main() {
      let mut s = String::from("hello");
  
      let r1 = &mut s;
      let r2 = &mut s;
  
      println!("{}, {}", r1, r2);
  }
  ```

  ```rust
  $ cargo run
     Compiling ownership v0.1.0 (file:///projects/ownership)
  error[E0499]: cannot borrow `s` as mutable more than once at a time
   --> src/main.rs:5:14
    |
  4 |     let r1 = &mut s;
    |              ------ first mutable borrow occurs here
  5 |     let r2 = &mut s;
    |              ^^^^^^ second mutable borrow occurs here
  6 | 
  7 |     println!("{}, {}", r1, r2);
    |                        -- first borrow later used here
  
  For more information about this error, try `rustc --explain E0499`.
  error: could not compile `ownership` due to previous error
  ```

  è¿™ä¸€é™åˆ¶ä»¥ä¸€ç§éå¸¸å°å¿ƒè°¨æ…çš„æ–¹å¼å…è®¸å¯å˜æ€§ï¼Œé˜²æ­¢åŒä¸€æ—¶é—´å¯¹åŒä¸€æ•°æ®å­˜åœ¨å¤šä¸ªå¯å˜å¼•ç”¨ã€‚æ–° Rustacean ä»¬ç»å¸¸éš¾ä»¥é€‚åº”è¿™ä¸€ç‚¹ï¼Œå› ä¸ºå¤§éƒ¨åˆ†è¯­è¨€ä¸­å˜é‡ä»»ä½•æ—¶å€™éƒ½æ˜¯å¯å˜çš„ã€‚è¿™ä¸ªé™åˆ¶çš„å¥½å¤„æ˜¯ Rust å¯ä»¥åœ¨ç¼–è¯‘æ—¶å°±é¿å…æ•°æ®ç«äº‰ã€‚**æ•°æ®ç«äº‰**ï¼ˆ*data race*ï¼‰ç±»ä¼¼äºç«æ€æ¡ä»¶ï¼Œå®ƒå¯ç”±è¿™ä¸‰ä¸ªè¡Œä¸ºé€ æˆï¼š

  + ä¸¤ä¸ªæˆ–æ›´å¤šæŒ‡é’ˆåŒæ—¶è®¿é—®åŒä¸€æ•°æ®ã€‚
  + è‡³å°‘æœ‰ä¸€ä¸ªæŒ‡é’ˆè¢«ç”¨æ¥å†™å…¥æ•°æ®ã€‚
  + æ²¡æœ‰åŒæ­¥æ•°æ®è®¿é—®çš„æœºåˆ¶ã€‚

+ æ•°æ®ç«äº‰ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼Œéš¾ä»¥åœ¨è¿è¡Œæ—¶è¿½è¸ªï¼Œå¹¶ä¸”éš¾ä»¥è¯Šæ–­å’Œä¿®å¤ï¼›Rust é¿å…äº†è¿™ç§æƒ…å†µçš„å‘ç”Ÿï¼Œå› ä¸ºå®ƒç”šè‡³ä¸ä¼šç¼–è¯‘å­˜åœ¨æ•°æ®ç«äº‰çš„ä»£ç ï¼

+ å¯ä»¥ä½¿ç”¨å¤§æ‹¬å·æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸï¼Œä»¥å…è®¸æ‹¥æœ‰å¤šä¸ªå¯å˜å¼•ç”¨ï¼Œåªæ˜¯ä¸èƒ½ **åŒæ—¶** æ‹¥æœ‰

  ```rust
  fn main() {
      let mut s = String::from("hello");
  
      {
          let r1 = &mut s;
      } // r1 åœ¨è¿™é‡Œç¦»å¼€äº†ä½œç”¨åŸŸï¼Œæ‰€ä»¥æˆ‘ä»¬å®Œå…¨å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„å¼•ç”¨
  
      let r2 = &mut s;
  }
  ```

+ **ä¸å¯ä»¥åŒæ—¶æ‹¥æœ‰**ä¸€ä¸ªå¯å˜å¼•ç”¨å’Œä¸€ä¸ªä¸å¯å˜çš„å¼•ç”¨

  ```rust
  fn main() {
      let mut s = String::from("hello");
  
      let r1 = &s; // æ²¡é—®é¢˜
      let r2 = &s; // æ²¡é—®é¢˜
      let r3 = &mut s; // å¤§é—®é¢˜
  
      println!("{}, {}, and {}", r1, r2, r3);
  }
  ```

  ```rust
  $ cargo run
     Compiling ownership v0.1.0 (file:///projects/ownership)
  error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
   --> src/main.rs:6:14
    |
  4 |     let r1 = &s; // no problem
    |              -- immutable borrow occurs here
  5 |     let r2 = &s; // no problem
  6 |     let r3 = &mut s; // BIG PROBLEM
    |              ^^^^^^ mutable borrow occurs here
  7 | 
  8 |     println!("{}, {}, and {}", r1, r2, r3);
    |                                -- immutable borrow later used here
  
  For more information about this error, try `rustc --explain E0502`.
  error: could not compile `ownership` due to previous error
  ```

#### 4.2.4 æ‚¬ç©ºå¼•ç”¨ï¼ˆDangling Referencesï¼‰

+ ä¸€ä¸ªæŒ‡é’ˆå¼•ç”¨äº†å†…å­˜ä¸­çš„æŸä¸ªåœ°å€ï¼Œè€Œè¿™å—å†…å­˜å¯èƒ½å·²ç»é‡Šæ”¾å¹¶åˆ†é…ç»™å…¶å®ƒæŒæœ‰è€…äº†

+ åœ¨ Rust ä¸­ç¼–è¯‘å™¨ç¡®ä¿å¼•ç”¨æ°¸è¿œä¹Ÿä¸ä¼šå˜æˆæ‚¬å‚çŠ¶æ€

  + å½“ä½ å¼•ç”¨äº†æŸäº›æ•°æ®ï¼Œç¼–è¯‘å™¨ç¡®ä¿æ•°æ®ä¸ä¼šåœ¨å…¶å¼•ç”¨ä¹‹å‰ç¦»å¼€ä½œç”¨åŸŸ

    ```rust
    fn main() {
        let reference_to_nothing = dangle();
    }
    
    fn dangle() -> &String {
        let s = String::from("hello");
    
        &s
    }
    ```

    ```rust
    $ cargo run
       Compiling ownership v0.1.0 (file:///projects/ownership)
    error[E0106]: missing lifetime specifier
     --> src/main.rs:5:16
      |
    5 | fn dangle() -> &String {
      |                ^ expected named lifetime parameter
      |
      = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
    help: consider using the `'static` lifetime
      |
    5 | fn dangle() -> &'static String {
      |                ~~~~~~~~
    
    For more information about this error, try `rustc --explain E0106`.
    error: could not compile `ownership` due to previous error
    ```

    æˆ‘ä»¬å°è¯•åˆ›å»ºä¸€ä¸ªæ‚¬å‚å¼•ç”¨ï¼ŒRust ä¼šé€šè¿‡ä¸€ä¸ªç¼–è¯‘æ—¶é”™è¯¯æ¥é¿å…

    ```rust
    fn main() {
        let reference_to_nothing = dangle();
    }
    
    fn dangle() -> &String { // dangle è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²çš„å¼•ç”¨
    
        let s = String::from("hello"); // s æ˜¯ä¸€ä¸ªæ–°å­—ç¬¦ä¸²
    
        &s // è¿”å›å­—ç¬¦ä¸² s çš„å¼•ç”¨
    } // è¿™é‡Œ s ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚å…¶å†…å­˜è¢«é‡Šæ”¾ã€‚
      // å±é™©ï¼
    ```

#### 4.2.5 å¼•ç”¨çš„è§„åˆ™

- åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œ**è¦ä¹ˆ** åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œ**è¦ä¹ˆ** åªèƒ½æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨ã€‚
- å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„ã€‚



### 4.3 Sliceç±»å‹ï¼ˆåˆ‡ç‰‡ï¼‰

> *slice* å…è®¸ä½ å¼•ç”¨é›†åˆä¸­ä¸€æ®µè¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸ç”¨å¼•ç”¨æ•´ä¸ªé›†åˆã€‚slice æ˜¯ä¸€ç±»å¼•ç”¨ï¼Œæ‰€ä»¥å®ƒä¸æŒæœ‰æ‰€æœ‰æƒ

+ ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥æ”¶ä¸€ä¸ªç”¨ç©ºæ ¼åˆ†éš”å•è¯çš„å­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›åœ¨è¯¥å­—ç¬¦ä¸²ä¸­æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªå•è¯ã€‚å¦‚æœå‡½æ•°åœ¨è¯¥å­—ç¬¦ä¸²ä¸­å¹¶æœªæ‰¾åˆ°ç©ºæ ¼ï¼Œåˆ™æ•´ä¸ªå­—ç¬¦ä¸²å°±æ˜¯ä¸€ä¸ªå•è¯ï¼Œæ‰€ä»¥åº”è¯¥è¿”å›æ•´ä¸ªå­—ç¬¦ä¸²

+ æˆ‘ä»¬å¹¶æ²¡æœ‰ä¸€ä¸ªçœŸæ­£è·å– **éƒ¨åˆ†** å­—ç¬¦ä¸²çš„åŠæ³•ã€‚ä¸è¿‡ï¼Œæˆ‘ä»¬å¯ä»¥è¿”å›å•è¯ç»“å°¾çš„ç´¢å¼•ï¼Œç»“å°¾ç”±ä¸€ä¸ªç©ºæ ¼è¡¨ç¤º

  ```rust
  fn main() {
      let mut s = String::from("hello world");
      let word_index = first_world(&s);
      s.clear(); // è¿™æ¸…ç©ºäº†å­—ç¬¦ä¸²ï¼Œä½¿å…¶ç­‰äº ""
      // word_index åœ¨æ­¤å¤„çš„å€¼ä»ç„¶æ˜¯ 5ï¼Œ
      // ä½†æ˜¯æ²¡æœ‰æ›´å¤šçš„å­—ç¬¦ä¸²è®©æˆ‘ä»¬å¯ä»¥æœ‰æ•ˆåœ°åº”ç”¨æ•°å€¼ 5ã€‚word_index çš„å€¼ç°åœ¨å®Œå…¨æ²¡æœ‰æ„ä¹‰
      println!("{}", word_index)
  }
  
  fn first_world(s: &String) -> usize {
      let bytes = s.as_bytes();
  
      for (i, &item) in bytes.iter().enumerate() {
          if item == b' ' {
              return i;
          }
      }
      s.len()
  }
  ```

   `iter` æ–¹æ³•è¿”å›é›†åˆä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œè€Œ `enumerate` åŒ…è£…äº† `iter` çš„ç»“æœï¼Œå°†è¿™äº›å…ƒç´ ä½œä¸ºå…ƒç»„çš„ä¸€éƒ¨åˆ†æ¥è¿”å›ã€‚`enumerate` è¿”å›çš„å…ƒç»„ä¸­ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ç´¢å¼•ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯é›†åˆä¸­å…ƒç´ çš„å¼•ç”¨ã€‚

   `enumerate` æ–¹æ³•è¿”å›ä¸€ä¸ªå…ƒç»„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¨¡å¼æ¥è§£æ„ã€‚åœ¨ `for` å¾ªç¯ä¸­ï¼Œæˆ‘ä»¬æŒ‡å®šäº†ä¸€ä¸ªæ¨¡å¼ï¼Œå…¶ä¸­å…ƒç»„ä¸­çš„ `i` æ˜¯ç´¢å¼•è€Œå…ƒç»„ä¸­çš„ `&item` æ˜¯å•ä¸ªå­—èŠ‚ã€‚å› ä¸ºæˆ‘ä»¬ä» `.iter().enumerate()` ä¸­è·å–äº†é›†åˆå…ƒç´ çš„å¼•ç”¨ï¼Œæ‰€ä»¥æ¨¡å¼ä¸­ä½¿ç”¨äº† `&`ã€‚

  åœ¨ `for` å¾ªç¯ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡å­—èŠ‚çš„å­—é¢å€¼è¯­æ³•æ¥å¯»æ‰¾ä»£è¡¨ç©ºæ ¼çš„å­—èŠ‚ã€‚å¦‚æœæ‰¾åˆ°äº†ä¸€ä¸ªç©ºæ ¼ï¼Œè¿”å›å®ƒçš„ä½ç½®ã€‚å¦åˆ™ï¼Œä½¿ç”¨ `s.len()` è¿”å›å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚

  æˆ‘ä»¬è¿”å›äº†ä¸€ä¸ªç‹¬ç«‹çš„ `usize`ï¼Œä¸è¿‡å®ƒåªåœ¨ `&String` çš„ä¸Šä¸‹æ–‡ä¸­æ‰æ˜¯ä¸€ä¸ªæœ‰æ„ä¹‰çš„æ•°å­—ã€‚æ¢å¥è¯è¯´ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªä¸ `String` ç›¸åˆ†ç¦»çš„å€¼ï¼Œæ— æ³•ä¿è¯å°†æ¥å®ƒä»ç„¶æœ‰æ•ˆã€‚

  è¿™ä¸ªç¨‹åºç¼–è¯‘æ—¶æ²¡æœ‰ä»»ä½•é”™è¯¯ï¼Œè€Œä¸”åœ¨è°ƒç”¨ `s.clear()` ä¹‹åä½¿ç”¨ `word` ä¹Ÿä¸ä¼šå‡ºé”™ã€‚å› ä¸º `word` ä¸ `s` çŠ¶æ€å®Œå…¨æ²¡æœ‰è”ç³»ï¼Œæ‰€ä»¥ `word `ä»ç„¶åŒ…å«å€¼ `5`ã€‚å¯ä»¥å°è¯•ç”¨å€¼ `5` æ¥æå–å˜é‡ `s` çš„ç¬¬ä¸€ä¸ªå•è¯ï¼Œä¸è¿‡è¿™æ˜¯æœ‰ bug çš„ï¼Œå› ä¸ºåœ¨æˆ‘ä»¬å°† `5` ä¿å­˜åˆ° `word` ä¹‹å `s` çš„å†…å®¹å·²ç»æ”¹å˜ã€‚æˆ‘ä»¬ä¸å¾—ä¸æ—¶åˆ»æ‹…å¿ƒ `word` çš„ç´¢å¼•ä¸ `s` ä¸­çš„æ•°æ®ä¸å†åŒæ­¥ï¼Œè¿™å¾ˆå•°å—¦ä¸”æ˜“å‡ºé”™ã€‚

#### 4.3.1 å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼ˆsliceï¼‰

+ **å­—ç¬¦ä¸² slice**ï¼ˆ*string slice*ï¼‰æ˜¯ `String` ä¸­ä¸€éƒ¨åˆ†å€¼çš„å¼•ç”¨ï¼Œå®ƒçœ‹èµ·æ¥åƒè¿™æ ·

  ```rust
  fn main() {
      let s = String::from("hello world");
  
      let hello = &s[0..5];
      let world = &s[6..11];
  }
  ```

+ å½¢å¼ï¼š[starting_index..ending_index]

  + starting_indexå°±æ˜¯åˆ‡ç‰‡èµ·å§‹ä½ç½®çš„ç´¢å¼•å€¼
  + ending_indexæ˜¯åˆ‡ç‰‡ç»ˆæ­¢ä½ç½®çš„ä¸‹ä¸€ä¸ªç´¢å¼•å€¼

  ![slice](assets/slice.svg)

  + å­—ç¬¦ä¸² slice range çš„ç´¢å¼•å¿…é¡»ä½äºæœ‰æ•ˆçš„ UTF-8 å­—ç¬¦è¾¹ç•Œå†…
  + å¦‚æœå°è¯•ä»ä¸€ä¸ªå¤šå­—èŠ‚å­—ç¬¦çš„ä¸­é—´ä½ç½®åˆ›å»ºå­—ç¬¦ä¸² sliceï¼Œåˆ™ç¨‹åºå°†ä¼šå› é”™è¯¯è€Œé€€å‡º

+ ä½¿ç”¨å­—ç¬¦ä¸²åˆ‡ç‰‡é‡å†™ä¾‹å­

  ```rust
  fn main() { 
  
      let mut s = String::from("hello world");
      let word_index = first_word(&s);
  
      s.clear(); // é”™è¯¯
      println!("{}", word_index);
  }
  
  fn first_word(s: &String) -> &str {
  
      let bytes = s.as_bytes();
  
      for(i, &item) in bytes.iter().enumerate() {
          if item == b' '{
              return &s[..i];
          }
      }
      &s[..]
  }
  ```

  ```rust
  $ cargo run
     Compiling ownership v0.1.0 (file:///projects/ownership)
  error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
    --> src/main.rs:18:5
     |
  16 |     let word = first_word(&s);
     |                           -- immutable borrow occurs here
  17 | 
  18 |     s.clear(); // error!
     |     ^^^^^^^^^ mutable borrow occurs here
  19 | 
  20 |     println!("the first word is: {}", word);
     |                                       ---- immutable borrow later used here
  
  For more information about this error, try `rustc --explain E0502`.
  error: could not compile `ownership` due to previous error
  ```

  å›å¿†ä¸€ä¸‹å€Ÿç”¨è§„åˆ™ï¼Œå½“æ‹¥æœ‰æŸå€¼çš„ä¸å¯å˜å¼•ç”¨æ—¶ï¼Œå°±ä¸èƒ½å†è·å–ä¸€ä¸ªå¯å˜å¼•ç”¨ã€‚å› ä¸º `clear` éœ€è¦æ¸…ç©º `String`ï¼Œå®ƒå°è¯•è·å–ä¸€ä¸ªå¯å˜å¼•ç”¨ã€‚åœ¨è°ƒç”¨ `clear` ä¹‹åçš„ `println!` ä½¿ç”¨äº† `word` ä¸­çš„å¼•ç”¨ï¼Œæ‰€ä»¥è¿™ä¸ªä¸å¯å˜çš„å¼•ç”¨åœ¨æ­¤æ—¶å¿…é¡»ä»ç„¶æœ‰æ•ˆã€‚Rust ä¸å…è®¸ `clear` ä¸­çš„å¯å˜å¼•ç”¨å’Œ `word` ä¸­çš„ä¸å¯å˜å¼•ç”¨åŒæ—¶å­˜åœ¨ï¼Œå› æ­¤ç¼–è¯‘å¤±è´¥ã€‚Rust ä¸ä»…ä½¿å¾—æˆ‘ä»¬çš„ API ç®€å•æ˜“ç”¨ï¼Œä¹Ÿåœ¨ç¼–è¯‘æ—¶å°±æ¶ˆé™¤äº†ä¸€æ•´ç±»çš„é”™è¯¯ï¼

#### 4.3.2 å­—ç¬¦ä¸²å­—é¢å€¼å°±æ˜¯ slice

+ å­—ç¬¦ä¸²å­—é¢å€¼è¢«ç›´æ¥å­˜å‚¨åœ¨äºŒè¿›åˆ¶ç¨‹åºä¸­
  + `let word = "hello world";`
    + å˜é‡ s çš„ç±»å‹æ˜¯ `&str`ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŒ‡å‘äºŒè¿›åˆ¶ç¨‹åºç‰¹å®šä½ç½®çš„åˆ‡ç‰‡
    + `&str`æ˜¯ä¸å¯å˜å¼•ç”¨ï¼Œæ‰€ä»¥å­—ç¬¦ä¸²å­—é¢å€¼ä¹Ÿæ˜¯ä¸å¯å˜çš„



#### 4.3.3 å°†å­—ç¬¦ä¸² sliceä½œä¸ºå‚æ•°ä¼ é€’

+ `fn first_word(s: &String) -> &str {`

+ è€Œæ›´æœ‰ç»éªŒçš„ Rustacean ä¼šé‡‡ç”¨`&str`ä½œä¸ºå‚æ•°ç±»å‹ï¼Œå› ä¸ºè¿™æ ·å°±å¯ä»¥åŒæ—¶æ¥æ”¶`String`å’Œ`&str`ç±»å‹çš„å‚æ•°äº†

  + `fn first_word(s: &str) -> &str {`
    + ä½¿ç”¨å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œç›´æ¥è°ƒç”¨è¯¥å‡½æ•°
    + ä½¿ç”¨`String`ï¼Œå¯ä»¥åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„`String`åˆ‡ç‰‡æ¥è°ƒç”¨è¯¥å‡½æ•°

+ å®šä¹‰å‡½æ•°æ—¶ä½¿ç”¨å­—ç¬¦ä¸²åˆ‡ç‰‡æ¥ä»£æ›¿å­—ç¬¦ä¸²å¼•ç”¨ä¼šä½¿æˆ‘ä»¬çš„APIæ›´åŠ é€šç”¨ï¼Œä¸”ä¸ä¼šæŸå¤±ä»»ä½•åŠŸèƒ½

  ```rust
  fn main() {
      let my_string = String::from("hello world");
  
      // `first_word` é€‚ç”¨äº `String`ï¼ˆçš„ sliceï¼‰ï¼Œæ•´ä½“æˆ–å…¨éƒ¨
      let word = first_word(&my_string[0..6]);
      let word = first_word(&my_string[..]);
      // `first_word` ä¹Ÿé€‚ç”¨äº `String` çš„å¼•ç”¨ï¼Œ
      // è¿™ç­‰ä»·äºæ•´ä¸ª `String` çš„ slice
      let word = first_word(&my_string);
  
      let my_string_literal = "hello world";
  
      // `first_word` é€‚ç”¨äºå­—ç¬¦ä¸²å­—é¢å€¼ï¼Œæ•´ä½“æˆ–å…¨éƒ¨
      let word = first_word(&my_string_literal[0..6]);
      let word = first_word(&my_string_literal[..]);
  
      // å› ä¸ºå­—ç¬¦ä¸²å­—é¢å€¼å·²ç» **æ˜¯** å­—ç¬¦ä¸² slice äº†ï¼Œ
      // è¿™ä¹Ÿæ˜¯é€‚ç”¨çš„ï¼Œæ— éœ€ slice è¯­æ³•ï¼
      let word = first_word(my_string_literal);
  }
  ```

  

#### 4.3.4 å…¶å®ƒç±»å‹çš„ slice

+ å°±è·Ÿæˆ‘ä»¬æƒ³è¦è·å–å­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†é‚£æ ·ï¼Œæˆ‘ä»¬ä¹Ÿä¼šæƒ³è¦å¼•ç”¨æ•°ç»„çš„ä¸€éƒ¨åˆ†

  ```rust
  #![allow(unused)]
  fn main() {
  let a = [1, 2, 3, 4, 5];
  
  let slice = &a[1..3];
  
  assert_eq!(slice, &[2, 3]);
  }
  ```

  è¿™ä¸ª slice çš„ç±»å‹æ˜¯ `&[i32]`ã€‚å®ƒè·Ÿå­—ç¬¦ä¸² slice çš„å·¥ä½œæ–¹å¼ä¸€æ ·ï¼Œé€šè¿‡å­˜å‚¨é›†åˆä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨å’Œä¸€ä¸ªé›†åˆæ€»é•¿åº¦ã€‚ä½ å¯ä»¥å¯¹å…¶ä»–æ‰€æœ‰é›†åˆä½¿ç”¨è¿™ç±» slice



## 5ã€ä½¿ç”¨ç»“æ„ä½“ç»„ç»‡ç›¸å…³è”çš„æ•°æ®

> *struct*ï¼Œæˆ–è€… *structure*ï¼Œæ˜¯ä¸€ä¸ªè‡ªå®šä¹‰æ•°æ®ç±»å‹ï¼Œå…è®¸ä½ åŒ…è£…å’Œå‘½åå¤šä¸ªç›¸å…³çš„å€¼ï¼Œä»è€Œå½¢æˆä¸€ä¸ªæœ‰æ„ä¹‰çš„ç»„åˆã€‚å¦‚æœä½ ç†Ÿæ‚‰ä¸€é—¨é¢å‘å¯¹è±¡è¯­è¨€ï¼Œ*struct* å°±åƒå¯¹è±¡ä¸­çš„æ•°æ®å±æ€§ã€‚

### 5.1 ç»“æ„ä½“çš„å®šä¹‰å’Œå®ä¾‹åŒ–

#### 5.1.1 åˆ›å»ºstruct

+ ä½¿ç”¨`struct`å…³é”®å­—ï¼Œå¹¶ä¸ºæ•´ä¸ª`struct`å‘½å

+ åœ¨èŠ±æ‹¬å·å†…ï¼Œä¸ºæ‰€æœ‰å­—æ®µï¼ˆFieldï¼‰å®šä¹‰åç§°å’Œç±»å‹

  ```rust
  struct User {
      username: String,
      email: String,
      sign_in_count: u64,
      active: bool,
  }
  ```

#### 5.1.2 å®ä¾‹åŒ–struct

+ æƒ³è¦ä½¿ç”¨`struct`ï¼Œéœ€è¦åˆ›å»º`struct`çš„å®ä¾‹

  + ä¸ºæ¯ä¸ªå­—æ®µæŒ‡å®šå…·ä½“å€¼
  + æ— éœ€æŒ‰å£°æ˜çš„é¡ºåºè¿›è¡ŒæŒ‡å®š

  ```rust
  fn main() {
      let user1 = User {
          email: String::from("someone@example.com"),
          username: String::from("someusername123"),
          active: true,
          sign_in_count: 1,
      };
  }
  ```

#### 5.1.3 å–å¾—structé‡Œé¢çš„æŸä¸ªå€¼

+ ä½¿ç”¨ç‚¹æ ‡è®°æ³•

  ```rust
  struct User {
      active: bool,
      username: String,
      email: String,
      sign_in_count: u64,
  }
  
  fn main() {
      let mut user1 = User {
          email: String::from("someone@example.com"),
          username: String::from("someusername123"),
          active: true,
          sign_in_count: 1,
      };
  
      user1.email = String::from("anotheremail@example.com");
  }
  ```

+ ä¸€æ—¦`struct`çš„å®ä¾‹æ˜¯å¯å˜çš„ï¼Œé‚£ä¹ˆå®ä¾‹ä¸­æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯å˜çš„ï¼ŒRust å¹¶ä¸å…è®¸åªå°†æŸä¸ªå­—æ®µæ ‡è®°ä¸ºå¯å˜

+ å¦å¤–éœ€è¦æ³¨æ„åŒå…¶ä»–ä»»ä½•è¡¨è¾¾å¼ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å‡½æ•°ä½“çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ä¸­æ„é€ ä¸€ä¸ªç»“æ„ä½“çš„æ–°å®ä¾‹ï¼Œæ¥éšå¼åœ°è¿”å›è¿™ä¸ªå®ä¾‹

  ```rust
  struct User {
      active: bool,
      username: String,
      email: String,
      sign_in_count: u64,
  }
  
  fn build_user(email: String, username: String) -> User {
      User {
          email: email,
          username: username,
          active: true,
          sign_in_count: 1,
      }
  }
  
  fn main() {
      let user1 = build_user(
          String::from("someone@example.com"),
          String::from("someusername123"),
      );
  }
  ```

+ ä¸ºå‡½æ•°å‚æ•°èµ·ä¸ç»“æ„ä½“å­—æ®µç›¸åŒçš„åå­—æ˜¯å¯ä»¥ç†è§£çš„ï¼Œä½†æ˜¯ä¸å¾—ä¸é‡å¤ `email` å’Œ `username` å­—æ®µåç§°ä¸å˜é‡æœ‰äº›å•°å—¦ã€‚å¦‚æœç»“æ„ä½“æœ‰æ›´å¤šå­—æ®µï¼Œé‡å¤æ¯ä¸ªåç§°å°±æ›´åŠ çƒ¦äººäº†ã€‚å¹¸è¿çš„æ˜¯ï¼Œæœ‰ä¸€ä¸ªæ–¹ä¾¿çš„ç®€å†™è¯­æ³•ï¼

#### 5.1.4 å­—æ®µåˆå§‹åŒ–ç®€å†™è¯­æ³•

+ å½“å‚æ•°åä¸å­—æ®µåéƒ½å®Œå…¨ç›¸åŒï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ **å­—æ®µåˆå§‹åŒ–ç®€å†™è¯­æ³•**ï¼ˆ*field init shorthand*ï¼‰æ¥é‡å†™

  ```rust
  struct User {
      active: bool,
      username: String,
      email: String,
      sign_in_count: u64,
  }
  
  fn build_user(email: String, username: String) -> User {
      User {
          email,
          username,
          active: true,
          sign_in_count: 1,
      }
  }
  
  fn main() {
      let user1 = build_user(
          String::from("someone@example.com"),
          String::from("someusername123"),
      );
  }
  ```

#### 5.1.5 structæ›´æ–°è¯­æ³•

+ å½“ä½ æƒ³åŸºäºæŸä¸ª`struct`å®ä¾‹æ¥åˆ›å»ºä¸€ä¸ªæ–°å®ä¾‹çš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨ **ç»“æ„ä½“æ›´æ–°è¯­æ³•**ï¼ˆ*struct update syntax*ï¼‰å®ç°

  ```rust
  struct User {
      active: bool,
      username: String,
      email: String,
      sign_in_count: u64,
  }
  
  fn main() {
      // --snip--
  
      let user1 = User {
          email: String::from("someone@example.com"),
          username: String::from("someusername123"),
          active: true,
          sign_in_count: 1,
      };
  	
      // ä¸ä½¿ç”¨æ›´æ–°è¯­æ³•
      let user2 = User {
          active: user1.active,
          username: user1.username,
          email: String::from("another@example.com"),
          sign_in_count: user1.sign_in_count,
      };
      
      //ä½¿ç”¨æ›´æ–°è¯­æ³•
      let user2 = User {
          email: String::from("another@example.com"),
          ..user1
      };
  }
  ```

#### 5.1.6 Tuple structs

+ å¯å®šä¹‰ç±»ä¼¼`tuple`çš„`struct`ï¼Œå«åšå…ƒç»„ç»“æ„ä½“ï¼ˆ*tuple structs*ï¼‰

  + `Tuple structs`æœ‰ç€ç»“æ„ä½“åç§°æä¾›çš„å«ä¹‰ï¼Œä½†æ²¡æœ‰å…·ä½“çš„å­—æ®µåï¼Œåªæœ‰å­—æ®µçš„ç±»å‹
  + å½“ä½ æƒ³ç»™æ•´ä¸ªå…ƒç»„å–ä¸€ä¸ªåå­—ï¼Œå¹¶ä½¿å…ƒç»„æˆä¸ºä¸å…¶ä»–å…ƒç»„ä¸åŒçš„ç±»å‹æ—¶ï¼Œå…ƒç»„ç»“æ„ä½“æ˜¯å¾ˆæœ‰ç”¨çš„ï¼Œè¿™æ—¶åƒå¸¸è§„ç»“æ„ä½“é‚£æ ·ä¸ºæ¯ä¸ªå­—æ®µå‘½åå°±æ˜¾å¾—å¤šä½™å’Œå½¢å¼åŒ–äº†

+ å®šä¹‰ `Tuple structs`ï¼šä½¿ç”¨`struct`å…³é”®å­—ï¼Œåè¾¹æ˜¯åå­—ï¼Œä»¥åŠé‡Œé¢å…ƒç´ çš„ç±»å‹

  ```rust
  struct Color(i32, i32, i32);
  struct Point(i32, i32, i32);
  
  fn main() {
      let black = Color(0, 0, 0);
      let origin = Point(0, 0, 0);
  }
  ```

+ `black` å’Œ `origin` å€¼çš„ç±»å‹ä¸åŒï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸åŒçš„å…ƒç»„ç»“æ„ä½“çš„å®ä¾‹

+ å…ƒç»„ç»“æ„ä½“å®ä¾‹ç±»ä¼¼äºå…ƒç»„ï¼Œä½ å¯ä»¥å°†å®ƒä»¬è§£æ„ä¸ºå•ç‹¬çš„éƒ¨åˆ†ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ `.` åè·Ÿç´¢å¼•æ¥è®¿é—®å•ç‹¬çš„å€¼

#### 5.1.7 æ²¡æœ‰ä»»ä½•å­—æ®µçš„ç±»å•å…ƒç»“æ„ä½“ï¼ˆ*unit-like structs*ï¼‰

+ å®šä¹‰ä¸€ä¸ªæ²¡æœ‰ä»»ä½•å­—æ®µçš„ç»“æ„ä½“ï¼å®ƒä»¬è¢«ç§°ä¸º **ç±»å•å…ƒç»“æ„ä½“**ï¼ˆ*unit-like structs*ï¼‰,å› ä¸ºå®ƒä»¬ç±»ä¼¼äº `()`ï¼Œå³â€œå…ƒç»„ç±»å‹â€ä¸­æåˆ°çš„ unit ç±»å‹

+ ç±»å•å…ƒç»“æ„ä½“å¸¸å¸¸åœ¨ä½ æƒ³è¦åœ¨æŸä¸ªç±»å‹ä¸Šå®ç° trait ä½†ä¸éœ€è¦åœ¨ç±»å‹ä¸­å­˜å‚¨æ•°æ®çš„æ—¶å€™å‘æŒ¥ä½œç”¨

  ```rust
  struct AlwaysEqual;
  
  fn main() {
      let subject = AlwaysEqual;
  }
  ```

#### 5.1.8 structæ•°æ®çš„æ‰€æœ‰æƒ

```rust
struct User {
    active: bool,
    username: &str,
    email: &str,
    sign_in_count: u64,
}
```

+ è¿™é‡Œçš„å­—æ®µä½¿ç”¨äº†`String`è€Œä¸æ˜¯`&str`
  + è¯¥`struct`å®ä¾‹æ‹¥æœ‰å…¶æ‰€æœ‰çš„æ•°æ®
  + åªè¦`struct`å®ä¾‹æ˜¯æœ‰æ•ˆçš„ï¼Œé‚£ä¹ˆé‡Œé¢çš„å­—æ®µæ•°æ®ä¹Ÿæ˜¯æœ‰æ•ˆçš„
  
+ `struct`é‡Œä¹Ÿå¯ä»¥å­˜æ”¾å¼•ç”¨ï¼Œä½†è¿™éœ€è¦ä½¿ç”¨å£°æ˜å‘¨æœŸï¼ˆlifetimesï¼‰
  + ç”Ÿå‘½å‘¨æœŸä¿è¯åªè¦`struct`å®ä¾‹æ˜¯æœ‰æ•ˆçš„ï¼Œé‚£ä¹ˆé‡Œé¢çš„å¼•ç”¨ä¹Ÿæ˜¯æœ‰æ•ˆçš„
  + å¦‚æœ`struct`é‡Œé¢å­˜å‚¨å¼•ç”¨ï¼Œè€Œä¸ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå°±ä¼šæŠ¥é”™
  
  ```rust
  struct User {
      active: bool,
      username: &str,
      email: &str,
      sign_in_count: u64,
  }
  
  fn main() {
      let user1 = User {
          email: "someone@example.com",
          username: "someusername123",
          active: true,
          sign_in_count: 1,
      };
  }
  
  ```
  
  ```rust
  $ cargo run
     Compiling structs v0.1.0 (file:///projects/structs)
  error[E0106]: missing lifetime specifier
   --> src/main.rs:3:15
    |
  3 |     username: &str,
    |               ^ expected named lifetime parameter
    |
  help: consider introducing a named lifetime parameter
    |
  1 ~ struct User<'a> {
  2 |     active: bool,
  3 ~     username: &'a str,
    |
  
  error[E0106]: missing lifetime specifier
   --> src/main.rs:4:12
    |
  4 |     email: &str,
    |            ^ expected named lifetime parameter
    |
  help: consider introducing a named lifetime parameter
    |
  1 ~ struct User<'a> {
  2 |     active: bool,
  3 |     username: &str,
  4 ~     email: &'a str,
    |
  
  For more information about this error, try `rustc --explain E0106`.
  error: could not compile `structs` due to 2 previous errors
  ```



### 5.2 ç»“æ„ä½“ç¤ºä¾‹ç¨‹åº

ä½¿ç”¨ Cargo æ–°å»ºä¸€ä¸ªå«åš *rectangles* çš„äºŒè¿›åˆ¶ç¨‹åºï¼Œå®ƒè·å–ä»¥åƒç´ ä¸ºå•ä½çš„é•¿æ–¹å½¢çš„å®½åº¦å’Œé«˜åº¦ï¼Œå¹¶è®¡ç®—å‡ºé•¿æ–¹å½¢çš„é¢ç§¯

```rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}

```

è¿™ä¸ªç¤ºä¾‹ä»£ç åœ¨è°ƒç”¨ `area` å‡½æ•°æ—¶ä¼ å…¥æ¯ä¸ªç»´åº¦ï¼Œè™½ç„¶å¯ä»¥æ­£ç¡®è®¡ç®—å‡ºé•¿æ–¹å½¢çš„é¢ç§¯ï¼Œä½†æˆ‘ä»¬ä»ç„¶å¯ä»¥ä¿®æ”¹è¿™æ®µä»£ç æ¥ä½¿å®ƒçš„æ„ä¹‰æ›´åŠ æ˜ç¡®ï¼Œå¹¶ä¸”å¢åŠ å¯è¯»æ€§

è¿™äº›ä»£ç çš„é—®é¢˜çªæ˜¾åœ¨ `area` çš„ç­¾åä¸Šï¼š

```rust
fn area(width: u32, height: u32) -> u32 {
```

å‡½æ•° `area` æœ¬åº”è¯¥è®¡ç®—ä¸€ä¸ªé•¿æ–¹å½¢çš„é¢ç§¯ï¼Œä¸è¿‡å‡½æ•°å´æœ‰ä¸¤ä¸ªå‚æ•°ã€‚è¿™ä¸¤ä¸ªå‚æ•°æ˜¯ç›¸å…³è”çš„ï¼Œä¸è¿‡ç¨‹åºæœ¬èº«å´æ²¡æœ‰è¡¨ç°å‡ºè¿™ä¸€ç‚¹ã€‚å°†é•¿åº¦å’Œå®½åº¦ç»„åˆåœ¨ä¸€èµ·å°†æ›´æ˜“æ‡‚ä¹Ÿæ›´æ˜“å¤„ç†ã€‚ç¬¬ä¸‰ç« çš„å…ƒç»„ç±»å‹ éƒ¨åˆ†å·²ç»è®¨è®ºè¿‡äº†ä¸€ç§å¯è¡Œçš„æ–¹æ³•ï¼šå…ƒç»„ã€‚

#### 5.2.1 ä½¿ç”¨å…ƒç»„é‡æ„

```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```

åœ¨æŸç§ç¨‹åº¦ä¸Šè¯´ï¼Œè¿™ä¸ªç¨‹åºæ›´å¥½ä¸€ç‚¹äº†ã€‚å…ƒç»„å¸®åŠ©æˆ‘ä»¬å¢åŠ äº†ä¸€äº›ç»“æ„æ€§ï¼Œå¹¶ä¸”ç°åœ¨åªéœ€ä¼ ä¸€ä¸ªå‚æ•°ã€‚ä¸è¿‡åœ¨å¦ä¸€æ–¹é¢ï¼Œè¿™ä¸ªç‰ˆæœ¬å´æœ‰ä¸€ç‚¹ä¸æ˜ç¡®äº†ï¼šå…ƒç»„å¹¶æ²¡æœ‰ç»™å‡ºå…ƒç´ çš„åç§°ï¼Œæ‰€ä»¥è®¡ç®—å˜å¾—æ›´è´¹è§£äº†ï¼Œå› ä¸ºä¸å¾—ä¸ä½¿ç”¨ç´¢å¼•æ¥è·å–å…ƒç»„çš„æ¯ä¸€éƒ¨åˆ†

åœ¨è®¡ç®—é¢ç§¯æ—¶å°†å®½å’Œé«˜å¼„æ··å€’æ— å…³ç´§è¦ï¼Œä¸è¿‡å½“åœ¨å±å¹•ä¸Šç»˜åˆ¶é•¿æ–¹å½¢æ—¶å°±æœ‰é—®é¢˜äº†ï¼æˆ‘ä»¬å¿…é¡»ç‰¢è®° `width` çš„å…ƒç»„ç´¢å¼•æ˜¯ `0`ï¼Œ`height` çš„å…ƒç»„ç´¢å¼•æ˜¯ `1`ã€‚å¦‚æœå…¶ä»–äººè¦ä½¿ç”¨è¿™äº›ä»£ç ï¼Œä»–ä»¬å¿…é¡»è¦ææ¸…æ¥šè¿™ä¸€ç‚¹ï¼Œå¹¶ä¹Ÿè¦ç‰¢è®°äºå¿ƒã€‚å¾ˆå®¹æ˜“å¿˜è®°æˆ–è€…æ··æ·†è¿™äº›å€¼è€Œé€ æˆé”™è¯¯ï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰åœ¨ä»£ç ä¸­ä¼ è¾¾æ•°æ®çš„æ„å›¾

#### 5.2.2 ä½¿ç”¨ç»“æ„ä½“é‡æ„ï¼šèµ‹äºˆæ›´å¤šæ„ä¹‰

æˆ‘ä»¬ä½¿ç”¨ç»“æ„ä½“ä¸ºæ•°æ®å‘½åæ¥ä¸ºå…¶èµ‹äºˆæ„ä¹‰ã€‚æˆ‘ä»¬å¯ä»¥å°†æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨çš„å…ƒç»„è½¬æ¢æˆä¸€ä¸ªæœ‰æ•´ä½“åç§°è€Œä¸”æ¯ä¸ªéƒ¨åˆ†ä¹Ÿæœ‰å¯¹åº”åå­—çš„ç»“æ„ä½“

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```

è¿™é‡Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªç»“æ„ä½“å¹¶ç§°å…¶ä¸º `Rectangle`ã€‚åœ¨å¤§æ‹¬å·ä¸­å®šä¹‰äº†å­—æ®µ `width` å’Œ `height`ï¼Œç±»å‹éƒ½æ˜¯ `u32`ã€‚æ¥ç€åœ¨ `main` ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå…·ä½“çš„ `Rectangle` å®ä¾‹ï¼Œå®ƒçš„å®½æ˜¯ 30ï¼Œé«˜æ˜¯ 50

å‡½æ•° `area` ç°åœ¨è¢«å®šä¹‰ä¸ºæ¥æ”¶ä¸€ä¸ªåå« `rectangle` çš„å‚æ•°ï¼Œå…¶ç±»å‹æ˜¯ä¸€ä¸ªç»“æ„ä½“ `Rectangle` å®ä¾‹çš„ä¸å¯å˜å€Ÿç”¨ã€‚ç¬¬å››ç« è®²åˆ°è¿‡ï¼Œæˆ‘ä»¬å¸Œæœ›å€Ÿç”¨ç»“æ„ä½“è€Œä¸æ˜¯è·å–å®ƒçš„æ‰€æœ‰æƒï¼Œè¿™æ · `main` å‡½æ•°å°±å¯ä»¥ä¿æŒ `rect1` çš„æ‰€æœ‰æƒå¹¶ç»§ç»­ä½¿ç”¨å®ƒï¼Œæ‰€ä»¥è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨å‡½æ•°ç­¾åå’Œè°ƒç”¨çš„åœ°æ–¹ä¼šæœ‰ `&`

`area` å‡½æ•°è®¿é—® `Rectangle` å®ä¾‹çš„ `width` å’Œ `height` å­—æ®µï¼ˆæ³¨æ„ï¼Œè®¿é—®å¯¹ç»“æ„ä½“çš„å¼•ç”¨çš„å­—æ®µä¸ä¼šç§»åŠ¨å­—æ®µçš„æ‰€æœ‰æƒï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆä½ ç»å¸¸çœ‹åˆ°å¯¹ç»“æ„ä½“çš„å¼•ç”¨ï¼‰ã€‚`area` çš„å‡½æ•°ç­¾åç°åœ¨æ˜ç¡®çš„é˜è¿°äº†æˆ‘ä»¬çš„æ„å›¾ï¼šä½¿ç”¨ `Rectangle` çš„ `width` å’Œ `height` å­—æ®µï¼Œè®¡ç®— `Rectangle` çš„é¢ç§¯ã€‚è¿™è¡¨æ˜å®½é«˜æ˜¯ç›¸äº’è”ç³»çš„ï¼Œå¹¶ä¸ºè¿™äº›å€¼æä¾›äº†æè¿°æ€§çš„åç§°è€Œä¸æ˜¯ä½¿ç”¨å…ƒç»„çš„ç´¢å¼•å€¼ `0` å’Œ `1` ã€‚ç»“æ„ä½“èƒœåœ¨æ›´æ¸…æ™°æ˜äº†

#### 5.2.3 é€šè¿‡æ´¾ç”Ÿ trait å¢åŠ å®ç”¨åŠŸèƒ½

åœ¨è°ƒè¯•ç¨‹åºæ—¶æ‰“å°å‡º `Rectangle` å®ä¾‹æ¥æŸ¥çœ‹å…¶æ‰€æœ‰å­—æ®µçš„å€¼éå¸¸æœ‰ç”¨ã€‚ç¤ºä¾‹ 5-11 åƒå‰é¢ç« èŠ‚é‚£æ ·å°è¯•ä½¿ç”¨ `println!` å®ã€‚ä½†è¿™å¹¶ä¸è¡Œ

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}
```

å½“æˆ‘ä»¬è¿è¡Œè¿™ä¸ªä»£ç æ—¶ï¼Œä¼šå‡ºç°å¸¦æœ‰å¦‚ä¸‹æ ¸å¿ƒä¿¡æ¯çš„é”™è¯¯

```rust
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```

`println!` å®èƒ½å¤„ç†å¾ˆå¤šç±»å‹çš„æ ¼å¼ï¼Œä¸è¿‡ï¼Œ`{}` é»˜è®¤å‘Šè¯‰ `println!` ä½¿ç”¨è¢«ç§°ä¸º `Display` çš„æ ¼å¼ï¼šæ„åœ¨æä¾›ç»™ç›´æ¥ç»ˆç«¯ç”¨æˆ·æŸ¥çœ‹çš„è¾“å‡ºã€‚ç›®å‰ä¸ºæ­¢è§è¿‡çš„åŸºæœ¬ç±»å‹éƒ½é»˜è®¤å®ç°äº† `Display`ï¼Œå› ä¸ºå®ƒå°±æ˜¯å‘ç”¨æˆ·å±•ç¤º `1` æˆ–å…¶ä»–ä»»ä½•åŸºæœ¬ç±»å‹çš„å”¯ä¸€æ–¹å¼ã€‚ä¸è¿‡å¯¹äºç»“æ„ä½“ï¼Œ`println!` åº”è¯¥ç”¨æ¥è¾“å‡ºçš„æ ¼å¼æ˜¯ä¸æ˜ç¡®çš„ï¼Œå› ä¸ºè¿™æœ‰æ›´å¤šæ˜¾ç¤ºçš„å¯èƒ½æ€§ï¼šæ˜¯å¦éœ€è¦é€—å·ï¼Ÿéœ€è¦æ‰“å°å‡ºå¤§æ‹¬å·å—ï¼Ÿæ‰€æœ‰å­—æ®µéƒ½åº”è¯¥æ˜¾ç¤ºå—ï¼Ÿç”±äºè¿™ç§ä¸ç¡®å®šæ€§ï¼ŒRust ä¸ä¼šå°è¯•çŒœæµ‹æˆ‘ä»¬çš„æ„å›¾ï¼Œæ‰€ä»¥ç»“æ„ä½“å¹¶æ²¡æœ‰æä¾›ä¸€ä¸ª `Display` å®ç°æ¥ä½¿ç”¨ `println!` ä¸ `{}` å ä½ç¬¦

ä½†æ˜¯å¦‚æœæˆ‘ä»¬ç»§ç»­é˜…è¯»é”™è¯¯ï¼Œå°†ä¼šå‘ç°è¿™ä¸ªæœ‰å¸®åŠ©çš„ä¿¡æ¯ï¼š

```rust
= help: the trait `std::fmt::Display` is not implemented for `Rectangle`
= note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
```

è®©æˆ‘ä»¬æ¥è¯•è¯•ï¼ç°åœ¨ `println!` å®è°ƒç”¨çœ‹èµ·æ¥åƒ `println!("rect1 is {:?}", rect1);` è¿™æ ·ã€‚åœ¨ `{}` ä¸­åŠ å…¥ `:?` æŒ‡ç¤ºç¬¦å‘Šè¯‰ `println!` æˆ‘ä»¬æƒ³è¦ä½¿ç”¨å«åš `Debug` çš„è¾“å‡ºæ ¼å¼ã€‚`Debug` æ˜¯ä¸€ä¸ª traitï¼Œå®ƒå…è®¸æˆ‘ä»¬ä»¥ä¸€ç§å¯¹å¼€å‘è€…æœ‰å¸®åŠ©çš„æ–¹å¼æ‰“å°ç»“æ„ä½“ï¼Œä»¥ä¾¿å½“æˆ‘ä»¬è°ƒè¯•ä»£ç æ—¶èƒ½çœ‹åˆ°å®ƒçš„å€¼

è¿™æ ·è°ƒæ•´åå†æ¬¡è¿è¡Œç¨‹åºåï¼Œä»ç„¶èƒ½çœ‹åˆ°ä¸€ä¸ªé”™è¯¯

```rust
error[E0277]: `Rectangle` doesn't implement `Debug`
```

ä¸è¿‡ç¼–è¯‘å™¨åˆä¸€æ¬¡ç»™å‡ºäº†ä¸€ä¸ªæœ‰å¸®åŠ©çš„ä¿¡æ¯ï¼š

```rust
= help: the trait `Debug` is not implemented for `Rectangle`
= note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
```

Rust **ç¡®å®** åŒ…å«äº†æ‰“å°å‡ºè°ƒè¯•ä¿¡æ¯çš„åŠŸèƒ½ï¼Œä¸è¿‡æˆ‘ä»¬å¿…é¡»ä¸ºç»“æ„ä½“æ˜¾å¼é€‰æ‹©è¿™ä¸ªåŠŸèƒ½ã€‚ä¸ºæ­¤ï¼Œåœ¨ç»“æ„ä½“å®šä¹‰ä¹‹å‰åŠ ä¸Šå¤–éƒ¨å±æ€§ `#[derive(Debug)]`

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
```

å¦ä¸€ç§ä½¿ç”¨ `Debug` æ ¼å¼æ‰“å°æ•°å€¼çš„æ–¹æ³•æ˜¯ä½¿ç”¨ `dbg!` å®ã€‚`dbg!` å®æ¥æ”¶ä¸€ä¸ªè¡¨è¾¾å¼çš„æ‰€æœ‰æƒï¼ˆä¸ `println!` å®ç›¸åï¼Œåè€…æ¥æ”¶çš„æ˜¯å¼•ç”¨ï¼‰ï¼Œæ‰“å°å‡ºä»£ç ä¸­è°ƒç”¨ dbg! å®æ—¶æ‰€åœ¨çš„æ–‡ä»¶å’Œè¡Œå·ï¼Œä»¥åŠè¯¥è¡¨è¾¾å¼çš„ç»“æœå€¼ï¼Œå¹¶è¿”å›è¯¥å€¼çš„æ‰€æœ‰æƒ

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```

æˆ‘ä»¬å¯ä»¥æŠŠ `dbg!` æ”¾åœ¨è¡¨è¾¾å¼ `30 * scale` å‘¨å›´ï¼Œå› ä¸º `dbg!` è¿”å›è¡¨è¾¾å¼çš„å€¼çš„æ‰€æœ‰æƒï¼Œæ‰€ä»¥ `width` å­—æ®µå°†è·å¾—ç›¸åŒçš„å€¼ï¼Œå°±åƒæˆ‘ä»¬åœ¨é‚£é‡Œæ²¡æœ‰ `dbg!` è°ƒç”¨ä¸€æ ·ã€‚æˆ‘ä»¬ä¸å¸Œæœ› `dbg!` æ‹¥æœ‰ `rect1` çš„æ‰€æœ‰æƒï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨ä¸‹ä¸€æ¬¡è°ƒç”¨ `dbg!` æ—¶ä¼ é€’ä¸€ä¸ªå¼•ç”¨ã€‚ä¸‹é¢æ˜¯è¿™ä¸ªä¾‹å­çš„è¾“å‡ºç»“æœï¼š

```rust
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &rect1 = Rectangle {
    width: 60,
    height: 50,
}
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç¬¬ä¸€ç‚¹è¾“å‡ºæ¥è‡ª *src/main.rs* ç¬¬ 10 è¡Œï¼Œæˆ‘ä»¬æ­£åœ¨è°ƒè¯•è¡¨è¾¾å¼ `30 * scale`ï¼Œå…¶ç»“æœå€¼æ˜¯60ï¼ˆä¸ºæ•´æ•°å®ç°çš„ `Debug` æ ¼å¼åŒ–æ˜¯åªæ‰“å°å®ƒä»¬çš„å€¼ï¼‰ã€‚åœ¨ *src/main.rs* ç¬¬ 14è¡Œ çš„ `dbg!` è°ƒç”¨è¾“å‡º `&rect1` çš„å€¼ï¼Œå³ `Rectangle` ç»“æ„ã€‚è¿™ä¸ªè¾“å‡ºä½¿ç”¨äº†æ›´ä¸ºæ˜“è¯»çš„ `Debug` æ ¼å¼ã€‚å½“ä½ è¯•å›¾å¼„æ¸…æ¥šä½ çš„ä»£ç åœ¨åšä»€ä¹ˆæ—¶ï¼Œ`dbg!` å®å¯èƒ½çœŸçš„å¾ˆæœ‰å¸®åŠ©!

é™¤äº† `Debug` traitï¼ŒRust è¿˜ä¸ºæˆ‘ä»¬æä¾›äº†å¾ˆå¤šå¯ä»¥é€šè¿‡ `derive` å±æ€§æ¥ä½¿ç”¨çš„ traitï¼Œä»–ä»¬å¯ä»¥ä¸ºæˆ‘ä»¬çš„è‡ªå®šä¹‰ç±»å‹å¢åŠ å®ç”¨çš„è¡Œä¸º

#### 5.2.4 æ€»ç»“

+ `std::fmt::Display`
+ `std::fmt::Debug`
+ `#[derive(Debug)]`
+ `{:?}`
+ `{:#?}`



### 5.3 struct æ–¹æ³•

#### 5.3.1 æ–¹æ³•çš„åˆ›å»ºè§„åˆ™

+ **æ–¹æ³•**ï¼ˆmethodï¼‰ä¸å‡½æ•°ç±»ä¼¼ï¼šå®ƒä»¬ä½¿ç”¨ `fn` å…³é”®å­—å’Œåç§°å£°æ˜ï¼Œå¯ä»¥æ‹¥æœ‰å‚æ•°å’Œè¿”å›å€¼ï¼ŒåŒæ—¶åŒ…å«åœ¨æŸå¤„è°ƒç”¨è¯¥æ–¹æ³•æ—¶ä¼šæ‰§è¡Œçš„ä»£ç ã€‚

+ ä¸è¿‡æ–¹æ³•ä¸å‡½æ•°æ˜¯ä¸åŒçš„ï¼š

  + å®ƒä»¬åœ¨ç»“æ„ä½“çš„ä¸Šä¸‹æ–‡ä¸­è¢«å®šä¹‰ï¼ˆæˆ–è€…æ˜¯æšä¸¾æˆ– trait å¯¹è±¡çš„ä¸Šä¸‹æ–‡ï¼‰
  + ç¬¬ä¸€ä¸ªå‚æ•°æ€»æ˜¯ `self`ï¼Œå®ƒä»£è¡¨è°ƒç”¨è¯¥æ–¹æ³•çš„ç»“æ„ä½“å®ä¾‹

  ```rust
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }
  
  impl Rectangle {
      fn area(&self) -> u32 {
          self.width * self.height
      }
  }
  
  fn main() {
      let rect1 = Rectangle {
          width: 30,
          height: 50,
      };
  
      println!(
          "The area of the rectangle is {} square pixels.",
          rect1.area()
      );
  }
  ```

+ åœ¨`impl`å—é‡Œå®šä¹‰æ–¹æ³•

+ æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°å¯ä»¥æ˜¯`&self`ï¼Œä¹Ÿå¯ä»¥è·å¾—å…¶æ‰€æœ‰æƒæˆ–å¯å˜å€Ÿç”¨ã€‚å’Œå…¶å®ƒå‚æ•°ä¸€æ ·

+ æ›´è‰¯å¥½çš„ä»£ç ç»„ç»‡

#### 5.3.2 æ–¹æ³•è°ƒç”¨çš„è¿ç®—ç¬¦

+ C/C++ï¼š`object -> something()` å°±å’Œ `(*object).something()`ä¸€æ ·ï¼Œéœ€è¦å…ˆè§£å¼•ç”¨ï¼ˆdereferenceï¼‰
+ Rustæ²¡æœ‰ `->`è¿ç®—ç¬¦
+ Rustä¼šè‡ªåŠ¨å¼•ç”¨æˆ–è§£å¼•ç”¨
  + åœ¨è°ƒç”¨æ–¹æ³•æ—¶å°±ä¼šå‘ç”Ÿè¿™ç§è¡Œä¸º
+ åœ¨è°ƒç”¨æ–¹æ³•æ—¶ï¼ŒRustæ ¹æ®æƒ…å†µè‡ªåŠ¨æ·»åŠ `&`ã€`&mut`æˆ–`*`ï¼Œä»¥ä¾¿ object å¯ä»¥åŒ¹é…æ–¹æ³•çš„ç­¾å
+ ä¸‹é¢ä¸¤è¡Œä»£ç æ•ˆæœç›¸åŒ
  + `p1.distance(&p2);`
  + `(&p1).distance(&p2);`

#### 5.3.3 æ–¹æ³•å‚æ•°

æ–¹æ³•å¯ä»¥æœ‰å¤šä¸ªå‚æ•°

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```

#### 5.3.4 å…³è”å‡½æ•°

+ å¯ä»¥åœ¨`impl`å—é‡Œå®šä¹‰ä¸æŠŠ`self`ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°çš„å‡½æ•°ï¼Œå®ƒä»¬å«åšå…³è”å‡½æ•°ï¼ˆä¸æ˜¯æ–¹æ³•ï¼‰

  + ä¾‹å¦‚ï¼š`String::from()`

+ å…³è”å‡½æ•°é€šå¸¸ç”¨äºæ„é€ å™¨

  ```rust
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }
  
  impl Rectangle {
      fn square(size: u32) -> Self {
          Self {
              width: size,
              height: size,
          }
      }
  }
  
  fn main() {
      let sq = Rectangle::square(3);
  }
  ```

+ `::`ç¬¦å·

  + å…³è”å‡½æ•°
  + æ¨¡å—åˆ›å»ºçš„å‘½åç©ºé—´

#### 5.3.4 å¤šä¸ª impl å—

+ æ¯ä¸ª`struct`å…è®¸æ‹¥æœ‰å¤šä¸ª`impl`å—

  ```rust
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }
  
  impl Rectangle {
      fn area(&self) -> u32 {
          self.width * self.height
      }
  }
  
  impl Rectangle {
      fn can_hold(&self, other: &Rectangle) -> bool {
          self.width > other.width && self.height > other.height
      }
  }
  
  fn main() {
      let rect1 = Rectangle {
          width: 30,
          height: 50,
      };
      let rect2 = Rectangle {
          width: 10,
          height: 40,
      };
      let rect3 = Rectangle {
          width: 60,
          height: 45,
      };
  
      println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
      println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
  }
  ```

> ç»“æ„ä½“è®©ä½ å¯ä»¥åˆ›å»ºå‡ºåœ¨ä½ çš„é¢†åŸŸä¸­æœ‰æ„ä¹‰çš„è‡ªå®šä¹‰ç±»å‹ã€‚é€šè¿‡ç»“æ„ä½“ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç›¸å…³è”çš„æ•°æ®ç‰‡æ®µè”ç³»èµ·æ¥å¹¶å‘½åå®ƒä»¬ï¼Œè¿™æ ·å¯ä»¥ä½¿å¾—ä»£ç æ›´åŠ æ¸…æ™°ã€‚åœ¨ `impl` å—ä¸­ï¼Œä½ å¯ä»¥å®šä¹‰ä¸ä½ çš„ç±»å‹ç›¸å…³è”çš„å‡½æ•°ï¼Œè€Œæ–¹æ³•æ˜¯ä¸€ç§ç›¸å…³è”çš„å‡½æ•°ï¼Œè®©ä½ æŒ‡å®šç»“æ„ä½“çš„å®ä¾‹æ‰€å…·æœ‰çš„è¡Œä¸ºã€‚

ä½†ç»“æ„ä½“å¹¶ä¸æ˜¯åˆ›å»ºè‡ªå®šä¹‰ç±»å‹çš„å”¯ä¸€æ–¹æ³•ï¼šè®©æˆ‘ä»¬è½¬å‘ Rust çš„æšä¸¾åŠŸèƒ½ï¼Œä¸ºä½ çš„å·¥å…·ç®±å†æ·»ä¸€ä¸ªå·¥å…·



## 6ã€æšä¸¾ä¸æ¨¡å¼åŒ¹é…

**æšä¸¾**ï¼ˆ*enumerations*ï¼‰ï¼Œä¹Ÿè¢«ç§°ä½œ *enums*ã€‚æšä¸¾å…è®¸ä½ é€šè¿‡åˆ—ä¸¾å¯èƒ½çš„ **æˆå‘˜**ï¼ˆ*variants*ï¼‰ æ¥å®šä¹‰ä¸€ä¸ªç±»å‹ã€‚

### 6.1 æšä¸¾çš„å®šä¹‰

+ IPåœ°å€ï¼šIPv4ã€IPv6

  ```rust
  enum IpAddrKind {
      V4,
      V6,
  }
  ```

  `V4` å’Œ `V6`ï¼Œè¢«ç§°ä¸ºæšä¸¾çš„ **æˆå‘˜**ï¼ˆ*variants*ï¼‰

#### 6.1.1 æšä¸¾å€¼

å¯ä»¥åƒè¿™æ ·åˆ›å»º `IpAddrKind` ä¸¤ä¸ªä¸åŒæˆå‘˜çš„å®ä¾‹ï¼š

```rust
let four = IpAddrKind::V4
let six = IpAddrKind::V6
```

==æ³¨æ„æšä¸¾çš„æˆå‘˜ä½äºå…¶æ ‡è¯†ç¬¦çš„å‘½åç©ºé—´ä¸­ï¼Œå¹¶ä½¿ç”¨ä¸¤ä¸ªå†’å·åˆ†å¼€==ã€‚è¿™ä¹ˆè®¾è®¡çš„ç›Šå¤„æ˜¯ç°åœ¨ `IpAddrKind::V4` å’Œ `IpAddrKind::V6` éƒ½æ˜¯ `IpAddrKind` ç±»å‹çš„ã€‚ä¾‹å¦‚ï¼Œæ¥ç€å¯ä»¥å®šä¹‰ä¸€ä¸ªå‡½æ•°æ¥è·å–ä»»ä½• `IpAddrKind`ï¼š

```rust
fn route(ip_kind: IpAddrKind) {}
```

ç°åœ¨å¯ä»¥ä½¿ç”¨ä»»ä¸€æˆå‘˜æ¥è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼š

```rust
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```

#### 6.1.2 å°†æ•°æ®é™„åŠ åˆ°æšä¸¾çš„å˜ä½“ä¸­

ä½¿ç”¨æšä¸¾ç”šè‡³è¿˜æœ‰æ›´å¤šä¼˜åŠ¿ã€‚è¿›ä¸€æ­¥è€ƒè™‘ä¸€ä¸‹æˆ‘ä»¬çš„ IP åœ°å€ç±»å‹ï¼Œç›®å‰æ²¡æœ‰ä¸€ä¸ªå­˜å‚¨å®é™… IP åœ°å€ **æ•°æ®** çš„æ–¹æ³•ï¼›åªçŸ¥é“å®ƒæ˜¯ä»€ä¹ˆ **ç±»å‹** çš„ã€‚è€ƒè™‘åˆ°å·²ç»åœ¨ç¬¬äº”ç« å­¦ä¹ è¿‡ç»“æ„ä½“äº†ï¼Œä½ å¯èƒ½ä¼šåƒè¿™æ ·å¤„ç†é—®é¢˜ï¼š

```rust
fn main() {
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
}
```

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ç§æ›´ç®€æ´çš„æ–¹å¼æ¥è¡¨è¾¾ç›¸åŒçš„æ¦‚å¿µï¼Œä»…ä»…ä½¿ç”¨æšä¸¾å¹¶å°†æ•°æ®ç›´æ¥æ”¾è¿›æ¯ä¸€ä¸ªæšä¸¾æˆå‘˜è€Œä¸æ˜¯å°†æšä¸¾ä½œä¸ºç»“æ„ä½“çš„ä¸€éƒ¨åˆ†ã€‚`IpAddr` æšä¸¾çš„æ–°å®šä¹‰è¡¨æ˜äº† `V4` å’Œ `V6` æˆå‘˜éƒ½å…³è”äº† `String` å€¼ï¼š

```rust
fn main() {
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
}
```

ä¼˜ç‚¹ï¼š

+ ä¸éœ€è¦é¢å¤–ä½¿ç”¨`struct`
+ æ¯ä¸ªå˜ä½“å¯ä»¥æ‹¥æœ‰ä¸åŒçš„ç±»å‹ä»¥åŠå…³è”çš„æ•°æ®é‡

ç”¨æšä¸¾æ›¿ä»£ç»“æ„ä½“è¿˜æœ‰å¦ä¸€ä¸ªä¼˜åŠ¿ï¼šæ¯ä¸ªæˆå‘˜å¯ä»¥å¤„ç†ä¸åŒç±»å‹å’Œæ•°é‡çš„æ•°æ®ã€‚IPv4 ç‰ˆæœ¬çš„ IP åœ°å€æ€»æ˜¯å«æœ‰å››ä¸ªå€¼åœ¨ 0 å’Œ 255 ä¹‹é—´çš„æ•°å­—éƒ¨åˆ†ã€‚å¦‚æœæˆ‘ä»¬æƒ³è¦å°† `V4` åœ°å€å­˜å‚¨ä¸ºå››ä¸ª `u8` å€¼è€Œ `V6` åœ°å€ä»ç„¶è¡¨ç°ä¸ºä¸€ä¸ª `String`ï¼Œè¿™å°±ä¸èƒ½ä½¿ç”¨ç»“æ„ä½“äº†ã€‚æšä¸¾åˆ™å¯ä»¥è½»æ˜“çš„å¤„ç†è¿™ä¸ªæƒ…å†µï¼š

```rust
fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
}
```

#### 6.1.3 æ ‡å‡†åº“ä¸­çš„IpAddr

äº‹å®è¯æ˜å­˜å‚¨å’Œç¼–ç  IP åœ°å€å®åœ¨æ˜¯å¤ªå¸¸è§äº†ä»¥è‡³äºæ ‡å‡†åº“æä¾›äº†ä¸€ä¸ªå¼€ç®±å³ç”¨çš„å®šä¹‰ï¼è®©æˆ‘ä»¬çœ‹çœ‹æ ‡å‡†åº“æ˜¯å¦‚ä½•å®šä¹‰ `IpAddr` çš„ï¼šå®ƒæ­£æœ‰ç€è·Ÿæˆ‘ä»¬å®šä¹‰å’Œä½¿ç”¨çš„ä¸€æ ·çš„æšä¸¾å’Œæˆå‘˜ï¼Œä¸è¿‡å®ƒå°†æˆå‘˜ä¸­çš„åœ°å€æ•°æ®åµŒå…¥åˆ°äº†ä¸¤ä¸ªä¸åŒå½¢å¼çš„ç»“æ„ä½“ä¸­ï¼Œå®ƒä»¬å¯¹ä¸åŒçš„æˆå‘˜çš„å®šä¹‰æ˜¯ä¸åŒçš„ï¼š

```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

å¯ä»¥å°†ä»»æ„ç±»å‹çš„æ•°æ®æ”¾å…¥æšä¸¾æˆå‘˜ä¸­ï¼šä¾‹å¦‚å­—ç¬¦ä¸²ã€æ•°å­—ç±»å‹æˆ–è€…ç»“æ„ä½“ã€‚ç”šè‡³å¯ä»¥åŒ…å«å¦ä¸€ä¸ªæšä¸¾ï¼å¦å¤–ï¼Œæ ‡å‡†åº“ä¸­çš„ç±»å‹é€šå¸¸å¹¶ä¸æ¯”ä½ è®¾æƒ³å‡ºæ¥çš„è¦å¤æ‚å¤šå°‘ã€‚

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

#### 6.1.4 ä¸ºæšä¸¾å®šä¹‰æ–¹æ³•

ç»“æ„ä½“å’Œæšä¸¾è¿˜æœ‰å¦ä¸€ä¸ªç›¸ä¼¼ç‚¹ï¼šå°±åƒå¯ä»¥ä½¿ç”¨ `impl` æ¥ä¸ºç»“æ„ä½“å®šä¹‰æ–¹æ³•é‚£æ ·ï¼Œä¹Ÿå¯ä»¥åœ¨æšä¸¾ä¸Šå®šä¹‰æ–¹æ³•ã€‚è¿™æ˜¯ä¸€ä¸ªå®šä¹‰äºæˆ‘ä»¬ `Message` æšä¸¾ä¸Šçš„å«åš `call` çš„æ–¹æ³•ï¼š

```rust
fn main() {
    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32, i32),
    }

    impl Message {
        fn call(&self) {
            // åœ¨è¿™é‡Œå®šä¹‰æ–¹æ³•ä½“
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
}
```

#### 6.1.5 Optionæšä¸¾

+ å®šä¹‰äºæ ‡å‡†åº“ä¸­
+ åœ¨`Prelude`ï¼ˆé¢„å¯¼å…¥æ¨¡å—ï¼‰ä¸­
+ æè¿°äº†ï¼šæŸä¸ªå€¼å¯èƒ½å­˜åœ¨ï¼ˆæŸç§ç±»å‹ï¼‰æˆ–ä¸å­˜åœ¨çš„æƒ…å†µ

Rust å¹¶æ²¡æœ‰å¾ˆå¤šå…¶ä»–è¯­è¨€ä¸­æœ‰çš„ç©ºå€¼åŠŸèƒ½ã€‚**ç©ºå€¼**ï¼ˆ*Null* ï¼‰æ˜¯ä¸€ä¸ªå€¼ï¼Œå®ƒä»£è¡¨æ²¡æœ‰å€¼ã€‚åœ¨æœ‰ç©ºå€¼çš„è¯­è¨€ä¸­ï¼Œå˜é‡æ€»æ˜¯è¿™ä¸¤ç§çŠ¶æ€ä¹‹ä¸€ï¼šç©ºå€¼å’Œéç©ºå€¼ã€‚

Nullå¼•ç”¨ï¼šThe Billion Dollar Mistake

ç©ºå€¼çš„é—®é¢˜åœ¨äºå½“ä½ å°è¯•åƒä¸€ä¸ªéç©ºå€¼é‚£æ ·ä½¿ç”¨ä¸€ä¸ªç©ºå€¼ï¼Œä¼šå‡ºç°æŸç§å½¢å¼çš„é”™è¯¯ã€‚å› ä¸ºç©ºå’Œéç©ºçš„å±æ€§æ— å¤„ä¸åœ¨ï¼Œéå¸¸å®¹æ˜“å‡ºç°è¿™ç±»é”™è¯¯ã€‚

ç©ºå€¼å°è¯•è¡¨è¾¾çš„æ¦‚å¿µä»ç„¶æ˜¯æœ‰æ„ä¹‰çš„ï¼šç©ºå€¼æ˜¯ä¸€ä¸ªå› ä¸ºæŸç§åŸå› ç›®å‰æ— æ•ˆæˆ–ç¼ºå¤±çš„å€¼ã€‚

é—®é¢˜ä¸åœ¨äºæ¦‚å¿µè€Œåœ¨äºå…·ä½“çš„å®ç°ã€‚ä¸ºæ­¤ï¼ŒRust å¹¶æ²¡æœ‰ç©ºå€¼ï¼Œä¸è¿‡å®ƒç¡®å®æ‹¥æœ‰ä¸€ä¸ªå¯ä»¥ç¼–ç å­˜åœ¨æˆ–ä¸å­˜åœ¨æ¦‚å¿µçš„æšä¸¾ã€‚è¿™ä¸ªæšä¸¾æ˜¯ `Option<T>`ï¼Œå®ƒåœ¨æ ‡å‡†åº“ä¸­å®šä¹‰ã€‚

```rust
enum Option<T> {
    Some(T),
    None,
}
```

Optionæšä¸¾åŒ…å«åœ¨`Prelude`ï¼ˆé¢„å¯¼å…¥æ¨¡å—ï¼‰ä¸­ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ï¼š

+ `Option<T>`
+ `Some(T)`
+ `None`

`Option<T>` æ¯” `Null` å¥½åœ¨å“ªï¼Ÿ

+ `Option<T>` å’Œ `T` æ˜¯ä¸åŒçš„ç±»å‹ï¼Œä¸å¯ä»¥æŠŠ `Option<T>`ç›´æ¥å½“æˆ`T`

  ```rust
  let x: i8 = 5;
  let y: Option<i8> = Some(5);
  
  let sum = x + y;
  ```

  ```rust
  $ cargo run
     Compiling enums v0.1.0 (file:///projects/enums)
  error[E0277]: cannot add `Option<i8>` to `i8`
   --> src/main.rs:5:17
    |
  5 |     let sum = x + y;
    |                 ^ no implementation for `i8 + Option<i8>`
    |
    = help: the trait `Add<Option<i8>>` is not implemented for `i8`
  
  For more information about this error, try `rustc --explain E0277`.
  error: could not compile `enums` due to previous error
  ```

é”™è¯¯ä¿¡æ¯æ„å‘³ç€ Rust ä¸çŸ¥é“è¯¥å¦‚ä½•å°† `Option<i8>` ä¸ `i8` ç›¸åŠ ï¼Œå› ä¸ºå®ƒä»¬çš„ç±»å‹ä¸åŒã€‚å½“åœ¨ Rust ä¸­æ‹¥æœ‰ä¸€ä¸ªåƒ `i8` è¿™æ ·ç±»å‹çš„å€¼æ—¶ï¼Œç¼–è¯‘å™¨ç¡®ä¿å®ƒæ€»æ˜¯æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„å€¼ã€‚æˆ‘ä»¬å¯ä»¥è‡ªä¿¡ä½¿ç”¨è€Œæ— éœ€åšç©ºå€¼æ£€æŸ¥ã€‚åªæœ‰å½“ä½¿ç”¨ `Option<i8>`ï¼ˆæˆ–è€…ä»»ä½•ç”¨åˆ°çš„ç±»å‹ï¼‰çš„æ—¶å€™éœ€è¦æ‹…å¿ƒå¯èƒ½æ²¡æœ‰å€¼ï¼Œè€Œç¼–è¯‘å™¨ä¼šç¡®ä¿æˆ‘ä»¬åœ¨ä½¿ç”¨å€¼ä¹‹å‰å¤„ç†äº†ä¸ºç©ºçš„æƒ…å†µã€‚

æ¢å¥è¯è¯´ï¼Œåœ¨å¯¹ `Option<T>` è¿›è¡Œ `T` çš„è¿ç®—ä¹‹å‰å¿…é¡»å°†å…¶è½¬æ¢ä¸º `T`



### 6.2 matchæ§åˆ¶æµç»“æ„

Rust æœ‰ä¸€ä¸ªå«åš `match` çš„æä¸ºå¼ºå¤§çš„æ§åˆ¶æµè¿ç®—ç¬¦ï¼Œå®ƒå…è®¸æˆ‘ä»¬å°†ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—çš„æ¨¡å¼ç›¸æ¯”è¾ƒï¼Œå¹¶æ ¹æ®ç›¸åŒ¹é…çš„æ¨¡å¼æ‰§è¡Œç›¸åº”ä»£ç ã€‚æ¨¡å¼å¯ç”±å­—é¢å€¼ã€å˜é‡ã€é€šé…ç¬¦å’Œè®¸å¤šå…¶ä»–å†…å®¹æ„æˆã€‚

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

fn main() {}
```

#### 6.2.1 ç»‘å®šå€¼çš„æ¨¡å¼

åŒ¹é…åˆ†æ”¯çš„å¦ä¸€ä¸ªæœ‰ç”¨çš„åŠŸèƒ½æ˜¯å¯ä»¥ç»‘å®šåŒ¹é…çš„æ¨¡å¼çš„éƒ¨åˆ†å€¼ã€‚è¿™ä¹Ÿå°±æ˜¯å¦‚ä½•ä»æšä¸¾æˆå‘˜ä¸­æå–å€¼çš„

```rust
#[derive(Debug)] // è¿™æ ·å¯ä»¥ç«‹åˆ»çœ‹åˆ°å·çš„åç§°
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}

fn main() {
    let state = value_in_cents(Coin::Quarter(UsState::Alaska));
    println!("{}", state)
}

```

#### 6.2.2 åŒ¹é… Option\<T>

æˆ‘ä»¬åœ¨ä¹‹å‰çš„éƒ¨åˆ†ä¸­ä½¿ç”¨ `Option<T>` æ—¶ï¼Œæ˜¯ä¸ºäº†ä» `Some` ä¸­å–å‡ºå…¶å†…éƒ¨çš„ `T` å€¼ï¼›æˆ‘ä»¬è¿˜å¯ä»¥åƒå¤„ç† `Coin` æšä¸¾é‚£æ ·ä½¿ç”¨ `match` å¤„ç† `Option<T>`ï¼åªä¸è¿‡è¿™å›æ¯”è¾ƒçš„ä¸å†æ˜¯ç¡¬å¸ï¼Œè€Œæ˜¯ `Option<T>` çš„æˆå‘˜ï¼Œä½† `match` è¡¨è¾¾å¼çš„å·¥ä½œæ–¹å¼ä¿æŒä¸å˜ã€‚

æ¯”å¦‚æˆ‘ä»¬æƒ³è¦ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒè·å–ä¸€ä¸ª `Option<i32>` ï¼Œå¦‚æœå…¶ä¸­å«æœ‰ä¸€ä¸ªå€¼ï¼Œå°†å…¶åŠ ä¸€ã€‚å¦‚æœå…¶ä¸­æ²¡æœ‰å€¼ï¼Œå‡½æ•°åº”è¯¥è¿”å› `None` å€¼ï¼Œè€Œä¸å°è¯•æ‰§è¡Œä»»ä½•æ“ä½œã€‚

```rust
fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
```

#### 6.2.3 matchåŒ¹é…å¿…é¡»ç©·ä¸¾æ‰€æœ‰çš„å¯èƒ½

`match` è¿˜æœ‰å¦ä¸€æ–¹é¢éœ€è¦è®¨è®ºï¼šè¿™äº›åˆ†æ”¯å¿…é¡»è¦†ç›–äº†æ‰€æœ‰çš„å¯èƒ½æ€§ã€‚è€ƒè™‘ä¸€ä¸‹ `plus_one` å‡½æ•°çš„è¿™ä¸ªç‰ˆæœ¬ï¼Œå®ƒæœ‰ä¸€ä¸ª bug å¹¶ä¸èƒ½ç¼–è¯‘ï¼š

```rust
fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
```

```rust
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --> src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option<i32>`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
```

Rust çŸ¥é“æˆ‘ä»¬æ²¡æœ‰è¦†ç›–æ‰€æœ‰å¯èƒ½çš„æƒ…å†µç”šè‡³çŸ¥é“å“ªäº›æ¨¡å¼è¢«å¿˜è®°äº†ï¼Rust ä¸­çš„åŒ¹é…æ˜¯ **ç©·å°½çš„**ï¼ˆ*exhaustive*ï¼‰ï¼šå¿…é¡»ç©·ä¸¾åˆ°æœ€åçš„å¯èƒ½æ€§æ¥ä½¿ä»£ç æœ‰æ•ˆã€‚ç‰¹åˆ«çš„åœ¨è¿™ä¸ª `Option<T>` çš„ä¾‹å­ä¸­ï¼ŒRust é˜²æ­¢æˆ‘ä»¬å¿˜è®°æ˜ç¡®çš„å¤„ç† `None` çš„æƒ…å†µï¼Œè¿™è®©æˆ‘ä»¬å…äºå‡è®¾æ‹¥æœ‰ä¸€ä¸ªå®é™…ä¸Šä¸ºç©ºçš„å€¼ï¼Œä»è€Œä½¿ä¹‹å‰æåˆ°çš„ä»·å€¼äº¿ä¸‡çš„é”™è¯¯ä¸å¯èƒ½å‘ç”Ÿã€‚

#### 6.2.4 é€šé…æ¨¡å¼å’Œ _ å ä½ç¬¦

æˆ‘ä»¬å¸Œæœ›å¯¹ä¸€äº›ç‰¹å®šçš„å€¼é‡‡å–ç‰¹æ®Šæ“ä½œï¼Œè€Œå¯¹å…¶ä»–çš„å€¼é‡‡å–é»˜è®¤æ“ä½œã€‚è¿™æ—¶ï¼Œå¯ä»¥ä½¿ç”¨é€šé…æ¨¡å¼otheræˆ– _ å ä½ç¬¦æ¥æ›¿ä»£å…¶ä½™æ²¡åˆ—å‡ºçš„å€¼ã€‚

```rust
fn main() {
    let v = 1u8;

    match v {
        1 => println!("one"),
        3 => println!("three"),
        5 => println!("five"),
        7 => println!("seven"),
        _other => println!("{}", _other),
    }

    match v {
        1 => println!("one"),
        3 => println!("three"),
        5 => println!("five"),
        7 => println!("seven"),
        _ => (),
    }
}
```

`other`å’Œ`_`çš„ä½œç”¨æ˜¯ç±»ä¼¼çš„ï¼Œåªä¸è¿‡ä½¿ç”¨`other`å¯ä»¥è·å–åˆ°å€¼ã€‚



### 6.3 if let ç®€æ´æ§åˆ¶æµ

`if let`å¤„ç†åªå…³å¿ƒä¸€ç§åŒ¹é…è€Œå¿½ç•¥å…¶å®ƒåŒ¹é…çš„æƒ…å†µ

```rust
fn main() {
    let v = Some(0u8);
    match v {
        Some(3) => println!("three"),
        _ => (),
    }

    if let Some(3) = v {
        println!("three");
    }
}
```

`if let` è¯­æ³•è·å–é€šè¿‡ç­‰å·åˆ†éš”çš„ä¸€ä¸ªæ¨¡å¼å’Œä¸€ä¸ªè¡¨è¾¾å¼ã€‚å®ƒçš„å·¥ä½œæ–¹å¼ä¸ `match` ç›¸åŒï¼Œè¿™é‡Œçš„è¡¨è¾¾å¼å¯¹åº” `match` è€Œæ¨¡å¼åˆ™å¯¹åº”ç¬¬ä¸€ä¸ªåˆ†æ”¯ã€‚

ä½¿ç”¨ `if let` æ„å‘³ç€ç¼–å†™æ›´å°‘ä»£ç ï¼Œæ›´å°‘çš„ç¼©è¿›å’Œæ›´å°‘çš„æ ·æ¿ä»£ç ã€‚ç„¶è€Œï¼Œè¿™æ ·ä¼šå¤±å» `match` å¼ºåˆ¶è¦æ±‚çš„ç©·å°½æ€§æ£€æŸ¥ã€‚`match` å’Œ `if let` ä¹‹é—´çš„é€‰æ‹©ä¾èµ–ç‰¹å®šçš„ç¯å¢ƒä»¥åŠå¢åŠ ç®€æ´åº¦å’Œå¤±å»ç©·å°½æ€§æ£€æŸ¥çš„æƒè¡¡å–èˆã€‚

å¯ä»¥è®¤ä¸º `if let` æ˜¯ `match` çš„ä¸€ä¸ªè¯­æ³•ç³–ï¼Œå®ƒå½“å€¼åŒ¹é…æŸä¸€æ¨¡å¼æ—¶æ‰§è¡Œä»£ç è€Œå¿½ç•¥æ‰€æœ‰å…¶ä»–å€¼ã€‚

å¯ä»¥åœ¨ `if let` ä¸­åŒ…å«ä¸€ä¸ª `else`ã€‚`else` å—ä¸­çš„ä»£ç ä¸ `match` è¡¨è¾¾å¼ä¸­çš„ `_` åˆ†æ”¯å—ä¸­çš„ä»£ç ç›¸åŒï¼Œè¿™æ ·çš„ `match` è¡¨è¾¾å¼å°±ç­‰åŒäº `if let` å’Œ `else`ã€‚ 

```rust
fn main() {
    let v = Some(0u8);
    match v {
        Some(3) => println!("three"),
        _ => (),
    }

    if let Some(3) = v {
        println!("three");
    } else {
        println!("others");
    }
}
```



## 7ã€Packageã€Crateã€Module

Rustçš„ä»£ç ç»„ç»‡

+ ä»£ç ç»„ç»‡ä¸»è¦åŒ…æ‹¬ï¼š

  + å“ªäº›ç»†èŠ‚å¯ä»¥æš´éœ²ï¼Œå“ªäº›ç»†èŠ‚æ˜¯ç§æœ‰çš„

  + ä½œç”¨åŸŸå†…å“ªäº›åç§°æ˜¯æœ‰æ•ˆçš„

+ æ¨¡å—ç³»ç»Ÿï¼š

  + Packageï¼ˆåŒ…ï¼‰ï¼šCargoçš„ç‰¹æ€§ï¼Œè®©ä½ æ„å»ºã€æµ‹è¯•ã€å…±äº«crate
  + Crateï¼ˆå•å…ƒåŒ…ï¼‰ï¼šä¸€ä¸ªæ¨¡å—æ ‘ï¼Œå®ƒå¯ä»¥äº§ç”Ÿä¸€ä¸ªlibraryæˆ–å¯æ‰§è¡Œæ–‡ä»¶
  + Moduleï¼ˆæ¨¡å—ï¼‰ã€useï¼šè®©ä½ æ§åˆ¶ä»£ç çš„ç»„ç»‡ã€ä½œç”¨åŸŸã€ç§æœ‰è·¯å¾„
  + Pathï¼ˆè·¯å¾„ï¼‰ï¼šä¸º`struct`ã€`function`æˆ–`module`ç­‰é¡¹å‘½åçš„æ–¹å¼

### 7.1 Packageå’ŒCrate

crate æ˜¯ Rust åœ¨ç¼–è¯‘æ—¶æœ€å°çš„ä»£ç å•ä½ã€‚å¦‚æœä½ ç”¨ `rustc` è€Œä¸æ˜¯ `cargo` æ¥ç¼–è¯‘ä¸€ä¸ªæ–‡ä»¶ï¼ˆç¬¬ä¸€ç« æˆ‘ä»¬è¿™ä¹ˆåšè¿‡ï¼‰ï¼Œç¼–è¯‘å™¨è¿˜æ˜¯ä¼šå°†é‚£ä¸ªæ–‡ä»¶è®¤ä½œä¸€ä¸ª crateã€‚ crate å¯ä»¥åŒ…å«æ¨¡å—ï¼Œæ¨¡å—å¯ä»¥å®šä¹‰åœ¨å…¶ä»–æ–‡ä»¶ï¼Œç„¶åå’Œ crate ä¸€èµ·ç¼–è¯‘ã€‚

#### 7.1.1 Crate

+ Crateçš„ç±»å‹

  + binary

  + library

+ Crate Root

  + æ˜¯æºä»£ç æ–‡ä»¶

  + Rustç¼–è¯‘å™¨ä»è¿™é‡Œå¼€å§‹ï¼Œç»„æˆä½ çš„Crateçš„æ ¹Module

#### 7.1.2 Package

+ åŒ…å«1ä¸ª`Cargo.toml`ï¼Œå®ƒæè¿°äº†å¦‚ä½•æ„å»ºè¿™äº›Crates
+ åªèƒ½åŒ…å« 0 - 1ä¸ª library crate
+ å¯ä»¥åŒ…å«ä»»æ„æ•°é‡çš„ binary crate
+ ä½†å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ª crate ï¼ˆlibrary æˆ– binaryï¼‰

#### 7.1.3 Cargoçš„æƒ¯ä¾‹

+ src / main.rs
  + binary crate çš„ crate root
  + crate åä¸ package åç›¸åŒ
+ src / lib.rs
  + package åŒ…å«ä¸€ä¸ª library crate
  + library crate çš„ crate root
  + crate åä¸ package åç›¸åŒ
+ Cargo æŠŠ crate root æ–‡ä»¶äº¤ç»™ rustc æ¥æ„å»º library æˆ– binary
+ ä¸€ä¸ª Package å¯ä»¥åŒæ—¶åŒ…å« src / main.rs å’Œ src / lib.rs
  + ä¸€ä¸ª binary crateï¼Œä¸€ä¸ª library crate
  + åç§°ä¸ package åç›¸åŒ
+ ä¸€ä¸ª Package å¯ä»¥æœ‰å¤šä¸ª binary crate
  + æ–‡ä»¶æ”¾åœ¨ src / binä¸‹
  + æ¯ä¸ªæ–‡ä»¶æ˜¯å•ç‹¬çš„ binary crate

#### 7.1.4 Crateçš„ä½œç”¨

+ å°†ç›¸å…³åŠŸèƒ½ç»„åˆåˆ°ä¸€ä¸ªä½œç”¨åŸŸå†…ï¼Œä¾¿äºåœ¨é¡¹ç›®é—´è¿›è¡Œå…±äº«
  + é˜²æ­¢å‘½åå†²çª
+ ä¾‹å¦‚ `rand crate`ï¼Œè®¿é—®å®ƒçš„åŠŸèƒ½éœ€è¦é€šè¿‡å®ƒçš„åå­—ï¼š`rand`



### 7.2 å®šä¹‰moduleæ¥æ§åˆ¶ä½œç”¨åŸŸå’Œç§æœ‰æ€§

#### 7.2.1 Module

+ åœ¨ä¸€ä¸ª crate å†…ï¼Œå°†ä»£ç è¿›è¡Œåˆ†ç»„
+ å¢åŠ å¯è¯»æ€§ï¼Œæ˜“äºå¤ç”¨
+ æ§åˆ¶æ¡ç›®ï¼ˆitemï¼‰ç§æœ‰æ€§ã€‚`public`ã€`private`

#### 7.2.2 å»ºç«‹Module

+ ä½¿ç”¨ `mod`å…³é”®å­—
+ moduleå¯ä»¥åµŒå¥—
+ å¯åŒ…å«å…¶å®ƒé¡¹ï¼ˆstructã€enumã€å¸¸é‡ã€traitã€å‡½æ•°ç­‰ï¼‰çš„å®šä¹‰

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}
        fn serve_order() {}
        fn take_payment() {}
    }
}
```

```rust
crate
 â””â”€â”€ front_of_house
     â”œâ”€â”€ hosting
     â”‚   â”œâ”€â”€ add_to_waitlist
     â”‚   â””â”€â”€ seat_at_table
     â””â”€â”€ serving
         â”œâ”€â”€ take_order
         â”œâ”€â”€ serve_order
         â””â”€â”€ take_payment
```

`src/main.rs` å’Œ `src/lib.rs` å«åš crate rootã€‚ä¹‹æ‰€ä»¥è¿™æ ·å«å®ƒä»¬æ˜¯å› ä¸ºè¿™ä¸¤ä¸ªæ–‡ä»¶çš„å†…å®¹éƒ½åˆ†åˆ«åœ¨ crate æ¨¡å—ç»“æ„çš„æ ¹ç»„æˆäº†ä¸€ä¸ªåä¸º `crate` çš„æ¨¡å—ï¼Œè¯¥ç»“æ„è¢«ç§°ä¸º *æ¨¡å—æ ‘*ï¼ˆ*module tree*ï¼‰



### 7.3 è·¯å¾„ï¼ˆPathï¼‰

ä¸ºäº†åœ¨Rustçš„æ¨¡å—ä¸­æ‰¾åˆ°æŸä¸ªæ¡ç›®ï¼Œéœ€è¦ä½¿ç”¨è·¯å¾„ã€‚è·¯å¾„æœ‰ä¸¤ç§å½¢å¼ï¼š

- **ç»å¯¹è·¯å¾„**ï¼ˆ*absolute path*ï¼‰ä» crate root å¼€å§‹ï¼Œä»¥ crate åæˆ–è€…å­—é¢å€¼ `crate` å¼€å¤´ã€‚
- **ç›¸å¯¹è·¯å¾„**ï¼ˆ*relative path*ï¼‰ä»å½“å‰æ¨¡å—å¼€å§‹ï¼Œä»¥ `self`ã€`super` æˆ–å½“å‰æ¨¡å—çš„æ ‡è¯†ç¬¦å¼€å¤´ã€‚

ç»å¯¹è·¯å¾„å’Œç›¸å¯¹è·¯å¾„éƒ½åè·Ÿä¸€ä¸ªæˆ–å¤šä¸ªç”±åŒå†’å·ï¼ˆ`::`ï¼‰åˆ†å‰²çš„æ ‡è¯†ç¬¦ã€‚

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    
    crate::front_of_house::hosting::add_to_waitlist();

    front_of_house::hosting::add_to_waitlist();
    
}
```

```rust
cr   
   Compiling path_demo v0.1.0 (E:\Files\Learning\BackEnd\Rust\Code\path_demo)
error[E0603]: module `hosting` is private
 --> src\lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --> src\lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --> src\lib.rs:11:21
   |
11 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --> src\lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `path_demo` due to 2 previous errors
```

é”™è¯¯ä¿¡æ¯è¯´ `hosting` æ¨¡å—æ˜¯ç§æœ‰çš„ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬æ‹¥æœ‰ `hosting` æ¨¡å—å’Œ `add_to_waitlist` å‡½æ•°çš„çš„æ­£ç¡®è·¯å¾„ï¼Œä½†æ˜¯ Rust ä¸è®©æˆ‘ä»¬ä½¿ç”¨ï¼Œå› ä¸ºå®ƒä¸èƒ½è®¿é—®ç§æœ‰ç‰‡æ®µã€‚

#### 7.3.1 ç§æœ‰è¾¹ç•Œï¼ˆprivacy boundaryï¼‰

+ æ¨¡å—ä¸ä»…å¯ä»¥ç”¨ç»„ç»‡ä»£ç ï¼Œè¿˜å¯ä»¥å®šä¹‰ç§æœ‰è¾¹ç•Œ
+ å¦‚æœæƒ³æŠŠå‡½æ•°æˆ–`struct`ç­‰è®¾ä¸ºç§æœ‰ï¼Œå¯ä»¥å°†å®ƒæ”¾åˆ°æŸä¸ªæ¨¡å—ä¸­
+ Rustä¸­æ‰€æœ‰çš„æ¡ç›®ï¼ˆå‡½æ•°ã€æ–¹æ³•ã€structã€enumã€æ¨¡å—ã€å¸¸é‡ï¼‰é»˜è®¤æ˜¯ç§æœ‰çš„
+ çˆ¶çº§æ¨¡å—æ— æ³•è®¿é—®å­æ¨¡å—ä¸­çš„ç§æœ‰æ¡ç›®
+ å­æ¨¡å—é‡Œå¯ä»¥ä½¿ç”¨æ‰€æœ‰ç¥–å…ˆæ¨¡å—ä¸­çš„æ¡ç›®
+ å¯ä»¥è°ƒç”¨åŒçº§æ¨¡å—ä¸­çš„ç§æœ‰æ¡ç›®

#### 7.3.2 pubå…³é”®å­—

+ ä½¿ç”¨ `pub`å…³é”®å­—æ¥å°†æŸäº›æ¡ç›®æ ‡è®°ä¸ºå…¬å…±çš„

  ```rust
  mod front_of_house {
      pub mod hosting {
          pub fn add_to_waitlist() {}
      }
  }
  
  pub fn eat_at_restaurant() {
  
      crate::front_of_house::hosting::add_to_waitlist();
  
      front_of_house::hosting::add_to_waitlist();
      
  }
  ```

#### 7.3.3 superå…³é”®å­—

+ superå…³é”®å­—ç”¨æ¥è®¿é—®çˆ¶çº§æ¨¡å—è·¯å¾„ä¸­çš„å†…å®¹ï¼Œç±»ä¼¼æ–‡ä»¶ç³»ç»Ÿä¸­çš„ `..`

  ```rust
  fn serve_order() {}
  
  mod back_of_house {
  
      fn fix_incorrect_order() {
          cook_order();
          super::serve_order();
          crate::serve_order();
      }
  
      fn cook_order() {}
  }
  ```

#### 7.3.4 pub struct

+ å°†`pub`å…³é”®å­—æ”¾åœ¨`struct`å‰

  + `struct`ä¸ºå…¬å…±çš„
  + `struct`çš„å­—æ®µé»˜è®¤æ˜¯ç§æœ‰çš„

+ `struct`çš„å­—æ®µéœ€è¦å•ç‹¬è®¾ç½®`pub`æ¥å˜æˆå…±æœ‰çš„

  ```rust
  mod back_of_house {
      pub struct Breakfast {
          pub toast: String,
          seasonal_fruit: String,
      }
  
      impl Breakfast {
          pub fn summer(toast: &str) -> Breakfast {
              Breakfast {
                  toast: String::from(toast),
                  seasonal_fruit: String::from("peaches"),
              }
          }
      }
  }
  
  pub fn eat_at_restaurant() {
      let mut meal = back_of_house::Breakfast::summer("Rye");
      meal.toast = String::from("Wheat");
      println!("I' d like {} toast please", meal.toast);
      meal.seasonal_fruit = String::from("blueberries"); // æ— æ³•è®¿é—®ç§æœ‰å­—æ®µ
  }
  ```

#### 7.3.5 pub enum

+ å°†`pub`å…³é”®å­—æ”¾åœ¨`enum`å‰

  + `enum`æ˜¯å…¬å…±çš„
  + `enum`çš„å˜ä½“ä¹Ÿéƒ½æ˜¯å…¬å…±çš„

  ```rust
  mod back_of_house {
      pub enum Appetizer {
          Soup,
          Salad,
      }
  }
  ```

  

### 7.4 useå…³é”®å­—

+ `use`å…³é”®å­—å¯ä»¥å°†è·¯å¾„å¯¼å…¥åˆ°ä½œç”¨åŸŸå†…

  + ä»»éµå®ˆç§æœ‰æ€§è§„åˆ™

  ```rust
  mod front_of_house {
      pub mod hosting {
          pub fn add_to_waitlist() {}
          fn some_function() {}
      }
  }
  use crate::front_of_house::hosting;
  
  pub fn eat_at_restaurant() {
      hosting::add_to_waitlist();
      hosting::add_to_waitlist();
      hosting::add_to_waitlist();
      // hosting::some_function();
  }
  ```

+ ä½¿ç”¨`use`æ¥æŒ‡å®šç›¸å¯¹è·¯å¾„

#### 7.4.1 useçš„ä¹ æƒ¯ç”¨æ³•

+ å‡½æ•°ï¼šå°†å‡½æ•°çš„çˆ¶çº§æ¨¡å—å¼•å…¥ä½œç”¨åŸŸï¼ˆæŒ‡å®šåˆ°çˆ¶çº§ï¼‰

+ `struct`ã€`enum`ã€å…¶å®ƒï¼šæŒ‡å®šå®Œæ•´è·¯å¾„ï¼ˆæŒ‡å®šåˆ°æœ¬èº«ï¼‰

+ åŒåæ¡ç›®ï¼šæŒ‡å®šåˆ°çˆ¶çº§

+ å¯ä»¥ä½¿ç”¨ `as`å…³é”®å­—æä¾›æ–°çš„åç§°

  ```rust
  use std::fmt;
  use std::io;
  
  fn f1() -> fmt::Result {}
  
  fn f2() -> io::Result {}
  
  
  
  use std::fmt::Result as fmtResult;
  use std::io::Result as ioResult;
  
  fn f1() -> fmtResult {}
  
  fn f2() -> ioResult {}
  ```

#### 7.4.2 ä½¿ç”¨ pub use é‡æ–°å¯¼å‡ºåç§°

+ ä½¿ç”¨`use`å°†è·¯å¾„ï¼ˆåç§°ï¼‰å¯¼å…¥åˆ°ä½œç”¨åŸŸå†…åï¼Œè¯¥åç§°åœ¨æ­¤ä½œç”¨åŸŸå†…æ˜¯ç§æœ‰çš„

+ `pub use`ï¼šé‡å¯¼å‡º

  + å°†è¯¥æ¡ç›®å¼•å…¥ä½œç”¨åŸŸ
  + è¯¥æ¡ç›®å¯ä»¥è¢«å¤–éƒ¨ä»£ç å¼•å…¥åˆ°å®ƒä»¬çš„ä½œç”¨åŸŸ

  ```rust
  pub use crate::front_of_house::hosting;
  ```

#### 7.4.3 ä½¿ç”¨å¤–éƒ¨åŒ…ï¼ˆpackageï¼‰

+ å¯¼å…¥è¿‡ç¨‹

  1. `Cargo.toml`æ·»åŠ ä¾èµ–çš„åŒ…ï¼ˆpackageï¼‰
     + <a href = "https://crates.io/">https://crates.io/</a> 

  1. ä½¿ç”¨`use`å°†ç‰¹å®šæ¡ç›®å¼•å…¥ä½œç”¨åŸŸ

     ```rust
     Cargo.toml :
     [dependencies]
     rand = "0.8.5"
     
     main.rs : 
     use rand::Rng;
     ```

+ æ ‡å‡†åº“ï¼ˆstdï¼‰ä¹Ÿè¢«å½“åšå¤–éƒ¨åŒ…

  + ä¸éœ€è¦ä¿®æ”¹`Cargo.toml`æ¥åŒ…å«`std`

  + éœ€è¦ä½¿ç”¨`use`å°†`std`ä¸­çš„ç‰¹å®šæ¡ç›®å¼•å…¥å½“å‰ä½œç”¨åŸŸ

    ```rust
    use std::collections::HashMap;
    ```

#### 7.4.4 ä½¿ç”¨åµŒå¥—è·¯å¾„æ¸…ç†å¤§é‡çš„useè¯­å¥

+ å¦‚æœä½¿ç”¨åŒä¸€ä¸ªåŒ…æˆ–æ¨¡å—ä¸‹çš„å¤šä¸ªæ¡ç›®

  ```rust
  use std::cmp::Ordering;
  use std::io;
  ```

+ å¯ä½¿ç”¨åµŒå¥—è·¯å¾„åœ¨åŒä¸€è¡Œå†…å°†ä¸Šè¿°æ¡ç›®è¿›è¡Œå¼•å…¥

  + `è·¯å¾„ç›¸åŒçš„éƒ¨åˆ†::{è·¯å¾„å·®å¼‚çš„éƒ¨åˆ†}`

  ```rust
  use std::cmp::Ordering;
  use std::io;
  use std::{cmp::Ordering, io};
  ```

+ å¦‚æœä¸¤ä¸ª`use`è·¯å¾„ä¹‹ä¸€æ˜¯å¦ä¸€ä¸ªçš„å­è·¯å¾„

  + ä½¿ç”¨`self`

  ```rust
  use std::io;
  use std::io::Write;
  use std::io::{self, Write};
  ```

#### 7.4.5 é€šé…ç¬¦ *

+ ä½¿ç”¨`*`å¯ä»¥æŠŠè·¯å¾„ä¸­æ‰€æœ‰çš„å…¬å…±æ¡ç›®éƒ½å¼•å…¥åˆ°ä½œç”¨åŸŸ

  ```rust
  use std::collections::*;
  ```

  

### 7.5 å°†æ¨¡å—æ‹†åˆ†ä¸ºä¸åŒæ–‡ä»¶

#### 7.5.1 å°†æ¨¡å—å†…å®¹ç§»åŠ¨åˆ°å…¶å®ƒæ–‡ä»¶

+ æ¨¡å—å®šä¹‰æ—¶ï¼Œå¦‚æœæ¨¡å—ååè¾¹æ˜¯`;`ï¼Œè€Œä¸æ˜¯ä»£ç å—
  + Rustä¼šä»ä¸æ¨¡å—åŒåçš„æ–‡ä»¶ä¸­åŠ è½½å†…å®¹
  + æ¨¡å—æ ‘çš„ç»“æ„ä¸ä¼šå‘ç”Ÿå˜åŒ–
  
  ```rust
  pub mod hosting;
  ```
  
  
  
+ éšç€æ¨¡å—é€æ¸å˜å¤§ï¼Œè¯¥æŠ€æœ¯è®©ä½ å¯ä»¥æŠŠæ¨¡å—çš„å†…å®¹ç§»åŠ¨åˆ°å…¶å®ƒæ–‡ä»¶ä¸­



## 8ã€å¸¸ç”¨çš„é›†åˆ

Rust æ ‡å‡†åº“ä¸­åŒ…å«ä¸€ç³»åˆ—è¢«ç§°ä¸º **é›†åˆ**ï¼ˆ*collections*ï¼‰çš„éå¸¸æœ‰ç”¨çš„æ•°æ®ç»“æ„ã€‚å¤§éƒ¨åˆ†å…¶ä»–æ•°æ®ç±»å‹éƒ½ä»£è¡¨ä¸€ä¸ªç‰¹å®šçš„å€¼ï¼Œä¸è¿‡é›†åˆå¯ä»¥åŒ…å«å¤šä¸ªå€¼ã€‚ä¸åŒäºå†…å»ºçš„æ•°ç»„å’Œå…ƒç»„ç±»å‹ï¼Œè¿™äº›é›†åˆæŒ‡å‘çš„æ•°æ®æ˜¯å‚¨å­˜åœ¨å †ä¸Šçš„ï¼Œè¿™æ„å‘³ç€æ•°æ®çš„æ•°é‡ä¸å¿…åœ¨ç¼–è¯‘æ—¶å°±å·²çŸ¥ï¼Œå¹¶ä¸”è¿˜å¯ä»¥éšç€ç¨‹åºçš„è¿è¡Œå¢é•¿æˆ–ç¼©å°ã€‚

- *vector* å…è®¸æˆ‘ä»¬ä¸€ä¸ªæŒ¨ç€ä¸€ä¸ªåœ°å‚¨å­˜ä¸€ç³»åˆ—æ•°é‡å¯å˜çš„å€¼
- **å­—ç¬¦ä¸²**ï¼ˆ*string*ï¼‰æ˜¯å­—ç¬¦çš„é›†åˆã€‚æˆ‘ä»¬ä¹‹å‰è§è¿‡ `String` ç±»å‹ï¼Œä¸è¿‡åœ¨æœ¬ç« æˆ‘ä»¬å°†æ·±å…¥äº†è§£ã€‚
- **å“ˆå¸Œ map**ï¼ˆ*hash map*ï¼‰å…è®¸æˆ‘ä»¬å°†å€¼ä¸ä¸€ä¸ªç‰¹å®šçš„é”®ï¼ˆkeyï¼‰ç›¸å…³è”ã€‚è¿™æ˜¯ä¸€ä¸ªå«åš *map* çš„æ›´é€šç”¨çš„æ•°æ®ç»“æ„çš„ç‰¹å®šå®ç°ã€‚

### 8.1 ä½¿ç”¨Vectorå­˜å‚¨å¤šä¸ªå€¼

+ `Vec<T>`ï¼Œå«åš`Vector`
  + ç”±æ ‡å‡†åº“æä¾›
  + å¯å­˜å‚¨å¤šä¸ªå€¼
  + åªèƒ½å­˜å‚¨ç›¸åŒç±»å‹çš„æ•°æ®
  + å€¼åœ¨å†…å­˜ä¸­è¿ç»­å­˜æ”¾

#### 8.1.1 åˆ›å»ºVector

+ `Vec::new`å‡½æ•°

  ```rust
  let v: Vec<i32> = Vec::new();
  ```

+ ä½¿ç”¨åˆå§‹å€¼åˆ›å»º`Vec<T>`ï¼Œä½¿ç”¨`vec!`å®

  ```rust
  let v = vec![1, 2, 3];
  ```

#### 8.1.2 æ›´æ–°Vector

+ å‘`Vector`æ·»åŠ å…ƒç´ ï¼Œä½¿ç”¨`push`æ–¹æ³•

  ```rust
  let mut v = Vec::new();
  v.push(1);
  v.push(2);
  v.push(3);
  v.push(4);
  ```

#### 8.1.3 åˆ é™¤Vector

+ ä¸ä»»ä½•å…¶å®ƒ`struct`ä¸€æ ·ï¼Œå½“`Vector`ç¦»å¼€ä½œç”¨åŸŸå

  + å®ƒå°±è¢«æ¸…ç†æ‰äº†
  + å®ƒæ‰€æœ‰çš„å…ƒç´ ä¹Ÿè¢«æ¸…ç†æ‰äº†

  ```rust
  {
      let v = vec![1, 2, 3, 4];
  
      // å¤„ç†å˜é‡ v
  } // <- è¿™é‡Œ v ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ
  ```

#### 8.1.4 è¯»å–Vectorçš„å…ƒç´ 

+ ä¸¤ç§æ–¹å¼å¯ä»¥å¼•ç”¨`Vector`é‡Œçš„å€¼

  + ç´¢å¼•
  + `get`æ–¹æ³•

+ ç´¢å¼• vs `get`å¤„ç†è®¿é—®è¶Šç•Œ

  + ç´¢å¼•ï¼španic
  + `get`ï¼šè¿”å›None

  ```rust
  
  let v = vec![1, 2, 3, 4];
  let third: &i32 = &v[2];
  println!("The third element is: {}", third);
  
  match v.get(2) {
      Some(third) => println!("The third element is: {}", third),
      None => println!("There is no third element"),
  }
  ```

#### 8.1.5 æ‰€æœ‰æƒå’Œå€Ÿç”¨è§„åˆ™

+ ä¸èƒ½åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸå†…åŒæ—¶æ‹¥æœ‰å¯å˜å’Œä¸å¯å˜å¼•ç”¨

  ```rust
  let mut v = vec![1, 2, 3, 4, 5];
  let first = &v[0];
  v.push(6);
  println!("The first element is: {}", first);
  ```

  ```rust
  error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
  ```

  ä¸ºä»€ä¹ˆç¬¬ä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨ä¼šå…³å¿ƒ vector ç»“å°¾çš„å˜åŒ–ï¼Ÿä¸èƒ½è¿™ä¹ˆåšçš„åŸå› æ˜¯ç”±äº vector çš„å·¥ä½œæ–¹å¼ï¼šåœ¨ vector çš„ç»“å°¾å¢åŠ æ–°å…ƒç´ æ—¶ï¼Œåœ¨æ²¡æœ‰è¶³å¤Ÿç©ºé—´å°†æ‰€æœ‰å…ƒç´ ä¾æ¬¡ç›¸é‚»å­˜æ”¾çš„æƒ…å†µä¸‹ï¼Œå¯èƒ½ä¼šè¦æ±‚åˆ†é…æ–°å†…å­˜å¹¶å°†è€çš„å…ƒç´ æ‹·è´åˆ°æ–°çš„ç©ºé—´ä¸­ã€‚è¿™æ—¶ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨å°±æŒ‡å‘äº†è¢«é‡Šæ”¾çš„å†…å­˜ã€‚å€Ÿç”¨è§„åˆ™é˜»æ­¢ç¨‹åºé™·å…¥è¿™ç§çŠ¶å†µã€‚

#### 8.1.6 éå†Vectorä¸­çš„å€¼

+ forå¾ªç¯

  ```rust
  let v = vec![1, 2, 3, 4, 5];
  for i in &v {
      println!("{}", i);
  }
  
  let mut v = vec![1, 2, 3, 4, 5];
  for i in &mut v {
      *i += 50;
  }
  for i in &v {
      println!("{}", i);
  }
  ```

#### 8.1.7 ä½¿ç”¨æšä¸¾æ¥å­˜å‚¨å¤šç§æ•°æ®ç±»å‹

+ `Enum`çš„å˜ä½“å¯ä»¥é™„åŠ ä¸åŒç±»å‹çš„æ•°æ®

+ `Enum`çš„å˜ä½“å®šä¹‰åœ¨åŒä¸€ä¸ª`enum`ç±»å‹ä¸‹

  ```rust
  enum SpreadsheetCell {
      Int(i32),
      Float(f64),
      Text(String),
  }
  
  let row = vec![
      SpreadsheetCell::Int(3),
      SpreadsheetCell::Float(11.22),
      SpreadsheetCell::Text(String::from("bule")),
  ];
  ```
  
  Rust åœ¨ç¼–è¯‘æ—¶å°±å¿…é¡»å‡†ç¡®çš„çŸ¥é“ vector ä¸­ç±»å‹çš„åŸå› åœ¨äºå®ƒéœ€è¦çŸ¥é“å‚¨å­˜æ¯ä¸ªå…ƒç´ åˆ°åº•éœ€è¦å¤šå°‘å†…å­˜ã€‚ç¬¬äºŒä¸ªå¥½å¤„æ˜¯å¯ä»¥å‡†ç¡®çš„çŸ¥é“è¿™ä¸ª vector ä¸­å…è®¸ä»€ä¹ˆç±»å‹ã€‚å¦‚æœ Rust å…è®¸ vector å­˜æ”¾ä»»æ„ç±»å‹ï¼Œé‚£ä¹ˆå½“å¯¹ vector å…ƒç´ æ‰§è¡Œæ“ä½œæ—¶ä¸€ä¸ªæˆ–å¤šä¸ªç±»å‹çš„å€¼å°±æœ‰å¯èƒ½ä¼šé€ æˆé”™è¯¯ã€‚ä½¿ç”¨æšä¸¾å¤–åŠ  match æ„å‘³ç€ Rust èƒ½åœ¨ç¼–è¯‘æ—¶å°±ä¿è¯æ€»æ˜¯ä¼šå¤„ç†æ‰€æœ‰å¯èƒ½çš„æƒ…å†µ
  
  

### 8.2 å­—ç¬¦ä¸²

å­—ç¬¦ä¸²æ˜¯æ–°æ™‹ Rustacean ä»¬é€šå¸¸ä¼šè¢«å›°ä½çš„é¢†åŸŸï¼Œè¿™æ˜¯ç”±äºä¸‰æ–¹é¢ç†ç”±çš„ç»“åˆï¼šRust å€¾å‘äºç¡®ä¿æš´éœ²å‡ºå¯èƒ½çš„é”™è¯¯ï¼Œå­—ç¬¦ä¸²æ˜¯æ¯”å¾ˆå¤šç¨‹åºå‘˜æ‰€æƒ³è±¡çš„è¦æ›´ä¸ºå¤æ‚çš„æ•°æ®ç»“æ„ï¼Œä»¥åŠ UTF-8ã€‚æ‰€æœ‰è¿™äº›è¦ç´ ç»“åˆèµ·æ¥å¯¹äºæ¥è‡ªå…¶ä»–è¯­è¨€èƒŒæ™¯çš„ç¨‹åºå‘˜å°±å¯èƒ½æ˜¾å¾—å¾ˆå›°éš¾äº†ã€‚

#### 8.2.1 ä»€ä¹ˆæ˜¯å­—ç¬¦ä¸²

+ ç‰¹ç‚¹

  + `Byte`çš„é›†åˆ

  + æä¾›äº†ä¸€äº›æ–¹æ³•
    + å¯ä»¥å°†`byte`è§£æä¸ºæ–‡æœ¬

+ Rustçš„**æ ¸å¿ƒè¯­è¨€å±‚é¢**ï¼Œåªæœ‰ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹ï¼šå­—ç¬¦ä¸²åˆ‡ç‰‡`str`ï¼ˆæˆ–`&str`ï¼‰

+ å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼šå¯¹å­˜å‚¨åœ¨å…¶å®ƒåœ°æ–¹ï¼ŒUTF-8ç¼–ç çš„å­—ç¬¦ä¸²çš„å¼•ç”¨

  + å­—ç¬¦ä¸²å­—é¢å€¼ï¼šå­˜å‚¨åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œä¹Ÿæ˜¯å­—ç¬¦ä¸²åˆ‡ç‰‡

+ `String`ç±»å‹

  + æ¥è‡ª**æ ‡å‡†åº“**è€Œä¸æ˜¯æ ¸å¿ƒè¯­è¨€
  + å¯å¢é•¿ã€å¯ä¿®æ”¹ã€å¯æ‹¥æœ‰
  + UTF-8ç¼–ç 

+ é€šå¸¸è¯´çš„å­—ç¬¦ä¸²æ˜¯æŒ‡`String`å’Œ`&str`ä¸¤ç§ç±»å‹

  + æ ‡å‡†åº“é‡Œç”¨çš„å¤š
  + UTF-8ç¼–ç 

+ å…¶å®ƒç±»å‹çš„å­—ç¬¦ä¸²ï¼šOsStringã€OsStrã€CStringã€CStr

  + `String` vs `Str`åç¼€ï¼šæ‹¥æœ‰æˆ–å€Ÿç”¨çš„å˜ä½“
  + å¯å­˜å‚¨ä¸åŒç¼–ç çš„æ–‡æœ¬æˆ–åœ¨å†…å­˜ä¸­ä»¥ä¸åŒçš„å½¢å¼å±•ç°

+ Library crateé’ˆå¯¹å­˜å‚¨å­—ç¬¦ä¸²å¯æä¾›æ›´å¤šçš„é€‰é¡¹

#### 8.2.2 åˆ›å»ºä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼ˆStringï¼‰

+ å¾ˆå¤š`Vec<T>`çš„æ“ä½œéƒ½å¯ä»¥ç”¨äº`String`

+ `String::new()`å‡½æ•°

  ```rust
  let mut s = String::new();
  ```

+ ä½¿ç”¨åˆå§‹å€¼æ¥åˆ›å»º`String`

  + `to_string()`æ–¹æ³•ï¼Œå¯ç”¨äºå®ç°äº†`Display trait`çš„ç±»å‹ï¼ŒåŒ…æ‹¬å­—ç¬¦ä¸²å­—é¢å€¼

    ```rust
    let data = "initial contents";
    let s = data.to_string();
    
    let s1 = "initial contents".to_string();
    ```

  + `String::from()`å‡½æ•°ï¼Œä»å­—é¢å€¼åˆ›å»º`String`

    ```rust
    let s2 = String::from("initial contents");
    ```

  + UTF-8

    ```rust
    let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
    let hello = String::from("DobrÃ½ den");
    let hello = String::from("Hello");
    let hello = String::from("×©Ö¸××œ×•Ö¹×");
    let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
    let hello = String::from("ã“ã‚“ã«ã¡ã¯");
    let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
    let hello = String::from("ä½ å¥½");
    let hello = String::from("OlÃ¡");
    let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
    let hello = String::from("Hola");
    ```

#### 8.2.3 æ›´æ–°String

+ `push_str()`æ–¹æ³•ï¼šå¯ä»¥å°†ä¸€ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡é™„åŠ åˆ°`String`

  ```rust
  let mut s = String::from("foo");
  s.push_str("bar");
  println!("{}", s);
  
  let mut s1 = String::from("foo");
  let s2 = "bar";
  s1.push_str(s2);
  println!("s2 is {}", s2);
  ```

+ `push()`æ–¹æ³•ï¼šæŠŠå•ä¸ªå­—ç¬¦é™„åŠ åˆ°`String`

  ```rust
  let mut s = String::from("foo");
  s.push_str("bar");
  s.push('!');
  println!("{}", s);
  ```

+ `+`ï¼šè¿æ¥å­—ç¬¦ä¸²

  + ä½¿ç”¨äº†ç±»ä¼¼è¿™ä¸ªç­¾åçš„æ–¹æ³•`fn add(self, s: &str) -> String {...}`
    + æ ‡å‡†åº“ä¸­çš„`add`æ–¹æ³•ä½¿ç”¨äº†æ³›å‹
    + åªèƒ½æŠŠ`&str`æ·»åŠ åˆ°`String`
    + è§£å¼•ç”¨å¼ºåˆ¶è½¬æ¢ï¼ˆderef coercionï¼‰

  ```rust
  let s1 = String::from("Hello, ");
  let s2 = String::from("world");
  let s3 = s1 + &s2;
  println!("{}", s3);
  println!("{}", s1); // æ³¨æ„ s1 è¢«ç§»åŠ¨äº†ï¼Œä¸èƒ½ç»§ç»­ä½¿ç”¨
  println!("{}", s2);
  ```

+ `format!`ï¼šè¿æ¥å¤šä¸ªå­—ç¬¦ä¸²

  + å’Œ`println!()`ç±»ä¼¼ï¼Œä½†è¿”å›å­—ç¬¦ä¸²
  + ä¸ä¼šè·å¾—å‚æ•°çš„æ‰€æœ‰æƒ

  ```rust
  let s1 = String::from("tic");
  let s2 = String::from("tac");
  let s3 = String::from("toe");
  
  // let s3 = s1 + "-" + &s2 + "-" + &s3;
  // println!("{}", s3);
  
  let s = format!("{}-{}-{}", s1, s2, s3);
  println!("{}", s);
  ```

#### 8.2.4 å¯¹StringæŒ‰ç´¢å¼•çš„å½¢å¼è¿›è¡Œè®¿é—®

+ æŒ‰ç´¢å¼•è¯­æ³•è®¿é—®`String`çš„æŸéƒ¨åˆ†ï¼Œä¼šæŠ¥é”™

  ```rust
  let s1 = String::from("hello");
  let h = s1[0];
  ```

  ```rust
  error[E0277]: the type `String` cannot be indexed by `{integer}`
  ```

  Rustçš„å­—ç¬¦ä¸²æ˜¯ä¸æ”¯æŒç´¢å¼•è¯­æ³•è®¿é—®çš„

+ å†…éƒ¨è¡¨ç¤º

  + `String`æ˜¯å¯¹`Vec<u8>`çš„åŒ…è£…

    + `len()`æ–¹æ³•

    ```rust
    let len = String::from("Hola").len();
    println!("{}", len); // 4
    
    let len = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ").len();
    println!("{}", len); // 24
    
    let hello = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";
    let answer = &hello[0];
    // Ğ—: 208 151
    ```

    å½“ä½¿ç”¨ UTF-8 ç¼–ç æ—¶ï¼Œ`Ğ—` çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ `208`ï¼Œç¬¬äºŒä¸ªæ˜¯ `151`ï¼Œæ‰€ä»¥ `answer` å®é™…ä¸Šåº”è¯¥æ˜¯ `208`ï¼Œä¸è¿‡ `208` è‡ªèº«å¹¶ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å­—æ¯ã€‚è¿”å› `208` å¯ä¸æ˜¯ä¸€ä¸ªè¯·æ±‚å­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªå­—æ¯çš„äººæ‰€å¸Œæœ›çœ‹åˆ°çš„ï¼Œä¸è¿‡å®ƒæ˜¯ Rust åœ¨å­—èŠ‚ç´¢å¼• 0 ä½ç½®æ‰€èƒ½æä¾›çš„å”¯ä¸€æ•°æ®ã€‚ç”¨æˆ·é€šå¸¸ä¸ä¼šæƒ³è¦ä¸€ä¸ªå­—èŠ‚å€¼è¢«è¿”å›ï¼Œå³ä¾¿è¿™ä¸ªå­—ç¬¦ä¸²åªæœ‰æ‹‰ä¸å­—æ¯ï¼š å³ä¾¿ `&"hello"[0]` æ˜¯è¿”å›å­—èŠ‚å€¼çš„æœ‰æ•ˆä»£ç ï¼Œå®ƒä¹Ÿåº”å½“è¿”å› `104` è€Œä¸æ˜¯ `h`ã€‚

    ä¸ºäº†é¿å…è¿”å›æ„å¤–çš„å€¼å¹¶é€ æˆä¸èƒ½ç«‹åˆ»å‘ç°çš„ bugï¼ŒRust æ ¹æœ¬ä¸ä¼šç¼–è¯‘è¿™äº›ä»£ç ï¼Œå¹¶åœ¨å¼€å‘è¿‡ç¨‹ä¸­åŠæ—©æœç»äº†è¯¯ä¼šçš„å‘ç”Ÿã€‚

+ å­—èŠ‚ã€æ ‡é‡å€¼å’Œå­—å½¢ç°‡ï¼ˆBytesã€Scalar Valuesã€Grapheme Clustersï¼‰

  + Rustæœ‰ä¸‰ç§çœ‹å¾…å­—ç¬¦ä¸²çš„æ–¹å¼
    + å­—èŠ‚
    + è¡¨é‡å€¼
    + å­—å½¢ç°‡ï¼ˆæœ€æ¥è¿‘â€œå­—æ¯â€çš„æ¦‚å¿µï¼‰

  ```rust
  let w = "à¤¨à¤®à¤¸à¥à¤¤à¥‡"; // æ¢µæ–‡ä¹¦å†™çš„å°åº¦è¯­å•è¯
  for b in w.bytes() { // å­—èŠ‚
      println!("{}", b);
  }
  
  for b in w.chars() { // æ ‡é‡å€¼
      println!("{}", b);
  }
  
  use unicode_segmentation::UnicodeSegmentation;
  for g in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".graphemes(true) { // å­—å½¢ç°‡
      println!("{}", g);
  }
  ```

+ Rustä¸å…è®¸å¯¹`String`è¿›è¡Œç´¢å¼•çš„æœ€åä¸€ä¸ªåŸå› 

  + ç´¢å¼•æ“ä½œåº”æ¶ˆè€—ä¸€ä¸ªå¸¸é‡æ—¶é—´ (O(1))
  + è€Œ`String`æ— æ³•ä¿è¯ï¼šéœ€è¦éå†æ‰€æœ‰å†…å®¹ï¼Œæ¥ç¡®å®šæœ‰å¤šå°‘ä¸ªåˆæ³•çš„å­—ç¬¦

#### 8.2.5 å­—ç¬¦ä¸²slice

+ å¯ä»¥ä½¿ç”¨`[]`å’Œ**ä¸€ä¸ªèŒƒå›´**æ¥åˆ›å»ºå­—ç¬¦ä¸²çš„åˆ‡ç‰‡

  + å¿…é¡»è°¨æ…ä½¿ç”¨
  + å¦‚æœåˆ‡å‰²æ—¶è·¨è¶Šäº†å­—ç¬¦è¾¹ç•Œï¼Œç¨‹åºå°±ä¼š`panic`

  ```rust
  let hello = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";
  let s = &hello[0..4];
  println!("{}", s); // Ğ—Ğ´
  
  let s1 = &hello[0..3];
  println!("{}", s1); // panic
  // byte index 3 is not a char boundary
  ```

#### 8.2.6 éå†Stringçš„æ–¹æ³•

+ å¯¹äºæ ‡é‡å€¼ï¼š`char()`æ–¹æ³•
+ å¯¹äºå­—èŠ‚ï¼š`byte()`æ–¹æ³•
+ å¯¹äºå­—å½¢ç°‡ï¼šå¾ˆå¤æ‚ï¼Œæ ‡å‡†åº“æœªæä¾›

#### 8.2.7 Stringå¹¶ä¸ç®€å•

+ Rusté€‰æ‹©å°†æ­£ç¡®å¤„ç†`String`æ•°æ®ä½œä¸ºæ‰€æœ‰Rustç¨‹åºçš„é»˜è®¤è¡Œä¸º
  + ç¨‹åºå‘˜å¿…é¡»åœ¨å¤„ç†`UTF-8`æ•°æ®ä¹‹å‰æŠ•å…¥æ›´å¤šçš„ç²¾åŠ›
+ å¯ä»¥é˜²æ­¢åœ¨å¼€å‘åæœŸå¤„ç†æ¶‰åŠé`ASCII`å­—ç¬¦çš„é”™è¯¯



### 8.3 HashMap<K, V>

`HashMap<K, V>` ç±»å‹å‚¨å­˜äº†ä¸€ä¸ªé”®ç±»å‹ `K` å¯¹åº”ä¸€ä¸ªå€¼ç±»å‹ `V` çš„æ˜ å°„ã€‚å®ƒé€šè¿‡ä¸€ä¸ª **å“ˆå¸Œå‡½æ•°**ï¼ˆ*hashing function*ï¼‰æ¥å®ç°æ˜ å°„ï¼Œå†³å®šå¦‚ä½•å°†é”®å’Œå€¼æ”¾å…¥å†…å­˜ä¸­ã€‚

+ é”®å€¼å¯¹çš„å½¢å¼å­˜å‚¨æ•°æ®ï¼Œä¸€ä¸ªé”®ï¼ˆKeyï¼‰å¯¹åº”ä¸€ä¸ªå€¼ï¼ˆValueï¼‰
+ `Hash`å‡½æ•°ï¼šå†³å®šå¦‚ä½•åœ¨å†…å­˜ä¸­å­˜æ”¾`K`å’Œ`V`

#### 8.3.1 åˆ›å»ºHashMap

+ åˆ›å»ºç©º`HashMap`ï¼š`new()`å‡½æ•°

+ æ·»åŠ æ•°æ®ï¼š`insert()`æ–¹æ³•

  ```rust
  use std::collections::HashMap;
  let mut scores = HashMap::new();
  scores.insert(String::from("Blue"), 10);
  scores.insert(String::from("Yellow"), 50);
  
  ```

+ `HashMap`ä½¿ç”¨çš„æ¯”è¾ƒå°‘ï¼Œå› æ­¤ä¸åœ¨`Prelude`ä¸­

+ æ ‡å‡†åº“å¯¹å…¶æ”¯æŒæ¯”è¾ƒå°‘ï¼Œæ²¡æœ‰å†…ç½®çš„å®æ¥åˆ›å»º`HashMap`

+ æ•°æ®å­˜å‚¨åœ¨`heap`ä¸Š

+ åŒæ„çš„ã€‚ä¸€ä¸ª`HashMap`ä¸­ï¼š

  + æ‰€æœ‰çš„`K`å¿…é¡»æ˜¯åŒä¸€ç§ç±»å‹
  + æ‰€æœ‰çš„`V`å¿…é¡»æ˜¯åŒä¸€ç§ç±»å‹

#### 8.3.2 å¦ä¸€ç§åˆ›å»ºHashMapçš„æ–¹å¼ï¼šcollectæ–¹æ³•

+ åœ¨å…ƒç´ ç±»å‹ä¸º`Tuple`çš„`Vector`ä¸Šä½¿ç”¨`collect`æ–¹æ³•ï¼Œå¯ä»¥ç»„å»ºä¸€ä¸ª`HashMap`

  + è¦æ±‚`Tuple`æœ‰ä¸¤ä¸ªå€¼ï¼šä¸€ä¸ªä½œä¸º`K`ï¼Œä¸€ä¸ªä½œä¸º`V`
  + `collect`æ–¹æ³•å¯ä»¥æŠŠæ•°æ®æ•´åˆæˆå¾ˆå¤šç§é›†åˆç±»å‹ï¼ŒåŒ…æ‹¬`HashMap`
    + è¿”å›å€¼éœ€è¦æ˜¾å¼æŒ‡æ˜ç±»å‹

  ```rust
  let teams = vec![String::from("Blue"), String::from("Yellow")];
  let intial_scores = vec![10, 50];
  
  let scores: HashMap<_, _> = teams.iter().zip(intial_scores.iter()).collect();
  
  println!("{:?}", scores); // {"Blue": 10, "Yellow": 50}
  ```

  `zip()`æ¥æ”¶ä¸€ä¸ªå‚æ•°ï¼Œå°†è°ƒç”¨è€…ä¸­çš„å…ƒç´ ä¸å‚æ•°ä¸­çš„å…ƒç´ ä¸€ä¸€å¯¹åº”ç»„æˆ`Tuple`ï¼Œè‹¥æ•°é‡ä¸åŒ¹é…ï¼Œå¤šçš„å…ƒç´ ä¼šè¢«ä¸¢å¼ƒã€‚`collect()`æ–¹æ³•å½¢æˆäº†ä¸€ä¸ª`HashMap`ï¼Œå…ƒç´ é¡ºåºå¹¶ä¸å›ºå®šï¼Œæ¯æ¬¡è¿è¡Œå¯èƒ½éƒ½ä¸ä¸€æ ·ã€‚å½“ç„¶`key -> value`çš„é¡ºåºæ˜¯ç”±`zip`ä¸€ä¸€å¯¹åº”çš„ï¼Œä¸æ˜¯ç”±`collect`å†³å®šçš„

#### 8.3.3 HashMapå’Œæ‰€æœ‰æƒ

+ å¯¹äºå®ç°äº†`Copy trait`çš„ç±»å‹ï¼ˆä¾‹å¦‚ i32ï¼‰ï¼Œå€¼ä¼šè¢«å¤åˆ¶åˆ°`HashMap`ä¸­

+ å¯¹äºæ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼ï¼ˆä¾‹å¦‚ Stringï¼‰ï¼Œå€¼ä¼šè¢«ç§»åŠ¨ï¼Œæ‰€æœ‰æƒä¼šè¢«è½¬ç§»ç»™`HashMap`

  ```rust
  let field_name = String::from("Favorite color");
  let field_valule = String::from("Blue");
  let mut map = HashMap::new();
  map.insert(field_name, field_valule);
  
  println!("{}: {}", field_name, field_valule); // borrow of moved value
  ```

+ å¦‚æœå°†å€¼çš„å¼•ç”¨æ’å…¥åˆ°`HashMap`ï¼Œå€¼æœ¬èº«ä¸ä¼šç§»åŠ¨

  + åœ¨`HashMap`æœ‰æ•ˆçš„æœŸé—´ï¼Œè¢«å¼•ç”¨çš„å€¼å¿…é¡»ä¿è¯æœ‰æ•ˆ

  ```rust
  let field_name = String::from("Favorite color");
  let field_valule = String::from("Blue");
  let mut map = HashMap::new();
  map.insert(&field_name, &field_valule);
  
  println!("{}: {}", field_name, field_valule); // correct
  ```

#### 8.3.4 è®¿é—®HashMapä¸­çš„å€¼

+ `get()`æ–¹æ³•

  + å‚æ•°ï¼š`K`
  + è¿”å›ï¼š`Option<&V>`

  ```rust
  let mut scores = HashMap::new();
  scores.insert(String::from("blue"), 10);
  scores.insert(String::from("Yellow"), 50);
  
  let team_name = String::from("blue");
  let score = scores.get(&team_name);
  
  match score {
      Some(s) => println!("{}", s),
      None => println!("team not exist"),
  }
  ```

#### 8.3.5 éå†HashMap

+ forå¾ªç¯

  ```rust
  let mut scores = HashMap::new();
  scores.insert(String::from("blue"), 10);
  scores.insert(String::from("Yellow"), 50);
  
  for (k, v) in &scores {
      println!("{}: {}", k, v);
  }
  ```

#### 8.3.6 æ›´æ–°HashMap<K, V>

+ `HashMap`å¤§å°å¯å˜

+ æ¯ä¸ª`K`åŒæ—¶åªèƒ½å¯¹åº”ä¸€ä¸ª`V`

+ æ›´æ–°`HashMap`ä¸­çš„æ•°æ®

  + `K`å·²ç»å­˜åœ¨ï¼Œå¯¹åº”ä¸€ä¸ª`V`
    + æ›¿æ¢ç°æœ‰çš„`V`
    + ä¿ç•™ç°æœ‰çš„`V`ï¼Œå¿½ç•¥æ–°çš„`V`
    + åˆå¹¶ç°æœ‰çš„`V`å’Œæ–°çš„`V`
  + `K`ä¸å­˜åœ¨
    + æ·»åŠ ä¸€å¯¹æ–°çš„`K, V`

+ æ›¿æ¢ç°æœ‰çš„`V`

  + å¦‚æœå‘`HashMap`æ’å…¥ä¸€å¯¹`Kã€V`ï¼Œç„¶ååœ¨æ’å…¥ç›¸åŒçš„`K`ï¼Œä½†æ˜¯`V`ä¸åŒï¼Œé‚£ä¹ˆåŸæ¥çš„`V`ä¼šè¢«æ›¿æ¢æ‰

    ```rust
    let mut scores = HashMap::new();
    scores.insert(String::from("blue"), 10);
    scores.insert(String::from("blue"), 20);
    
    println!("{:?}", scores); // {"blue": 20}
    ```

+ åªæœ‰`K`ä¸å¯¹åº”ä»»ä½•å€¼çš„æƒ…å†µä¸‹ï¼Œæ‰æ’å…¥`V`

  + `entry()`æ–¹æ³•ï¼šæ£€æŸ¥æŒ‡å®šçš„`K`æ˜¯å¦å¯¹åº”ä¸€ä¸ª`V`
    + å‚æ•°ä¸º`K`
    + è¿”å›`enum Entry`ï¼šä»£è¡¨å€¼æ˜¯å¦å­˜åœ¨
  + `Entry`çš„`or_insert()`æ–¹æ³•ï¼š
    + å¦‚æœ`K`å­˜åœ¨ï¼Œè¿”å›åˆ°å¯¹åº”çš„`V`çš„ä¸€ä¸ªå¯å˜å¼•ç”¨
    + å¦‚æœ`K`ä¸å­˜åœ¨ï¼Œå°†æ–¹æ³•å‚æ•°ä½œä¸º`K`çš„æ–°å€¼æ’è¿›å»ï¼Œè¿”å›åˆ°è¿™ä¸ªå€¼çš„å¯å˜å¼•ç”¨

  ```rust
  let mut scores = HashMap::new();
  scores.insert(String::from("blue"), 10);
  // scores.entry(String::from("yellow")).or_insert(50);
  let e = scores.entry(String::from("yellow"));
  println!("{:?}", e);
  e.or_insert(50);
  
  scores.entry(String::from("blue")).or_insert(50);
  println!("{:?}", scores);
  ```

+ åŸºäºç°æœ‰çš„`V`æ¥æ›´æ–°`V`

  ```rust
  let text = "hello world wonderful world";
  let mut map = HashMap::new();
  for word in text.split_whitespace() {
      let count = map.entry(word).or_insert(0);
      *count += 1;
  }
  println!("{:#?}", map); 
  // {
  //     "hello": 1,
  //     "world": 2,
  //     "wonderful": 1,
  // }
  ```

#### 8.3.7 Hashå‡½æ•°

+ é»˜è®¤æƒ…å†µä¸‹ï¼Œ`HashMap`ä½¿ç”¨åŠ å¯†åŠŸèƒ½å¼ºå¤§çš„`Hash`å‡½æ•°ï¼Œå¯ä»¥æŠµæŠ—æ‹’ç»æœåŠ¡ï¼ˆDosï¼‰æ”»å‡»
  + ä¸æ˜¯å¯ç”¨çš„æœ€å¿«çš„`Hash`ç®—æ³•
  + ä½†å…·æœ‰æ›´å¥½çš„å®‰å…¨æ€§
+ å¯ä»¥æŒ‡å®šä¸åŒçš„`hasher`æ¥åˆ‡æ¢åˆ°å¦ä¸€ä¸ªå‡½æ•°
  + `hasher`æ˜¯å®ç°äº†`BuildHasher trait`çš„ç±»å‹



## 9ã€é”™è¯¯å¤„ç†

é”™è¯¯æ˜¯è½¯ä»¶ä¸­ä¸å¯å¦è®¤çš„äº‹å®ï¼Œæ‰€ä»¥ Rust æœ‰ä¸€äº›å¤„ç†å‡ºé”™æƒ…å†µçš„ç‰¹æ€§ã€‚åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼ŒRust è¦æ±‚ä½ æ‰¿è®¤é”™è¯¯çš„å¯èƒ½æ€§ï¼Œå¹¶åœ¨ä½ çš„ä»£ç ç¼–è¯‘å‰é‡‡å–ä¸€äº›è¡ŒåŠ¨ã€‚è¿™ä¸€è¦æ±‚ä½¿ä½ çš„ç¨‹åºæ›´åŠ å¥å£®ï¼Œå› ä¸ºå®ƒå¯ä»¥ç¡®ä¿ä½ åœ¨å°†ä»£ç éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒä¹‹å‰å°±èƒ½å‘ç°é”™è¯¯å¹¶è¿›è¡Œé€‚å½“çš„å¤„ç†ã€‚

Rust å°†é”™è¯¯åˆ†ä¸ºä¸¤å¤§ç±»ï¼š**å¯æ¢å¤çš„**ï¼ˆ*recoverable*ï¼‰å’Œ **ä¸å¯æ¢å¤çš„**ï¼ˆ*unrecoverable*ï¼‰é”™è¯¯ã€‚å¯¹äºä¸€ä¸ªå¯æ¢å¤çš„é”™è¯¯ï¼Œæ¯”å¦‚æ–‡ä»¶æœªæ‰¾åˆ°çš„é”™è¯¯ï¼Œæˆ‘ä»¬å¾ˆå¯èƒ½åªæƒ³å‘ç”¨æˆ·æŠ¥å‘Šé—®é¢˜å¹¶é‡è¯•æ“ä½œã€‚ä¸å¯æ¢å¤çš„é”™è¯¯æ€»æ˜¯ bug å‡ºç°çš„å¾å…†ï¼Œæ¯”å¦‚è¯•å›¾è®¿é—®ä¸€ä¸ªè¶…è¿‡æ•°ç»„æœ«ç«¯çš„ä½ç½®ï¼Œå› æ­¤æˆ‘ä»¬è¦ç«‹å³åœæ­¢ç¨‹åºã€‚

å¤§å¤šæ•°è¯­è¨€å¹¶ä¸åŒºåˆ†è¿™ä¸¤ç§é”™è¯¯ï¼Œå¹¶é‡‡ç”¨ç±»ä¼¼å¼‚å¸¸è¿™æ ·æ–¹å¼ç»Ÿä¸€å¤„ç†ä»–ä»¬ã€‚Rust æ²¡æœ‰å¼‚å¸¸ã€‚ç›¸åï¼Œå®ƒæœ‰ `Result<T, E>` ç±»å‹ï¼Œç”¨äºå¤„ç†å¯æ¢å¤çš„é”™è¯¯ï¼Œè¿˜æœ‰ `panic!` å®ï¼Œåœ¨ç¨‹åºé‡åˆ°ä¸å¯æ¢å¤çš„é”™è¯¯æ—¶åœæ­¢æ‰§è¡Œã€‚

+ Rustçš„å¯é æ€§ï¼šé”™è¯¯å¤„ç†
  + å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼šåœ¨ç¼–è¯‘æ—¶æç¤ºé”™è¯¯å¹¶å¤„ç†
+ é”™è¯¯çš„åˆ†ç±»ï¼š
  + å¯æ¢å¤
    + ä¾‹å¦‚æ–‡ä»¶æœªæ‰¾åˆ°ï¼Œå¯å†æ¬¡å°è¯•
  + ä¸å¯æ¢å¤
    + bugï¼Œä¾‹å¦‚è®¿é—®çš„ç´¢å¼•è¶…å‡ºèŒƒå›´
+ Rustæ²¡æœ‰ç±»ä¼¼å¼‚å¸¸çš„æœºåˆ¶
  + å¯æ¢å¤é”™è¯¯ï¼š`Result<T,E>`
  + ä¸å¯æ¢å¤ï¼š`panic!`å®

### 9.1 ç”¨ panic! å¤„ç†ä¸å¯æ¢å¤çš„é”™è¯¯

+ å½“`panic!`å®æ‰§è¡Œï¼š
  + ä½ çš„ç¨‹åºä¼šæ‰“å°ä¸€ä¸ªé”™è¯¯ä¿¡æ¯
  + å±•å¼€ï¼ˆunwindï¼‰ã€æ¸…ç†è°ƒç”¨æ ˆï¼ˆStackï¼‰
  + é€€å‡ºç¨‹åº

> ### å¯¹åº” panic æ—¶çš„æ ˆå±•å¼€æˆ–ç»ˆæ­¢
>
> å½“å‡ºç° panic æ—¶ï¼Œç¨‹åºé»˜è®¤ä¼šå¼€å§‹ **å±•å¼€**ï¼ˆ*unwinding*ï¼‰ï¼Œè¿™æ„å‘³ç€ Rust ä¼šå›æº¯æ ˆå¹¶æ¸…ç†å®ƒé‡åˆ°çš„æ¯ä¸€ä¸ªå‡½æ•°çš„æ•°æ®ï¼Œä¸è¿‡è¿™ä¸ªå›æº¯å¹¶æ¸…ç†çš„è¿‡ç¨‹æœ‰å¾ˆå¤šå·¥ä½œã€‚å¦ä¸€ç§é€‰æ‹©æ˜¯ç›´æ¥ **ç»ˆæ­¢**ï¼ˆ*abort*ï¼‰ï¼Œè¿™ä¼šä¸æ¸…ç†æ•°æ®å°±é€€å‡ºç¨‹åºã€‚é‚£ä¹ˆç¨‹åºæ‰€ä½¿ç”¨çš„å†…å­˜éœ€è¦ç”±æ“ä½œç³»ç»Ÿæ¥æ¸…ç†ã€‚å¦‚æœä½ éœ€è¦é¡¹ç›®çš„æœ€ç»ˆäºŒè¿›åˆ¶æ–‡ä»¶è¶Šå°è¶Šå¥½ï¼Œpanic æ—¶é€šè¿‡åœ¨ *Cargo.toml* çš„ `[profile]` éƒ¨åˆ†å¢åŠ  `panic = 'abort'`ï¼Œå¯ä»¥ç”±å±•å¼€åˆ‡æ¢ä¸ºç»ˆæ­¢ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ æƒ³è¦åœ¨releaseæ¨¡å¼ä¸­ panic æ—¶ç›´æ¥ç»ˆæ­¢ï¼š
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```

+ é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“`panic`å‘ç”Ÿï¼š

  + ç¨‹åºå±•å¼€è°ƒç”¨æ ˆï¼ˆå·¥ä½œé‡å¤§ï¼‰
    + Rustæ²¿ç€è°ƒç”¨æ ˆå¾€å›èµ°
    + æ¸…ç†æ¯ä¸ªé‡åˆ°çš„å‡½æ•°ä¸­çš„æ•°æ®
  + ç«‹å³ç»ˆæ­¢è°ƒç”¨æ ˆ
    + ä¸è¿›è¡Œæ¸…ç†ï¼Œç›´æ¥åœæ­¢ç¨‹åº
    + å†…å­˜éœ€è¦OSè¿›è¡Œæ¸…ç†

+ æƒ³è®©äºŒè¿›åˆ¶æ–‡ä»¶æ›´å°ï¼ŒæŠŠè®¾ç½®ä»â€œå±•å¼€â€æ”¹ä¸ºâ€œç»ˆæ­¢â€

  + åœ¨`Cargo.toml`ä¸­é€‚å½“çš„`profile`éƒ¨åˆ†è®¾ç½®
    + `panic=abort`

  ```rust
  fn main() {
      // panic!("crash and burn");
  
      let v = vec![1, 2, 3];
      v[99];
  }
  ```

+ `panic!`å¯èƒ½å‡ºç°åœ¨ï¼š

  + æˆ‘ä»¬å†™çš„ä»£ç ä¸­
  + æˆ‘ä»¬æ‰€ä¾èµ–çš„ä»£ç ä¸­

+ å¯ä»¥é€šè¿‡è°ƒç”¨`panic!`çš„å‡½æ•°çš„å›æº¯ä¿¡æ¯æ¥å®šä½å¼•èµ·é—®é¢˜çš„ä»£ç 

  + é€šè¿‡è®¾ç½®ç¯å¢ƒå˜é‡`RUST_BACKTRACE`å¯å¾—åˆ°å›æº¯ä¿¡æ¯

  ```rust
  export RUST_BACKTRACE=1 && cr                 [11:11:32]
      Finished dev [unoptimized + debuginfo] target(s) in 0.00s
       Running `target/debug/panic_demo`
  thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:5:5
  stack backtrace:
     0: rust_begin_unwind
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/std/src/panicking.rs:584:5
     1: core::panicking::panic_fmt
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/panicking.rs:142:14
     2: core::panicking::panic_bounds_check
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/panicking.rs:84:5
     3: <usize as core::slice::index::SliceIndex<[T]>>::index
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/slice/index.rs:250:10
     4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/slice/index.rs:18:9
     5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/alloc/src/vec/mod.rs:2628:9
     6: panic_demo::main
               at ./src/main.rs:5:5
     7: core::ops::function::FnOnce::call_once
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/ops/function.rs:248:5
  note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
  ```

  + ä¸ºäº†è·å–å¸¦æœ‰è°ƒè¯•ä¿¡æ¯çš„å›æº¯ï¼Œå¿…é¡»å¯ç”¨è°ƒè¯•ç¬¦å·ï¼ˆä¸å¸¦ `--release`ï¼‰

### 9.2 ç”¨Resultå¤„ç†å¯æ¢å¤çš„é”™è¯¯

> å¤§éƒ¨åˆ†é”™è¯¯å¹¶æ²¡æœ‰ä¸¥é‡åˆ°éœ€è¦ç¨‹åºå®Œå…¨åœæ­¢æ‰§è¡Œã€‚æœ‰æ—¶ï¼Œä¸€ä¸ªå‡½æ•°ä¼šå› ä¸ºä¸€ä¸ªå®¹æ˜“ç†è§£å¹¶åšå‡ºååº”çš„åŸå› å¤±è´¥ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå› ä¸ºæ‰“å¼€ä¸€ä¸ªå¹¶ä¸å­˜åœ¨çš„æ–‡ä»¶è€Œå¤±è´¥ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯èƒ½æƒ³è¦åˆ›å»ºè¿™ä¸ªæ–‡ä»¶ï¼Œè€Œä¸æ˜¯ç»ˆæ­¢è¿›ç¨‹ã€‚

#### 9.2.1 Resultæšä¸¾

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

+ `T`ï¼šæ“ä½œæˆåŠŸæƒ…å†µä¸‹ï¼Œ`Ok`å˜ä½“é‡Œè¿”å›çš„æ•°æ®çš„ç±»å‹

+ `E`ï¼šæ“ä½œå¤±è´¥æƒ…å†µä¸‹ï¼Œ`Err`å˜ä½“é‡Œè¿”å›çš„æ•°æ®çš„ç±»å‹

  ```rust
  let f = File::open("hello.txt");
  ```

#### 9.2.2 å¤„ç†Resultçš„ä¸€ç§æ–¹å¼ï¼šmatchè¡¨è¾¾å¼

+ å’Œ`Option`æšä¸¾ä¸€æ ·ï¼Œ`Result`åŠå…¶å˜ä½“ä¹Ÿæ˜¯ç”±`prelude`å¸¦å…¥ä½œç”¨åŸŸ

  ```rust
  let f = File::open("hello.txt");
  
  let f = match f {
      Ok(file) => file,
      Err(error) => {
          panic!("error opening file: {:?}", error)
      }
  };
  ```

+ åŒ¹é…ä¸åŒçš„é”™è¯¯

  ```rust
  let f = File::open("hello.txt");
  
  let f = match f {
      Ok(file) => file,
      Err(error) => match error.kind() {
          ErrorKind::NotFound => match File::create("hello.txt") {
              Ok(fc) => fc,
              Err(e) => panic!("Error creating file: {:?}", e),
          },
          other_error => panic!("Error opening the file: {:?}", other_error),
      },
  };
  ```

  ä¸Šä¾‹ä¸­ä½¿ç”¨äº†å¾ˆå¤šçš„`match!`ï¼Œ`match` ç¡®å®å¾ˆå¼ºå¤§ï¼Œä¸è¿‡ä¹Ÿéå¸¸çš„åŸºç¡€ã€‚ç¬¬åä¸‰ç« æˆ‘ä»¬ä¼šä»‹ç»é—­åŒ…ï¼ˆclosureï¼‰ï¼Œè¿™å¯ä»¥ç”¨äºå¾ˆå¤š `Result<T, E>` ä¸Šå®šä¹‰çš„æ–¹æ³•ã€‚åœ¨å¤„ç†ä»£ç ä¸­çš„ `Result<T, E>` å€¼æ—¶è¿™äº›æ–¹æ³•å¯èƒ½ä¼šæ›´åŠ ç®€æ´ã€‚

  ```rust
  let f = File::open("hello.txt").unwrap_or_else(|error| {
      if error.kind() == ErrorKind::NotFound {
          File::create("hello.txt").unwrap_or_else(|error| {
              panic!("Error creating file: {:?}", error);
          })
      } else {
          panic!("Error opening file: {:?}", error);
      }
  });
  ```

#### 9.2.3 unwrap

`match` èƒ½å¤Ÿèƒœä»»å®ƒçš„å·¥ä½œï¼Œä¸è¿‡å®ƒå¯èƒ½æœ‰ç‚¹å†—é•¿å¹¶ä¸”ä¸æ€»æ˜¯èƒ½å¾ˆå¥½çš„è¡¨æ˜å…¶æ„å›¾ã€‚`Result<T, E>` ç±»å‹å®šä¹‰äº†å¾ˆå¤šè¾…åŠ©æ–¹æ³•æ¥å¤„ç†å„ç§æƒ…å†µã€‚å…¶ä¸­ä¹‹ä¸€å«åš `unwrap`ï¼Œå®ƒçš„å®ç°å°±ç±»ä¼¼äº `match` è¯­å¥ã€‚å¦‚æœ `Result` å€¼æ˜¯æˆå‘˜ `Ok`ï¼Œ`unwrap` ä¼šè¿”å› `Ok` ä¸­çš„å€¼ã€‚å¦‚æœ `Result` æ˜¯æˆå‘˜ `Err`ï¼Œ`unwrap` ä¼šä¸ºæˆ‘ä»¬è°ƒç”¨ `panic!`ã€‚

+ `unwrap`ç›¸å½“äº`match`è¡¨è¾¾å¼çš„ä¸€ä¸ªå¿«æ·æ–¹æ³•
  + å¦‚æœ`Result`çš„ç»“æœæ˜¯`Ok`ï¼Œåˆ™è¿”å›`Ok`é‡Œé¢çš„å€¼
  + å¦‚æœ`Result`çš„ç»“æœæ˜¯`Err`ï¼Œåˆ™è°ƒç”¨`panic!`å®

  ```rust
    let f = File::open("hello.txt").unwrap();
  ```

#### 9.2.4 expect

+ `expect`å’Œ`unwrap`ç±»ä¼¼ï¼Œä½†æ˜¯å¯ä»¥æŒ‡å®šé”™è¯¯ä¿¡æ¯

    ```rust
    let f = File::open("hello.txt").expect("æ— æ³•æ‰“å¼€æ–‡ä»¶ hello.txt");
    ```


#### 9.2.5 ä¼ æ’­é”™è¯¯

+ åœ¨å‡½æ•°ä¸­å¤„ç†é”™è¯¯

+ å°†é”™è¯¯è¿”å›ç»™è°ƒç”¨è€…

    ```rust
    fn read_username_from_file() -> Result<String, io::Error> {
        let f = File::open("hello.txt");
    
        let mut f = match f {
            Ok(file) => file,
            Err(e) => return Err(e),
        };
    
        let mut s = String::new();
        match f.read_to_string(&mut s) {
            Ok(_) => Ok(s),
            Err(e) => Err(e),
        }
    }
    
    let reuslt = read_username_from_file();
    ```

#### 9.2.6 ? è¿ç®—ç¬¦

+ ä¼ æ’­é”™è¯¯çš„ä¸€ç§å¿«æ·æ–¹å¼

  ```rust
  fn read_username_from_file() -> Result<String, io::Error> {
      let mut f = File::open("hello.txt")?;
      let mut s = String::new();
      f.read_to_string(&mut s)?;
      Ok(s)
  }
  ```

  å¦‚æœ`Result`æ˜¯`Ok`ï¼š`Ok`ä¸­çš„å€¼å°±æ˜¯è¡¨è¾¾å¼çš„ç»“æœï¼Œç„¶åç»§ç»­æ‰§è¡Œç¨‹åºï¼›å¦‚æœ`Result`æ˜¯`Err`ï¼š`Err`å°±æ˜¯æ•´ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œå°±åƒä½¿ç”¨äº†`return`		

+ `?`ä¸`from`å‡½æ•°

  + `Trait std::convert::From`ä¸Šçš„`fromå‡½æ•°`
    + ç”¨äºé”™è¯¯ä¹‹é—´çš„è½¬æ¢
  + è¢«`?`æ‰€åº”ç”¨çš„é”™è¯¯ï¼Œä¼šéšå¼çš„è¢«`from`å‡½æ•°å¤„ç†
    + å½“`?`è°ƒç”¨å‡½æ•°æ—¶ï¼Œå®ƒæ‰€æ¥æ”¶çš„é”™è¯¯ç±»å‹ä¼šè¢«è½¬åŒ–ä¸ºå½“å‰å‡½æ•°è¿”å›ç±»å‹æ‰€å®šä¹‰çš„é”™è¯¯ç±»å‹
  + é’ˆå¯¹ä¸åŒçš„é”™è¯¯åŸå› ï¼Œè¿”å›åŒä¸€ç§é”™è¯¯ç±»å‹
    + åªè¦æ¯ä¸ªé”™è¯¯ç±»å‹å®ç°äº†è½¬æ¢ä¸ºæ‰€è¿”å›çš„é”™è¯¯ç±»å‹çš„`from`å‡½æ•°

+ é“¾å¼è°ƒç”¨

  ```rust
  fn read_username_from_file() -> Result<String, io::Error> {
      let mut s = String::new();
      File::open("hello.txt")?.read_to_string(&mut s)?;
      Ok(s)
  }
  ```

+ `?`è¿ç®—ç¬¦åªèƒ½ç”¨äºè¿”å›`Result`çš„å‡½æ•°

  ```rust
  fn main() {
      let f = File::open("hello.txt")?;
  }
  ```

  å¾ˆæ˜æ˜¾`main()`å‡½æ•°çš„è¿”å›å€¼æ˜¯`()`ï¼Œå› æ­¤å¹¶ä¸èƒ½ä½¿ç”¨`?`è¿ç®—ç¬¦

  ```rust
  error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
  
  fn main() {
      | --------- this function should return `Result` or `Option` to accept `?`
      
  cannot use the `?` operator in a function that returns `()`
  ```

+ `main()`å‡½æ•°çš„è¿”å›ç±»å‹ä¹Ÿå¯ä»¥æ˜¯ï¼š`Result<T, E>`

  ```rust
  fn main() -> Result<(), Box<dyn Error>> {
      let f = File::open("hello.txt")?;
      Ok(())
  }
  ```

  `Box<dyn Error>`æ˜¯`trait`å¯¹è±¡ï¼š

  + ç®€å•ç†è§£ï¼šâ€œä»»ä½•å¯èƒ½çš„é”™è¯¯ç±»å‹â€



### 9.3 ä½•æ—¶ä½¿ç”¨panic!

+ åœ¨å®šä¹‰ä¸€ä¸ªå¯èƒ½å¤±è´¥çš„å‡½æ•°æ—¶ï¼Œä¼˜å…ˆè€ƒè™‘è¿”å›`Result`
+ å¦åˆ™å°±é€‰æ‹©`panic!`

#### 9.3.1 ç¼–å†™ç¤ºä¾‹ã€åŸå‹ä»£ç ã€æµ‹è¯•

+ å¯ä»¥ä½¿ç”¨`panic!`
  + æ¼”ç¤ºæŸäº›æ¦‚å¿µï¼š`unwrap`
  + åŸå‹ä»£ç ï¼š`unwrap`ã€`expect`
  + æµ‹è¯•ï¼š`unwrap`ã€`expect`

#### 9.3.2 å½“æˆ‘ä»¬æ¯”ç¼–è¯‘å™¨çŸ¥é“æ›´å¤šçš„æƒ…å†µ

+ ä½ å¯ä»¥ç¡®å®š`Result`å°±æ˜¯`Ok`ï¼š`unwrap`

  ```rust
  let home: IpAddr = "127.0.0.1".parse().unwrap();
  ```

#### 9.3.3 é”™è¯¯å¤„ç†çš„æŒ‡å¯¼æ€§å»ºè®®

+ å½“ä»£ç æœ€ç»ˆå¯èƒ½å¤„äºæŸåçŠ¶æ€æ—¶ï¼Œæœ€å¥½ä½¿ç”¨`panic!`
+ æŸåçŠ¶æ€ï¼ˆBad stateï¼‰ï¼šæŸäº›å‡è®¾ã€ä¿è¯ã€çº¦å®šæˆ–ä¸å¯å˜æ€§è¢«æ‰“ç ´
  + ä¾‹å¦‚éæ³•çš„å€¼ã€çŸ›ç›¾çš„å€¼æˆ–ç©ºç¼ºçš„å€¼è¢«ä¼ å…¥ä»£ç 
  + ä»¥åŠä¸‹åˆ—ä¸­çš„ä¸€æ¡ï¼š
    + è¿™ç§æŸåçŠ¶æ€å¹¶ä¸æ˜¯é¢„æœŸèƒ½å¤Ÿå¶å°”å‘ç”Ÿçš„äº‹æƒ…
    + åœ¨æ­¤ä¹‹åï¼Œä½ çš„ä»£ç å¦‚æœå¤„äºè¿™ç§æŸåçŠ¶æ€å°±æ— æ³•è¿è¡Œ
    + åœ¨ä½ ä½¿ç”¨çš„ç±»å‹ä¸­æ²¡æœ‰ä¸€ä¸ªå¥½çš„æ–¹æ³•æ¥å°†è¿™äº›ä¿¡æ¯ï¼ˆå¤„äºæŸåçŠ¶æ€ï¼‰è¿›è¡Œç¼–ç 
+ åœºæ™¯å»ºè®®
  + è°ƒç”¨ä½ çš„ä»£ç ï¼Œä¼ å…¥æ— æ„ä¹‰çš„å‚æ•°å€¼ï¼š`panic!`
  + è°ƒç”¨å¤–éƒ¨ä¸å¯æ§ä»£ç ï¼Œè¿”å›éæ³•çŠ¶æ€ï¼Œä½ æ— æ³•ä¿®å¤ï¼š`panic!`
  + å¦‚æœå¤±è´¥æ˜¯å¯é¢„æœŸçš„ï¼š`Result`
  + å½“ä½ çš„ä»£ç å¯¹å€¼è¿›è¡Œæ“ä½œï¼Œé¦–å…ˆåº”è¯¥éªŒè¯è¿™äº›å€¼ï¼š`panic!`

#### 9.3.4 åˆ›å»ºè‡ªå®šä¹‰ç±»å‹è¿›è¡Œæœ‰æ•ˆæ€§éªŒè¯

+ åˆ›å»ºæ–°çš„ç±»å‹ï¼ŒæŠŠéªŒè¯é€»è¾‘æ”¾åœ¨æ„é€ å®ä¾‹çš„å‡½æ•°é‡Œ

  ```rust
  loop {
      // ...
  
      let guess = "32";
      let guess: i32 = match guess.trim().parse() {
          Ok(num) => num,
          Err(_) => continue,
      };
  
      if guess < 1 || guess > 100 {
          println!("The secret number will be between 1 and 100");
          continue;
      }
  
      // ...
  }
  ```

  `if` è¡¨è¾¾å¼æ£€æŸ¥äº†å€¼æ˜¯å¦è¶…å‡ºèŒƒå›´ï¼Œå‘Šè¯‰ç”¨æˆ·å‡ºäº†ä»€ä¹ˆé—®é¢˜ï¼Œå¹¶è°ƒç”¨ `continue` å¼€å§‹ä¸‹ä¸€æ¬¡å¾ªç¯ï¼Œè¯·æ±‚å¦ä¸€ä¸ªçŒœæµ‹ã€‚`if` è¡¨è¾¾å¼ä¹‹åï¼Œå°±å¯ä»¥åœ¨çŸ¥é“ `guess` åœ¨ 1 åˆ° 100 ä¹‹é—´çš„æƒ…å†µä¸‹ä¸ç§˜å¯†æ•°å­—ä½œæ¯”è¾ƒäº†ã€‚

  ç„¶è€Œï¼Œè¿™å¹¶ä¸æ˜¯ä¸€ä¸ªç†æƒ³çš„è§£å†³æ–¹æ¡ˆï¼šå¦‚æœè®©ç¨‹åºä»…ä»…å¤„ç† 1 åˆ° 100 ä¹‹é—´çš„å€¼æ˜¯ä¸€ä¸ªç»å¯¹éœ€è¦æ»¡è¶³çš„è¦æ±‚ï¼Œè€Œä¸”ç¨‹åºä¸­çš„å¾ˆå¤šå‡½æ•°éƒ½æœ‰è¿™æ ·çš„è¦æ±‚ï¼Œåœ¨æ¯ä¸ªå‡½æ•°ä¸­éƒ½æœ‰è¿™æ ·çš„æ£€æŸ¥å°†æ˜¯éå¸¸å†—ä½™çš„ï¼ˆå¹¶å¯èƒ½æ½œåœ¨çš„å½±å“æ€§èƒ½ï¼‰ã€‚

  ```rust
  pub struct Guess {
      value: i32,
  }
  
  impl Guess {
      pub fn new(value: i32) -> Guess {
          if value < 1 || value > 100 {
              panic!("Guess value must be between 1 and 100, got {}", value);
          }
          Guess { value }
      }
  
      pub fn value(&self) -> i32 {
          self.value
      }
  }
  
  loop {
      // ...
  
      let guess = "32";
      let guess: i32 = match guess.trim().parse() {
          Ok(num) => num,
          Err(_) => continue,
      };
  
      let guess = Guess::new(guess);
  
      // ...
  }
  ```

  æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°ç±»å‹æ¥å°†éªŒè¯æ”¾å…¥åˆ›å»ºå…¶å®ä¾‹çš„å‡½æ•°ä¸­ï¼Œè€Œä¸æ˜¯åˆ°å¤„é‡å¤è¿™äº›æ£€æŸ¥ã€‚è¿™æ ·å°±å¯ä»¥å®‰å…¨çš„åœ¨å‡½æ•°ç­¾åä¸­ä½¿ç”¨æ–°ç±»å‹å¹¶ç›¸ä¿¡ä»–ä»¬æ¥æ”¶åˆ°çš„å€¼ã€‚ä¸Šä¾‹ä¸­åˆ›å»ºäº†æ–°çš„ç±»å‹ï¼ŒæŠŠéªŒè¯é€»è¾‘æ”¾åœ¨æ„é€ å®ä¾‹çš„å‡½æ•°é‡Œã€‚å…¶ä¸­`getter`ï¼ˆvalue()ï¼‰ç”¨äºè¿”å›å­—æ®µçš„æ•°æ®ï¼Œè¿™æ ·åšçš„åŸå› æ˜¯`value`å­—æ®µæ˜¯ç§æœ‰çš„ï¼Œå¤–éƒ¨`mod`æ— æ³•ç›´æ¥å¯¹å­—æ®µçš„å€¼è¿›è¡Œä¿®æ”¹ä¸è®¿é—®ï¼Œåªèƒ½é€šè¿‡`new()`æ¥è¿›è¡Œå®ä¾‹åŒ–ï¼Œä»¥é¿å…ç¨‹åºè·³è¿‡æ„é€ æ–¹æ³•çš„å®‰å…¨æ£€æŸ¥ï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯guesså®ä¾‹çš„å€¼éƒ½æ˜¯åˆæ³•çš„ã€‚



## 10ã€æ³›å‹ã€Traitã€ç”Ÿå‘½å‘¨æœŸ

### 10.1 æå–å‡½æ•°æ¥å‡å°‘é‡å¤

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
```

åœ¨ä¸¤ä¸ªä¸åŒçš„æ•°å­—åˆ—è¡¨ä¸­å¯»æ‰¾æœ€å¤§å€¼ã€‚è™½ç„¶ä»£ç èƒ½å¤Ÿæ‰§è¡Œï¼Œä½†æ˜¯é‡å¤çš„ä»£ç æ˜¯å†—ä½™ä¸”å®¹æ˜“å‡ºé”™çš„ï¼Œæ›´æ–°é€»è¾‘æ—¶æˆ‘ä»¬ä¸å¾—ä¸è®°ä½éœ€è¦ä¿®æ”¹å¤šå¤„åœ°æ–¹çš„ä»£ç ã€‚

ä¸ºäº†æ¶ˆé™¤é‡å¤ï¼Œæˆ‘ä»¬è¦åˆ›å»ºä¸€å±‚æŠ½è±¡ï¼Œå®šä¹‰ä¸€ä¸ªå¤„ç†ä»»æ„æ•´å‹åˆ—è¡¨ä½œä¸ºå‚æ•°çš„å‡½æ•°ã€‚è¿™ä¸ªæ–¹æ¡ˆä½¿å¾—ä»£ç æ›´ç®€æ´ï¼Œå¹¶ä¸”è¡¨ç°äº†å¯»æ‰¾ä»»æ„åˆ—è¡¨ä¸­æœ€å¤§å€¼è¿™ä¸€æ¦‚å¿µã€‚

```rust
fn largest(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {}", result);
}
```

å°†å¯»æ‰¾æœ€å¤§å€¼çš„ä»£ç æå–åˆ°äº†ä¸€ä¸ªå«åš `largest` çš„å‡½æ•°ä¸­ã€‚æ¥ç€æˆ‘ä»¬è°ƒç”¨äº†å¯»æ‰¾ä¸¤ä¸ªåˆ—è¡¨ä¸­æœ€å¤§å€¼çš„å‡½æ•°ã€‚

`largest` å‡½æ•°æœ‰ä¸€ä¸ªå‚æ•° `list`ï¼Œå®ƒä»£è¡¨ä¼šä¼ é€’ç»™å‡½æ•°çš„ä»»ä½•å…·ä½“çš„ `i32`å€¼çš„ sliceã€‚å‡½æ•°å®šä¹‰ä¸­çš„ `list` ä»£è¡¨ä»»ä½• `&[i32]`ã€‚å½“è°ƒç”¨ `largest` å‡½æ•°æ—¶ï¼Œå…¶ä»£ç å®é™…ä¸Šè¿è¡Œäºæˆ‘ä»¬ä¼ é€’çš„ç‰¹å®šå€¼ä¸Šã€‚

### 10.2 æ³›å‹ï¼ˆgenericï¼‰

+ æé«˜ä»£ç çš„å¤ç”¨èƒ½åŠ›
  + å¤„ç†é‡å¤ä»£ç çš„é—®é¢˜
+ æ³›å‹æ˜¯å…·ä½“ç±»å‹æˆ–å…¶å®ƒå±æ€§çš„æŠ½è±¡æ›¿ä»£
  + ä½ ç¼–å†™çš„ä»£ç å¹¶ä¸æ˜¯æœ€ç»ˆçš„ä»£ç ï¼Œè€Œæ˜¯ä¸€ç§æ¨¡æ¿ï¼Œé‡Œé¢æœ‰ä¸€äº›â€œå ä½ç¬¦â€
  + ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶ä¼šå°†â€œå ä½ç¬¦â€æ›¿æ¢ä¸ºå…·ä½“çš„ç±»å‹
+ ä¾‹å¦‚ï¼š`fn largest<T>(list: &[T]) -> T {...}`
  + Tï¼ˆtypeï¼‰ï¼šç±»å‹å‚æ•°
    + å¾ˆçŸ­ï¼Œé€šå¸¸æ˜¯ä¸€ä¸ªå­—æ¯
    + CamelCase

#### 10.2.1 å‡½æ•°å®šä¹‰ä¸­ä½¿ç”¨æ³›å‹

+ æ³›å‹å‡½æ•°

  + å‚æ•°ç±»å‹
  + è¿”å›ç±»å‹

  ```rust
  fn largest<T>(list: &[T]) -> &T {
      let mut largest = &list[0];
      for item in list {
          if item > largest {
              largest = item;
          }
      }
      largest
  }
  ```

  ```rust
  error[E0369]: binary operation `>` cannot be applied to type `&T`
   --> src/main.rs:5:17
    |
  5 |         if item > largest {
    |            ---- ^ ------- &T
    |            |
    |            &T
    |
  help: consider restricting type parameter `T`
    |
  1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
    |             ++++++++++++++++++++++
  
  For more information about this error, try `rustc --explain E0369`.
  error: could not compile `chapter10` due to previous error
  ```

  å¸®åŠ©è¯´æ˜ä¸­æåˆ°äº† `std::cmp::PartialOrd`ï¼Œè¿™æ˜¯ä¸€ä¸ª *trait*ã€‚ç®€å•æ¥è¯´ï¼Œè¿™ä¸ªé”™è¯¯è¡¨æ˜ `largest` çš„å‡½æ•°ä½“ä¸èƒ½é€‚ç”¨äº `T` çš„æ‰€æœ‰å¯èƒ½çš„ç±»å‹ã€‚å› ä¸ºåœ¨å‡½æ•°ä½“éœ€è¦æ¯”è¾ƒ `T` ç±»å‹çš„å€¼ï¼Œä¸è¿‡å®ƒåªèƒ½ç”¨äºæˆ‘ä»¬çŸ¥é“å¦‚ä½•æ’åºçš„ç±»å‹ã€‚ä¸ºäº†å¼€å¯æ¯”è¾ƒåŠŸèƒ½ï¼Œæ ‡å‡†åº“ä¸­å®šä¹‰çš„ `std::cmp::PartialOrd` trait å¯ä»¥å®ç°ç±»å‹çš„æ¯”è¾ƒåŠŸèƒ½ã€‚

#### 10.2.2 Structå®šä¹‰ä¸­çš„æ³›å‹ 

```rust
struct Point<T> {
    x: T, 
    y: T,
}

let integer = Point{ x: 5, y: 10 };
let float = Point{ x: 1.0, y: 4.0};


struct Point<T, U> {
    x: T, 
    y: U,
}

let number = Point{ x: 5, y: 1.0 };
```

åœ¨`struct`ä¸­å¯ä»¥ä½¿ç”¨å¤šä¸ªæ³›å‹çš„ç±»å‹å‚æ•°ï¼Œä½†æ˜¯å¦‚æœç±»å‹å‚æ•°è¿‡å¤šï¼Œåˆ™ä»£ç éœ€è¦é‡ç»„ä¸ºå¤šä¸ªæ›´å°çš„å•å…ƒã€‚

#### 10.2.3 Enumå®šä¹‰ä¸­çš„æ³›å‹

+ å¯ä»¥è®©æšä¸¾çš„å˜ä½“æŒæœ‰æ³›å‹æ•°æ®ç±»å‹

  + ä¾‹å¦‚`Option<T>`ï¼Œ`Result<T, E>`

  ```rust
  enum Option<T> {
      Some(T),
      None,
  }
  
  enum Result<T, E> {
      Ok(T),
      Err(E),
  }
  ```

#### 10.2.4 æ–¹æ³•å®šä¹‰ä¸­çš„æ³›å‹

+ ä¸º`struct`æˆ–`enum`å®ç°æ–¹æ³•çš„æ—¶å€™ï¼Œå¯ä»¥åœ¨å®šä¹‰ä½¿ç”¨æ³›å‹

  ```rust
  struct Point<T> {
      x: T,
      y: T,
  }
  
  impl<T> Point<T> {
      fn x(&self) -> &T {
          &self.x
      }
  }
  
  impl Point<i32> {
      fn x(&self) -> &i32 {
          &self.x
      }
  }
  ```

+ æŠŠ`T`æ”¾åœ¨`impl`å…³é”®å­—åï¼Œè¡¨ç¤ºåœ¨ç±»å‹`T`ä¸Šå®ç°æ–¹æ³•

  + ä¾‹å¦‚ï¼š`impl<T> Point<T>`

+ åªé’ˆå¯¹å…·ä½“ç±»å‹å®ç°æ–¹æ³•ï¼ˆå…¶ä½™ç±»å‹æ²¡å®ç°æ–¹æ³•ï¼‰

  + ä¾‹å¦‚ï¼š`impl Point<i32>`

+ `struct`é‡Œçš„æ³›å‹ç±»å‹å‚æ•°å¯ä»¥å’Œæ–¹æ³•çš„æ³›å‹ç±»å‹å‚æ•°ä¸åŒ

  ```rust
  struct Point<X1, Y1> {
      x: X1,
      y: Y1,
  }
  
  impl<X1, Y1> Point<X1, Y1> {
      fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
          Point {
              x: self.x,
              y: other.y,
          }
      }
  }
  
  fn main() {
      let p1 = Point { x: 5, y: 10.4 };
      let p2 = Point { x: "Hello", y: 'c' };
  
      let p3 = p1.mixup(p2);
  
      println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
  }
  ```

#### 10.2.5 æ³›å‹ä»£ç çš„æ€§èƒ½

+ ä½¿ç”¨æ³›å‹çš„ä»£ç å’Œä½¿ç”¨å…·ä½“ç±»å‹çš„ä»£ç è¿è¡Œé€Ÿåº¦æ˜¯ä¸€æ ·çš„

+ å•æ€åŒ–ï¼ˆmonomorphizationï¼‰

  + åœ¨ç¼–è¯‘æ—¶å°†æ³›å‹æ›¿æ¢ä¸ºå…·ä½“ç±»å‹çš„è¿‡ç¨‹

  ```rust
  let integer = Some(5);
  let float = Some(5.0);
  ```

  å½“ Rust ç¼–è¯‘è¿™äº›ä»£ç çš„æ—¶å€™ï¼Œå®ƒä¼šè¿›è¡Œå•æ€åŒ–ã€‚ç¼–è¯‘å™¨ä¼šè¯»å–ä¼ é€’ç»™ `Option<T>` çš„å€¼å¹¶å‘ç°æœ‰ä¸¤ç§ `Option<T>`ï¼šä¸€ä¸ªå¯¹åº” `i32` å¦ä¸€ä¸ªå¯¹åº” `f64`ã€‚ä¸ºæ­¤ï¼Œå®ƒä¼šå°†æ³›å‹å®šä¹‰ `Option<T>` å±•å¼€ä¸ºä¸¤ä¸ªé’ˆå¯¹ `i32` å’Œ `f64` çš„å®šä¹‰ï¼Œæ¥ç€å°†æ³›å‹å®šä¹‰æ›¿æ¢ä¸ºè¿™ä¸¤ä¸ªå…·ä½“çš„å®šä¹‰ã€‚

  ç¼–è¯‘å™¨ç”Ÿæˆçš„å•æ€åŒ–ç‰ˆæœ¬çš„ä»£ç çœ‹èµ·æ¥åƒè¿™æ ·ï¼ˆç¼–è¯‘å™¨ä¼šä½¿ç”¨ä¸åŒäºå¦‚ä¸‹å‡æƒ³çš„åå­—ï¼‰ï¼š

  ```rust
  enum Option_i32 {
      Some(i32),
      None,
  }
  
  enum Option_f64 {
      Some(f64),
      None,
  }
  
  fn main() {
      let integer = Option_i32::Some(5);
      let float = Option_f64::Some(5.0);
  }
  ```

  æ³›å‹ `Option<T>` è¢«ç¼–è¯‘å™¨æ›¿æ¢ä¸ºäº†å…·ä½“çš„å®šä¹‰ã€‚å› ä¸º Rust ä¼šå°†æ¯ç§æƒ…å†µä¸‹çš„æ³›å‹ä»£ç ç¼–è¯‘ä¸ºå…·ä½“ç±»å‹ï¼Œä½¿ç”¨æ³›å‹æ²¡æœ‰è¿è¡Œæ—¶å¼€é”€ã€‚å½“ä»£ç è¿è¡Œæ—¶ï¼Œå®ƒçš„æ‰§è¡Œæ•ˆç‡å°±è·Ÿå¥½åƒæ‰‹å†™æ¯ä¸ªå…·ä½“å®šä¹‰çš„é‡å¤ä»£ç ä¸€æ ·ã€‚è¿™ä¸ªå•æ€åŒ–è¿‡ç¨‹æ­£æ˜¯ Rust æ³›å‹åœ¨è¿è¡Œæ—¶æå…¶é«˜æ•ˆçš„åŸå› ã€‚



### 10.3 Trait

+ `Trait`å‘Šè¯‰Rustç¼–è¯‘å™¨
  + æŸç§ç±»å‹å…·æœ‰å“ªäº›å¹¶ä¸”å¯ä»¥ä¸å…¶å®ƒç±»å‹å…±äº«çš„åŠŸèƒ½
+ æŠ½è±¡çš„å®šä¹‰å…±äº«è¡Œä¸º
+ `Trait bounds`ï¼ˆçº¦æŸï¼‰
  + æ³›å‹ç±»å‹å‚æ•°æŒ‡å®šä¸ºå®ç°äº†ç‰¹å®šè¡Œä¸ºçš„ç±»å‹
+ `trait`ä¸å…¶å®ƒè¯­è¨€çš„æ¥å£ï¼ˆinterfaceï¼‰ç±»ä¼¼ï¼Œä½†æœ‰äº›åŒºåˆ«

#### 10.3.1 å®šä¹‰ä¸€ä¸ªTrait

+ `Trait`çš„å®šä¹‰ï¼šæŠŠæ–¹æ³•ç­¾åæ”¾åœ¨ä¸€èµ·ï¼Œæ¥å®šä¹‰å®ç°æŸç§ç›®çš„æ‰€å¿…éœ€çš„ä¸€ç»„è¡Œä¸º

  + å…³é”®å­—ï¼š`trait`
  + åªæœ‰æ–¹æ³•ç­¾åï¼Œæ²¡æœ‰å…·ä½“å®ç°
  + `trait`å¯ä»¥æœ‰å¤šä¸ªæ–¹æ³•ï¼šæ¯ä¸ªæ–¹æ³•ç­¾åå ä¸€è¡Œï¼Œä»¥`;`ç»“å°¾
  + å®ç°è¯¥`trait`çš„ç±»å‹å¿…é¡»æä¾›å…·ä½“çš„æ–¹æ³•å®ç°

  ```rust
  pub trait Summary {
      fn summarize(&self) -> String;
  }
  ```

#### 10.3.2 ä¸ºç±»å‹å®ç°trait

+ ä¸ä¸ºç±»å‹å®ç°æ–¹æ³•ç±»ä¼¼

+ ä¸åŒä¹‹å¤„

  + `impl Xxxx for Tweet {...}`
  + åœ¨`impl`å—ä¸­ï¼Œéœ€è¦å¯¹`Trait`é‡Œçš„æ–¹æ³•ç­¾åè¿›è¡Œå…·ä½“çš„å®ç°

  ```rust
  pub trait Summary {
      fn summarize(&self) -> String;
  }
  
  pub struct NewsArticle {
      pub headline: String,
      pub location: String,
      pub author: String,
      pub content: String,
  }
  
  impl Summary for NewsArticle {
      fn summarize(&self) -> String {
          format!("{}, by {} ({})", self.headline, self.author, self.location)
      }
  }
  
  pub struct Tweet {
      pub username: String,
      pub content: String,
      pub reply: bool,
      pub retweet: bool,
  }
  
  impl Summary for Tweet {
      fn summarize(&self) -> String {
          format!("{}: {}", self.username, self.content)
      }
  }
  
  
  
  use trait_demo::{Tweet, Summary};
  
  fn main() {
      let tweet = Tweet {
          username: String::from("horse_ebooks"),
          content: String::from("of course, as you probably already konw, people"),
          reply: false,
          retweet: false,
      };
  
      println!("1 new tweet: {}", tweet.summarize())
  }
  ```

#### 10.3.3 å®ç°traitçš„çº¦æŸ

+ å¯ä»¥åœ¨æŸä¸ªç±»å‹ä¸Šå®ç°æŸä¸ª`trait`çš„å‰ææ¡ä»¶æ˜¯
  + è¿™ä¸ªç±»å‹æˆ–è¿™ä¸ª`trait`è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯åœ¨æœ¬åœ°`crate`é‡Œå®šä¹‰çš„
+ æ— æ³•ä¸ºå¤–éƒ¨ç±»å‹æ¥å®ç°å¤–éƒ¨çš„`trait`
  + è¿™ä¸ªé™åˆ¶æ˜¯ç¨‹åºå±æ€§çš„ä¸€éƒ¨åˆ†ï¼Œä¹Ÿå°±æ˜¯**ç›¸å¹²æ€§ï¼ˆ*coherence*ï¼‰**
  + æ›´å…·ä½“åœ°è¯´æ˜¯**å­¤å„¿åŸåˆ™ï¼ˆ*orphan rule*ï¼‰**ï¼šä¹‹æ‰€ä»¥è¿™æ ·å‘½åæ˜¯å› ä¸ºçˆ¶ç±»å‹ä¸å­˜åœ¨
  + æ­¤è§„åˆ™ç¡®ä¿å…¶ä»–äººçš„ä»£ç ä¸èƒ½ç ´åæ‚¨çš„ä»£ç ï¼Œåä¹‹äº¦ç„¶
  + å¦‚æœæ²¡æœ‰è¿™ä¸ªè§„åˆ™ï¼Œä¸¤ä¸ª`crate`å¯ä»¥ä¸ºåŒä¸€ç±»å‹å®ç°åŒä¸€ä¸ª`trait`ï¼ŒRustå°±ä¸çŸ¥é“åº”è¯¥ä½¿ç”¨å“ªä¸ªå®ç°äº†

#### 10.3.4 é»˜è®¤å®ç°

```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}

let article = NewsArticle {
    headline: String::from("Penguins win the Stanley Cup Championship!"),
    location: String::from("Pittsburgh, PA, USA"),
    author: String::from("Iceburgh"),
    content: String::from(
        "The Pittsburgh Penguins once again are the best \
        hockey team in the NHL.",
    ),
};

println!("New article available! {}", article.summarize());


pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}

impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}

let tweet = Tweet {
    username: String::from("horse_ebooks"),
    content: String::from(
        "of course, as you probably already know, people",
    ),
    reply: false,
    retweet: false,
};

println!("1 new tweet: {}", tweet.summarize());
```

é»˜è®¤å®ç°çš„æ–¹æ³•å¯ä»¥è°ƒç”¨`trait`ä¸­å…¶å®ƒçš„æ–¹æ³•ï¼Œå³ä½¿è¿™äº›æ–¹æ³•æ²¡æœ‰é»˜è®¤å®ç°ã€‚ä½†æ˜¯æ— æ³•ä»æ–¹æ³•çš„é‡å†™å®ç°é‡Œé¢è°ƒç”¨é»˜è®¤çš„å®ç°ã€‚

#### 10.3.5 Traitä½œä¸ºå‚æ•°

+ `impl Trait`è¯­æ³•ï¼šé€‚ç”¨äºç®€å•æƒ…å†µ

  ```rust
  pub fn notify(item: impl Summary) {
      println!("Breaking news! {}", item.summarize());
  }
  ```

+ `Trait bound`è¯­æ³•ï¼šå¯ç”¨äºå¤æ‚æƒ…å†µ

  + `impl Trait`è¯­æ³•æ˜¯`Trait bound`çš„è¯­æ³•ç³–

  ```rust
  pub fn notify<T: Summary>(item: T) {
      println!("Breaking news! {}", item.summarize());
  }
  ```

+ ä½¿ç”¨`+`æŒ‡å®šå¤šä¸ª`Trait bound`

  ```rust
  pub fn notify1(item: impl Summary + Display) {
      println!("Breaking news! {}", item.summarize());
  }
  
  
  pub fn notify<T: Summary + Display>(item: T) {
      println!("Breaking news! {}", item.summarize());
  }
  ```

+ `Trait bound`ä½¿ç”¨`where`å­å¥

  + åœ¨æ–¹æ³•ç­¾ååæŒ‡å®šwhereå­å¥

  ```rust
  pub fn notify2<T, U>(a: T, b: U) -> String
  where 
      T: Summary + Display,
      U: Clone + Debug,
  {
      format!("Breaking news! {}", a.summarize())
  }
  ```

#### 10.3.6 å®ç°Traitä½œä¸ºè¿”å›ç±»å‹

+ `impl Trait`è¯­æ³•

  ```rust
  pub fn returns_summarizable() -> impl Summary {
      Tweet {
          username: String::from("horse_ebooks"),
          content: String::from(
              "of course, as you probably already know, people",
          ),
          reply: false,
          retweet: false,
      }
  }
  ```

  `impl Trait`åªèƒ½è¿”å›ç¡®å®šçš„åŒä¸€ç§ç±»å‹ï¼Œè¿”å›å¯èƒ½ä¸åŒç±»å‹çš„ä»£ç ä¼šæŠ¥é”™

  ```rust
  fn returns_summarizable(switch: bool) -> impl Summary {
      if switch {
          NewsArticle {
              headline: String::from(
                  "Penguins win the Stanley Cup Championship!",
              ),
              location: String::from("Pittsburgh, PA, USA"),
              author: String::from("Iceburgh"),
              content: String::from(
                  "The Pittsburgh Penguins once again are the best \
                   hockey team in the NHL.",
              ),
          }
      } else {
          Tweet {
              username: String::from("horse_ebooks"),
              content: String::from(
                  "of course, as you probably already know, people",
              ),
              reply: false,
              retweet: false,
          }
      }
  }
  ```

  è¿™é‡Œå°è¯•è¿”å› `NewsArticle` æˆ– `Tweet`ï¼Œè¿™å°†ä¼šäº§ç”Ÿé”™è¯¯ã€‚

#### 10.3.7 ä½¿ç”¨Trait Boundçš„ä¾‹å­

+ ä¿®å¤`largest`å‡½æ•°

  ```rust
  fn largest<T: PartialOrd>(list: &[T]) -> &T {
      let mut largest = &list[0];
      for item in list {
          if item > largest { // std::cmp::PartialOrd
              largest = item;
          }
      }
      largest
  }
  
  
  fn largest<T: PartialOrd + Clone>(list: &[T]) -> T {
      let mut largest = list[0].clone();
      for item in list.iter() {
          if item > &largest { // std::cmp::PartialOrd
              largest = item.clone();
          }
      }
      largest
  }
  ```

#### 10.3.8 ä½¿ç”¨Trait Boundæœ‰æ¡ä»¶çš„å®ç°æ–¹æ³•

+ åœ¨ä½¿ç”¨æ³›å‹ç±»å‹å‚æ•°çš„`impl`å—ä¸Šä½¿ç”¨`Trait bound`ï¼Œæˆ‘ä»¬å¯ä»¥æœ‰æ¡ä»¶çš„ä¸ºå®ç°äº†ç‰¹å®š`Trait`çš„ç±»å‹æ¥å®ç°æ–¹æ³•

  ```rust
  struct Pair<T> {
      x: T,
      y: T,
  }
  
  impl<T> Pair<T> {
      fn new(x: T, y: T) -> Self {
          Self { x, y }
      }
  }
  
  impl<T: Display + PartialOrd> Pair<T> {
      fn cmp_display(&self) {
          if self.x >= self.y {
              println!("The largest member is x = {}", self.x);
          } else {
              println!("The largest member is y = {}", self.y);
          }
      }
  }
  ```

  ç±»å‹ `Pair<T>` æ€»æ˜¯å®ç°äº† `new` æ–¹æ³•å¹¶è¿”å›ä¸€ä¸ª `Pair<T>` çš„å®ä¾‹ï¼ˆå›å¿†ä¸€ä¸‹ç¬¬äº”ç« çš„ ["å®šä¹‰æ–¹æ³•"](https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#å®šä¹‰æ–¹æ³•) éƒ¨åˆ†ï¼Œ`Self` æ˜¯ä¸€ä¸ª `impl` å—ç±»å‹çš„ç±»å‹åˆ«åï¼ˆtype aliasï¼‰ï¼Œåœ¨è¿™é‡Œæ˜¯ `Pair<T>`ï¼‰ã€‚ä¸è¿‡åœ¨ä¸‹ä¸€ä¸ª `impl` å—ä¸­ï¼Œåªæœ‰é‚£äº›ä¸º `T` ç±»å‹å®ç°äº† `PartialOrd` trait ï¼ˆæ¥å…è®¸æ¯”è¾ƒï¼‰ **å’Œ** `Display` trait ï¼ˆæ¥å¯ç”¨æ‰“å°ï¼‰çš„ `Pair<T>` æ‰ä¼šå®ç° `cmp_display` æ–¹æ³•ã€‚

+ ä¹Ÿå¯ä»¥ä¸ºå®ç°äº†å…¶å®ƒ`Trait`çš„ä»»æ„ç±»å‹æœ‰æ¡ä»¶çš„å®ç°æŸä¸ª`Trait`

+ ä¸ºæ»¡è¶³`Trait Bound`çš„æ‰€æœ‰ç±»å‹ä¸Šå®ç°`Trait`å«åšè¦†ç›–å®ç°ï¼ˆblanket implementationsï¼‰

  ```rust
  impl<T: Display> ToString for T {
      // --snip--
  }
  ```

  æ ‡å‡†åº“ä¸ºä»»ä½•å®ç°äº† `Display` trait çš„ç±»å‹å®ç°äº† `ToString` traitã€‚

  å› ä¸ºæ ‡å‡†åº“æœ‰äº†è¿™äº› blanket implementationï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ä»»ä½•å®ç°äº† `Display` trait çš„ç±»å‹è°ƒç”¨ç”± `ToString` å®šä¹‰çš„ `to_string` æ–¹æ³•ã€‚

  ```rust
  let s = 3.to_string();
  ```



### 10.4 ç”Ÿå‘½å‘¨æœŸ

+ Rustçš„æ¯ä¸ªå¼•ç”¨éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
+ ç”Ÿå‘½å‘¨æœŸï¼šå¼•ç”¨ä¿æŒæœ‰æ•ˆçš„ä½œç”¨åŸŸ
+ å¤§å¤šæ•°æƒ…å†µï¼šç”Ÿå‘½å‘¨æœŸæ˜¯éšå¼çš„ã€å¯è¢«æ¨æ–­çš„
+ å½“å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸå¯èƒ½ä»¥ä¸åŒçš„æ–¹å¼äº’ç›¸å…³è”æ—¶ï¼šæ‰‹åŠ¨æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ

#### 10.4.1 ç”Ÿå‘½å‘¨æœŸ - é¿å…æ‚¬å‚å¼•ç”¨ï¼ˆdangling referenceï¼‰

+ ç”Ÿå‘½å‘¨æœŸçš„ä¸»è¦ç›®æ ‡ï¼šé¿å…æ‚¬å‚å¼•ç”¨ï¼ˆdangling referenceï¼‰

  ```rust
  fn main() {
      {
          let r;
          {
              let x = 5;
              r = &x;
          }
          println!("r: {}", r);
      }
  }
  ```

  ```rust
  |
  |             r = &x;
  |                 ^^ borrowed value does not live long enough
  |         }
  |         - `x` dropped here while still borrowed
  |         println!("r: {}", r);
  |                           - borrow later used here
  ```

+ **å€Ÿç”¨æ£€æŸ¥å™¨**

  + Rustç¼–è¯‘å™¨çš„å€Ÿç”¨æ£€æŸ¥å™¨ï¼šæ¯”è¾ƒä½œç”¨åŸŸæ¥åˆ¤æ–­æ‰€æœ‰çš„å€Ÿç”¨æ˜¯å¦åˆæ³•

  ```rust
  fn main() {
      let r;                // ---------+-- 'a
                            //          |
      {                     //          |
          let x = 5;        // -+-- 'b  |
          r = &x;           //  |       |
      }                     // -+       |
                            //          |
      println!("r: {}", r); //          |
  }     
  ```

  è¿™é‡Œå°† `r` çš„ç”Ÿå‘½å‘¨æœŸæ ‡è®°ä¸º `'a` å¹¶å°† `x` çš„ç”Ÿå‘½å‘¨æœŸæ ‡è®°ä¸º `'b`ã€‚å¦‚ä½ æ‰€è§ï¼Œå†…éƒ¨çš„ `'b` å—è¦æ¯”å¤–éƒ¨çš„ç”Ÿå‘½å‘¨æœŸ `'a` å°å¾—å¤šã€‚åœ¨ç¼–è¯‘æ—¶ï¼ŒRust æ¯”è¾ƒè¿™ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸçš„å¤§å°ï¼Œå¹¶å‘ç° `r` æ‹¥æœ‰ç”Ÿå‘½å‘¨æœŸ `'a`ï¼Œä¸è¿‡å®ƒå¼•ç”¨äº†ä¸€ä¸ªæ‹¥æœ‰ç”Ÿå‘½å‘¨æœŸ `'b` çš„å¯¹è±¡ã€‚ç¨‹åºè¢«æ‹’ç»ç¼–è¯‘ï¼Œå› ä¸ºç”Ÿå‘½å‘¨æœŸ `'b` æ¯”ç”Ÿå‘½å‘¨æœŸ `'a` è¦å°ï¼šè¢«å¼•ç”¨çš„å¯¹è±¡æ¯”å®ƒçš„å¼•ç”¨è€…å­˜åœ¨çš„æ—¶é—´æ›´çŸ­ã€‚

  ```rust
  fn main() {
      let x = 5;            // ----------+-- 'b
                            //           |
      let r = &x;           // --+-- 'a  |
                            //   |       |
      println!("r: {}", r); //   |       |
                            // --+       |
  }                         // ----------+
  ```

  è¿™é‡Œ `x` æ‹¥æœ‰ç”Ÿå‘½å‘¨æœŸ `'b`ï¼Œæ¯” `'a` è¦å¤§ã€‚è¿™å°±æ„å‘³ç€ `r` å¯ä»¥å¼•ç”¨ `x`ï¼šRust çŸ¥é“ `r` ä¸­çš„å¼•ç”¨åœ¨ `x` æœ‰æ•ˆçš„æ—¶å€™ä¹Ÿæ€»æ˜¯æœ‰æ•ˆçš„ã€‚

#### 10.4.2 å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

```rust
let string1 = String::from("abcd");
let string2 = "xyz";

let result = longest(string1.as_str(), string2);
println!("The longest string is {}", result);


fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

```rust
|
|     fn longest(x: &str, y: &str) -> &str {
|                   ----     ----     ^ expected named lifetime parameter
|
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
|
|     fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
|               ++++     ++          ++          ++
```

æç¤ºæ–‡æœ¬æ­ç¤ºäº†è¿”å›å€¼éœ€è¦ä¸€ä¸ªæ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œå› ä¸º Rust å¹¶ä¸çŸ¥é“å°†è¦è¿”å›çš„å¼•ç”¨æ˜¯æŒ‡å‘ `x` æˆ– `y`ã€‚äº‹å®ä¸Šæˆ‘ä»¬ä¹Ÿä¸çŸ¥é“ï¼Œå› ä¸ºå‡½æ•°ä½“ä¸­ `if` å—è¿”å›ä¸€ä¸ª `x` çš„å¼•ç”¨è€Œ `else` å—è¿”å›ä¸€ä¸ª `y` çš„å¼•ç”¨ï¼

å½“æˆ‘ä»¬å®šä¹‰è¿™ä¸ªå‡½æ•°çš„æ—¶å€™ï¼Œå¹¶ä¸çŸ¥é“ä¼ é€’ç»™å‡½æ•°çš„å…·ä½“å€¼ï¼Œæ‰€ä»¥ä¹Ÿä¸çŸ¥é“åˆ°åº•æ˜¯ `if` è¿˜æ˜¯ `else` ä¼šè¢«æ‰§è¡Œã€‚æˆ‘ä»¬ä¹Ÿä¸çŸ¥é“ä¼ å…¥çš„å¼•ç”¨çš„å…·ä½“ç”Ÿå‘½å‘¨æœŸï¼Œæ‰€ä»¥ä¹Ÿå°±ä¸èƒ½åƒä¸Šä¾‹é‚£æ ·é€šè¿‡è§‚å¯Ÿä½œç”¨åŸŸæ¥ç¡®å®šè¿”å›çš„å¼•ç”¨æ˜¯å¦æ€»æ˜¯æœ‰æ•ˆã€‚å€Ÿç”¨æ£€æŸ¥å™¨è‡ªèº«åŒæ ·ä¹Ÿæ— æ³•ç¡®å®šï¼Œå› ä¸ºå®ƒä¸çŸ¥é“ `x` å’Œ `y` çš„ç”Ÿå‘½å‘¨æœŸæ˜¯å¦‚ä½•ä¸è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸç›¸å…³è”çš„ã€‚ä¸ºäº†ä¿®å¤è¿™ä¸ªé”™è¯¯ï¼Œæˆ‘ä»¬å°†å¢åŠ æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°æ¥å®šä¹‰å¼•ç”¨é—´çš„å…³ç³»ä»¥ä¾¿å€Ÿç”¨æ£€æŸ¥å™¨å¯ä»¥è¿›è¡Œåˆ†æã€‚

#### 10.4.3 ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è¯­æ³•

+ ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨å¹¶ä¸ä¼šæ”¹å˜å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸé•¿åº¦
+ å½“æŒ‡å®šäº†æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œå‡½æ•°å¯ä»¥æ¥å—å¸¦æœ‰ä»»ä½•ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
+ ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨ï¼šæè¿°äº†å¤šä¸ªå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸé—´çš„å…³ç³»ï¼Œä½†ä¸å½±å“ç”Ÿå‘½å‘¨æœŸ
+ è¯­æ³•
  + ç”Ÿå‘½å‘¨æœŸå‚æ•°å
    + ä»¥`'`å¼€å¤´
    + é€šå¸¸å…¨å°å†™ä¸”éå¸¸çŸ­
    + è®¸å¤šäººä¹ æƒ¯ä½¿ç”¨`'a`
  + ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„ä½ç½®
    + åœ¨å¼•ç”¨çš„`&`ç¬¦å·å
    + ä½¿ç”¨ç©ºæ ¼å°†æ ‡æ³¨å’Œå¼•ç”¨ç±»å‹åˆ†å¼€
  + ä¾‹
    + `&i32`    // ä¸€ä¸ªå¼•ç”¨
    + `&'a i32`    //å¸¦æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
    + `&'a mut i32`    //å¸¦æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¯å˜å¼•ç”¨
+ å•ä¸ªç”Ÿå‘½å‘¨æœŸæ ‡æ³¨æœ¬èº«æ²¡æœ‰æ„ä¹‰

#### 10.4.4 å‡½æ•°ç­¾åä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨

+ æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°å£°æ˜åœ¨å‡½æ•°åå’Œå‚æ•°åˆ—è¡¨ä¹‹é—´çš„`<>`é‡Œ

  ```rust
  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
      if x.len() > y.len() {
          x
      } else {
          y
      }
  }
  ```

+ ç”Ÿå‘½å‘¨æœŸ`'a`çš„å®é™…ç”Ÿå‘½å‘¨æœŸæ˜¯ï¼šx å’Œ y ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸä¸­è¾ƒå°çš„é‚£ä¸ª

  ```rust
  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
      if x.len() > y.len() {
          x
      } else {
          y
      }
  }
  
  let string1 = String::from("long string is long");
  let result;
  {
      let string2 = String::from("xyz");
      result = longest(string1.as_str(), string2.as_str());
  }
  println!("The longest string is {}", result);
  ```

#### 10.4.5 æ·±å…¥ç†è§£ç”Ÿå‘½å‘¨æœŸ

+ æŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°çš„æ–¹å¼ä¾èµ–äºå‡½æ•°æ‰€åšçš„äº‹æƒ…

  ```rust
  fn longest<'a>(x: &'a str, y: &str) -> &'a str {
      x
  }
  ```

  å¦‚æœå°† `longest` å‡½æ•°çš„å®ç°ä¿®æ”¹ä¸ºæ€»æ˜¯è¿”å›ç¬¬ä¸€ä¸ªå‚æ•°è€Œä¸æ˜¯æœ€é•¿çš„å­—ç¬¦ä¸² sliceï¼Œå°±ä¸éœ€è¦ä¸ºå‚æ•° `y` æŒ‡å®šä¸€ä¸ªç”Ÿå‘½å‘¨æœŸã€‚

+ ä»å‡½æ•°è¿”å›å¼•ç”¨æ—¶ï¼Œè¿”å›ç±»å‹çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°éœ€è¦ä¸å…¶ä¸­ä¸€ä¸ªå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸåŒ¹é…

+ å¦‚æœè¿”å›çš„å¼•ç”¨æ²¡æœ‰æŒ‡å‘ä»»ä½•å‚æ•°ï¼Œé‚£ä¹ˆå®ƒåªèƒ½å¼•ç”¨å‡½æ•°å†…åˆ›å»ºçš„å€¼

  +  è¿™å°±æ˜¯æ‚¬å‚å¼•ç”¨ï¼šè¯¥å€¼åœ¨å‡½æ•°ç»“æŸæ—¶å°±èµ°å‡ºäº†ä½œç”¨åŸŸ

  ```rust
  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
      let result = String::from("abc");
      result.as_str()
  }
  ```

  ```rust
  $ cargo run
     Compiling chapter10 v0.1.0 (file:///projects/chapter10)
  error[E0515]: cannot return reference to local variable `result`
    --> src/main.rs:11:5
     |
  11 |     result.as_str()
     |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function
  
  For more information about this error, try `rustc --explain E0515`.
  error: could not compile `chapter10` due to previous error
  
  ```

  å‡ºç°çš„é—®é¢˜æ˜¯ `result` åœ¨ `longest` å‡½æ•°çš„ç»“å°¾å°†ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«æ¸…ç†ï¼Œè€Œæˆ‘ä»¬å°è¯•ä»å‡½æ•°è¿”å›ä¸€ä¸ª `result` çš„å¼•ç”¨ã€‚æ— æ³•æŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°æ¥æ”¹å˜æ‚¬å‚å¼•ç”¨ï¼Œè€Œä¸” Rust ä¹Ÿä¸å…è®¸æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ‚¬å‚å¼•ç”¨ã€‚åœ¨è¿™ç§æƒ…å†µï¼Œæœ€å¥½çš„è§£å†³æ–¹æ¡ˆæ˜¯è¿”å›ä¸€ä¸ªæœ‰æ‰€æœ‰æƒçš„æ•°æ®ç±»å‹è€Œä¸æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œè¿™æ ·å‡½æ•°è°ƒç”¨è€…å°±éœ€è¦è´Ÿè´£æ¸…ç†è¿™ä¸ªå€¼äº†ã€‚

#### 10.4.6 Structå®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨

+ Structä¸­å¯åŒ…æ‹¬

  + è‡ªæŒæœ‰çš„ç±»å‹
  + å¼•ç”¨ï¼šéœ€è¦åœ¨æ¯ä¸ªå¼•ç”¨ä¸Šæ·»åŠ ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨

  ```rust
  struct ImportantExcerpt<'a> {
      part: &'a str,
  }
  
  let novel = String::from("Call me Ishmael. Some years age ...");
  
  let first_sentence = novel.split('.').next().expect("Could not find a '.'");
  
  let i = ImportantExcerpt {
      part: first_sentence
  };
  ```

#### 10.4.7 ç”Ÿå‘½å‘¨æœŸçš„çœç•¥ï¼ˆLifetime Elisionï¼‰

+ æ¯ä¸ªå¼•ç”¨éƒ½æœ‰ç”Ÿå‘½å‘¨æœŸ

+ éœ€è¦ä¸ºä½¿ç”¨ç”Ÿå‘½å‘¨æœŸçš„å‡½æ•°æˆ–structæŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°

  ```rust
  fn first_word(s: &str) -> &str {
      let bytes = s.as_bytes();
  
      for (i, &item) in bytes.iter().enumerate() {
          if item == b' ' {
              return &s[0..i];
          }
      }
  
      &s[..]
  }
  ```

  è¿™ä¸ªå‡½æ•°æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸæ³¨è§£å´èƒ½ç¼–è¯‘æ˜¯ç”±äºä¸€äº›å†å²åŸå› ï¼šåœ¨æ—©æœŸç‰ˆæœ¬ï¼ˆpre-1.0ï¼‰çš„ Rust ä¸­ï¼Œè¿™çš„ç¡®æ˜¯ä¸èƒ½ç¼–è¯‘çš„ã€‚æ¯ä¸€ä¸ªå¼•ç”¨éƒ½å¿…é¡»æœ‰æ˜ç¡®çš„ç”Ÿå‘½å‘¨æœŸã€‚é‚£æ—¶çš„å‡½æ•°ç­¾åå°†ä¼šå†™æˆè¿™æ ·ï¼š

  ```rust
  fn first_word<'a>(s: &'a str) -> &'a str {
  ```

  åœ¨ç¼–å†™äº†å¾ˆå¤š Rust ä»£ç åï¼ŒRust å›¢é˜Ÿå‘ç°åœ¨ç‰¹å®šæƒ…å†µä¸‹ Rust ç¨‹åºå‘˜ä»¬æ€»æ˜¯é‡å¤åœ°ç¼–å†™ä¸€æ¨¡ä¸€æ ·çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£ã€‚è¿™äº›åœºæ™¯æ˜¯å¯é¢„æµ‹çš„å¹¶ä¸”éµå¾ªå‡ ä¸ªæ˜ç¡®çš„æ¨¡å¼ã€‚æ¥ç€ Rust å›¢é˜Ÿå°±æŠŠè¿™äº›æ¨¡å¼ç¼–ç è¿›äº† Rust ç¼–è¯‘å™¨ä¸­ï¼Œå¦‚æ­¤å€Ÿç”¨æ£€æŸ¥å™¨åœ¨è¿™äº›æƒ…å†µä¸‹å°±èƒ½æ¨æ–­å‡ºç”Ÿå‘½å‘¨æœŸè€Œä¸å†å¼ºåˆ¶ç¨‹åºå‘˜æ˜¾å¼çš„å¢åŠ æ³¨è§£ã€‚

+ **ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼ˆ*lifetime elision rules*ï¼‰**

  + åœ¨Rustå¼•ç”¨åˆ†æä¸­æ‰€ç¼–å…¥çš„æ¨¡å¼ç§°ä¸º**ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™**
    + è¿™äº›è§„åˆ™æ— éœ€å¼€å‘è€…æ¥éµå®ˆ
    + å®ƒä»¬æ˜¯ä¸€äº›ç‰¹æ®Šæƒ…å†µï¼Œç”±ç¼–è¯‘å™¨æ¥è€ƒè™‘
    + å¦‚æœä½ çš„ä»£ç ç¬¦åˆè¿™äº›æƒ…å†µï¼Œé‚£ä¹ˆå°±æ— éœ€æ˜¾å¼æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ
  + ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ä¸ä¼šæä¾›å®Œæ•´çš„æ¨æ–­
    + å¦‚æœåº”ç”¨è§„åˆ™åï¼Œå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä»ç„¶æ¨¡ç³Šä¸æ¸… --> ç¼–è¯‘é”™è¯¯
    + è§£å†³åŠæ³•ï¼šæ·»åŠ ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œè¡¨æ˜å¼•ç”¨é—´çš„ç›¸äº’å…³ç³»

+ **è¾“å…¥ã€è¾“å‡ºç”Ÿå‘½å‘¨æœŸï¼ˆinput / output lifetimesï¼‰**

  + å‡½æ•° / æ–¹æ³•çš„å‚æ•°ï¼šè¾“å…¥ç”Ÿå‘½å‘¨æœŸ
  + å‡½æ•° / æ–¹æ³•çš„è¿”å›å€¼ï¼šè¾“å‡ºç”Ÿå‘½å‘¨æœŸ

+ **ç”Ÿå‘½å‘¨æœŸçœç•¥çš„ä¸‰ä¸ªè§„åˆ™**

  + ç¼–è¯‘å™¨ä½¿ç”¨3ä¸ªè§„åˆ™åœ¨æ²¡æœ‰æ˜¾å¼æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸçš„æƒ…å†µä¸‹ï¼Œæ¥ç¡®å®šå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ

    + è§„åˆ™1åº”ç”¨äºè¾“å…¥ç”Ÿå‘½å‘¨æœŸ
    + è§„åˆ™2ã€3åº”ç”¨äºè¾“å‡ºç”Ÿå‘½å‘¨æœŸ
    + å¦‚æœç¼–è¯‘å™¨åº”ç”¨å®Œ3ä¸ªè§„åˆ™ä¹‹åï¼Œä»ç„¶æœ‰æ— æ³•ç¡®å®šç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨ --> æŠ¥é”™
    + è¿™äº›è§„åˆ™é€‚ç”¨äº`fn`å®šä¹‰å’Œ`impl`å—

  + è§„åˆ™

    + è§„åˆ™1ï¼šæ¯ä¸ªå¼•ç”¨ç±»å‹çš„å‚æ•°éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
    + è§„åˆ™2ï¼šå¦‚æœåªæœ‰1ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¹ˆè¯¥ç”Ÿå‘½å‘¨æœŸè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°
    + è§„åˆ™3ï¼šå¦‚æœæœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä½†å…¶ä¸­ä¸€ä¸ªæ˜¯`&self`æˆ–`&mut self`ï¼ˆæ˜¯æ–¹æ³•ï¼‰ï¼Œé‚£ä¹ˆ`self`çš„ç”Ÿå‘½å‘¨æœŸä¼šè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°

  + ä¾‹å­ï¼šå‡è®¾æˆ‘ä»¬è‡ªå·±å°±æ˜¯ç¼–è¯‘å™¨ã€‚å¹¶åº”ç”¨è¿™äº›è§„åˆ™æ¥è®¡ç®—

    +  `first_word` å‡½æ•°ç­¾åä¸­çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸã€‚å¼€å§‹æ—¶ç­¾åä¸­çš„å¼•ç”¨å¹¶æ²¡æœ‰å…³è”ä»»ä½•ç”Ÿå‘½å‘¨æœŸï¼š

      ```rust
      fn first_word(s: &str) -> &str {
      ```

      æ¥ç€ç¼–è¯‘å™¨åº”ç”¨ç¬¬ä¸€æ¡è§„åˆ™ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸ªå¼•ç”¨å‚æ•°éƒ½æœ‰å…¶è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸã€‚æˆ‘ä»¬åƒå¾€å¸¸ä¸€æ ·ç§°ä¹‹ä¸º `'a`ï¼Œæ‰€ä»¥ç°åœ¨ç­¾åçœ‹èµ·æ¥åƒè¿™æ ·ï¼š

      ```rust
      fn first_word<'a>(s: &'a str) -> &str {
      ```

      å¯¹äºç¬¬äºŒæ¡è§„åˆ™ï¼Œå› ä¸ºè¿™é‡Œæ­£å¥½åªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°æ‰€ä»¥æ˜¯é€‚ç”¨çš„ã€‚ç¬¬äºŒæ¡è§„åˆ™è¡¨æ˜è¾“å…¥å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸå°†è¢«èµ‹äºˆè¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œæ‰€ä»¥ç°åœ¨ç­¾åçœ‹èµ·æ¥åƒè¿™æ ·ï¼š

      ```rust
      fn first_word<'a>(s: &'a str) -> &'a str {
      ```

      ç°åœ¨è¿™ä¸ªå‡½æ•°ç­¾åä¸­çš„æ‰€æœ‰å¼•ç”¨éƒ½æœ‰äº†ç”Ÿå‘½å‘¨æœŸï¼Œå¦‚æ­¤ç¼–è¯‘å™¨å¯ä»¥ç»§ç»­å®ƒçš„åˆ†æè€Œæ— é¡»ç¨‹åºå‘˜æ ‡è®°è¿™ä¸ªå‡½æ•°ç­¾åä¸­çš„ç”Ÿå‘½å‘¨æœŸã€‚

    + è¿™æ¬¡ä»æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„`longest`å‡½æ•°å¼€å§‹

      ```rust
      fn longest(x: &str, y: &str) -> &str {
      ```

      å†æ¬¡å‡è®¾æˆ‘ä»¬è‡ªå·±å°±æ˜¯ç¼–è¯‘å™¨å¹¶åº”ç”¨ç¬¬ä¸€æ¡è§„åˆ™ï¼šæ¯ä¸ªå¼•ç”¨å‚æ•°éƒ½æœ‰å…¶è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸã€‚è¿™æ¬¡æœ‰ä¸¤ä¸ªå‚æ•°ï¼Œæ‰€ä»¥å°±æœ‰ä¸¤ä¸ªï¼ˆä¸åŒçš„ï¼‰ç”Ÿå‘½å‘¨æœŸï¼š

      ```rust
      fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
      ```

      å†æ¥åº”ç”¨ç¬¬äºŒæ¡è§„åˆ™ï¼Œå› ä¸ºå‡½æ•°å­˜åœ¨å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œå®ƒå¹¶ä¸é€‚ç”¨äºè¿™ç§æƒ…å†µã€‚å†æ¥çœ‹ç¬¬ä¸‰æ¡è§„åˆ™ï¼Œå®ƒåŒæ ·ä¹Ÿä¸é€‚ç”¨ï¼Œè¿™æ˜¯å› ä¸ºæ²¡æœ‰ `self` å‚æ•°ã€‚åº”ç”¨äº†ä¸‰ä¸ªè§„åˆ™ä¹‹åç¼–è¯‘å™¨è¿˜æ²¡æœ‰è®¡ç®—å‡ºè¿”å›å€¼ç±»å‹çš„ç”Ÿå‘½å‘¨æœŸã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨ç¼–è¯‘ä»£ç æ—¶ä¼šå‡ºç°é”™è¯¯çš„åŸå› ï¼šç¼–è¯‘å™¨ä½¿ç”¨æ‰€æœ‰å·²çŸ¥çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼Œä»ä¸èƒ½è®¡ç®—å‡ºç­¾åä¸­æ‰€æœ‰å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸã€‚

      å› ä¸ºç¬¬ä¸‰æ¡è§„åˆ™çœŸæ­£èƒ½å¤Ÿé€‚ç”¨çš„å°±åªæœ‰æ–¹æ³•ç­¾åï¼Œç°åœ¨å°±è®©æˆ‘ä»¬çœ‹çœ‹é‚£ç§æƒ…å†µä¸­çš„ç”Ÿå‘½å‘¨æœŸï¼Œå¹¶çœ‹çœ‹ä¸ºä»€ä¹ˆè¿™æ¡è§„åˆ™æ„å‘³ç€æˆ‘ä»¬ç»å¸¸ä¸éœ€è¦åœ¨æ–¹æ³•ç­¾åä¸­æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸã€‚

#### 10.4.8 æ–¹æ³•å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨

+ åœ¨`struct`ä¸Šä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå®ç°æ–¹æ³•ï¼Œè¯­æ³•å’Œæ³›å‹å‚æ•°çš„è¯­æ³•ä¸€æ ·

+ åœ¨å“ªå£°æ˜å’Œä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä¾èµ–äº

  + ç”Ÿå‘½å‘¨æœŸå‚æ•°æ˜¯å¦å’Œå­—æ®µã€æ–¹æ³•çš„å‚æ•°æˆ–è¿”å›å€¼æœ‰å…³

+ `struct`å­—æ®µçš„ç”Ÿå‘½å‘¨æœŸå

  + åœ¨`impl`åå£°æ˜
  + åœ¨`struct`ååä½¿ç”¨
  + è¿™äº›ç”Ÿå‘½å‘¨æœŸæ˜¯`struct`ç±»å‹çš„ä¸€éƒ¨åˆ†

+ `impl`å—å†…çš„æ–¹æ³•ç­¾åä¸­

  + å¼•ç”¨å¯èƒ½ç»‘å®šäº`struct`å­—æ®µå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¹Ÿå¯èƒ½æ˜¯ç‹¬ç«‹çš„
  + ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ç»å¸¸ä½¿å¾—æ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¸æ˜¯å¿…é¡»çš„

  ```rust
  struct ImportantExcerpt<'a> {
      part: &'a str,
  }
  
  impl<'a> ImportantExcerpt<'a> {
      fn level(&self) -> i32 {
          3
      }
  }
  
  impl<'a> ImportantExcerpt<'a> {
      fn announce_and_return_part(&self, announcement: &str) -> &str {
          println!("Attention please: {}", announcement);
          self.part
      }
  }
  ```

  é¦–å…ˆï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªæ–¹æ³• `level`ã€‚å…¶å”¯ä¸€çš„å‚æ•°æ˜¯ `self` çš„å¼•ç”¨ï¼Œè€Œä¸”è¿”å›å€¼åªæ˜¯ä¸€ä¸ª `i32`ï¼Œå¹¶ä¸å¼•ç”¨ä»»ä½•å€¼ã€‚

  `impl` ä¹‹åå’Œç±»å‹åç§°ä¹‹åçš„ç”Ÿå‘½å‘¨æœŸå‚æ•°æ˜¯å¿…è¦çš„ï¼Œä¸è¿‡å› ä¸ºç¬¬ä¸€æ¡ç”Ÿå‘½å‘¨æœŸè§„åˆ™æˆ‘ä»¬å¹¶ä¸å¿…é¡»æ ‡æ³¨ `self` å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸã€‚è€Œ`announce_and_return_part`æœ‰ä¸¤ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œæ‰€ä»¥ Rust åº”ç”¨ç¬¬ä¸€æ¡ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™å¹¶ç»™äºˆ `&self` å’Œ `announcement` ä»–ä»¬å„è‡ªçš„ç”Ÿå‘½å‘¨æœŸã€‚æ¥ç€ï¼Œå› ä¸ºå…¶ä¸­ä¸€ä¸ªå‚æ•°æ˜¯ `&self`ï¼Œè¿”å›å€¼ç±»å‹è¢«èµ‹äºˆäº† `&self` çš„ç”Ÿå‘½å‘¨æœŸï¼Œè¿™æ ·æ‰€æœ‰çš„ç”Ÿå‘½å‘¨æœŸéƒ½è¢«è®¡ç®—å‡ºæ¥äº†ã€‚

#### 10.4.9 é™æ€ç”Ÿå‘½å‘¨æœŸ

+ `static`æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ç”Ÿå‘½å‘¨æœŸï¼šæ•´ä¸ªç¨‹åºçš„æŒç»­æ—¶é—´
  + ä¾‹å¦‚ï¼šæ‰€æœ‰çš„å­—ç¬¦ä¸²å­—é¢å€¼éƒ½æ‹¥æœ‰`static`ç”Ÿå‘½å‘¨æœŸï¼ˆå› ä¸ºå®ƒè¢«ç›´æ¥å­˜å‚¨åœ¨ç¨‹åºçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œè€Œè¿™ä¸ªæ–‡ä»¶æ€»æ˜¯å¯ç”¨çš„ï¼‰
    + `let s: &'static str = "I have a static lifetime.";`
+ ä¸ºå¼•ç”¨æŒ‡å®š`static`ç”Ÿå‘½å‘¨æœŸå‰è¦ä¸‰æ€
  + æ˜¯å¦éœ€è¦å¼•ç”¨åœ¨ç¨‹åºæ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…éƒ½å­˜æ´»

#### 10.4.10 ç»“åˆæ³›å‹ç±»å‹å‚æ•°ã€trait boundså’Œç”Ÿå‘½å‘¨æœŸ

```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

è¿™ä¸ªæ˜¯ä¹‹å‰ç¤ºä¾‹ä¸­è¿”å›ä¸¤ä¸ªå­—ç¬¦ä¸² slice ä¸­è¾ƒé•¿è€…çš„ `longest` å‡½æ•°ï¼Œä¸è¿‡å¸¦æœ‰ä¸€ä¸ªé¢å¤–çš„å‚æ•° `ann`ã€‚`ann` çš„ç±»å‹æ˜¯æ³›å‹ `T`ï¼Œå®ƒå¯ä»¥è¢«æ”¾å…¥ä»»ä½•å®ç°äº† `where` ä»å¥ä¸­æŒ‡å®šçš„ `Display` trait çš„ç±»å‹ã€‚è¿™ä¸ªé¢å¤–çš„å‚æ•°ä¼šä½¿ç”¨ `{}` æ‰“å°ï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆ `Display` trait bound æ˜¯å¿…é¡»çš„ã€‚å› ä¸ºç”Ÿå‘½å‘¨æœŸä¹Ÿæ˜¯æ³›å‹ï¼Œæ‰€ä»¥ç”Ÿå‘½å‘¨æœŸå‚æ•° `'a` å’Œæ³›å‹ç±»å‹å‚æ•° `T` éƒ½ä½äºå‡½æ•°ååçš„åŒä¸€å°–æ‹¬å·åˆ—è¡¨ä¸­ã€‚



## 11ã€ç¼–å†™è‡ªåŠ¨åŒ–æµ‹è¯•

+ æµ‹è¯•
  + å‡½æ•°
  + éªŒè¯éæµ‹è¯•ä»£ç çš„åŠŸèƒ½æ˜¯å¦å’Œé¢„æœŸä¸€è‡´
+ æµ‹è¯•å‡½æ•°ä½“ï¼ˆé€šå¸¸ï¼‰æ‰§è¡Œçš„3ä¸ªæ“ä½œ
  + å‡†å¤‡ï¼ˆArrangeï¼‰æ•°æ® / çŠ¶æ€
  + è¿è¡Œï¼ˆActï¼‰è¢«æµ‹è¯•çš„ä»£ç 
  + æ–­è¨€ï¼ˆAssertï¼‰ç»“æœ

### 11.1 å¦‚ä½•ç¼–å†™æµ‹è¯•

#### 11.1.1 è§£å‰–æµ‹è¯•å‡½æ•°

+ æµ‹è¯•å‡½æ•°éœ€è¦ä½¿ç”¨`test`å±æ€§ï¼ˆattributeï¼‰è¿›è¡Œæ ‡æ³¨

  + `Attribute`å°±æ˜¯ä¸€æ®µRustä»£ç çš„å…ƒæ•°æ®
  + åœ¨å‡½æ•°ä¸ŠåŠ `#[test]`ï¼Œå¯æŠŠå‡½æ•°å˜æˆæµ‹è¯•å‡½æ•°

+ ä½¿ç”¨`cargo test`å‘½ä»¤è¿è¡Œæ‰€æœ‰æµ‹è¯•å‡½æ•°

  + Rustä¼šæ„å»ºä¸€ä¸ª`Test Runner`å¯æ‰§è¡Œæ–‡ä»¶
    + å®ƒä¼šè¿è¡Œæ ‡æ³¨äº†`test`çš„å‡½æ•°ï¼Œå¹¶æŠ¥å‘Šå…¶è¿è¡Œæ˜¯å¦æˆåŠŸ

+ å½“ä½¿ç”¨`cargo`åˆ›å»º`library`é¡¹ç›®çš„æ—¶å€™ï¼Œä¼šç”Ÿæˆä¸€ä¸ª`test module`ï¼Œé‡Œé¢æœ‰ä¸€ä¸ª`test`å‡½æ•°

  + ä½ å¯ä»¥æ·»åŠ ä»»æ„æ•°é‡çš„`test module`æˆ–å‡½æ•°

  ```rust
  pub fn add(left: usize, right: usize) -> usize {
      left + right
  }
  
  #[cfg(test)]
  mod tests {
      use super::*;
  
      #[test]
      fn it_works() {
          let result = add(2, 2);
          assert_eq!(result, 4);
      }
  }
  ```

  ```rust
  âœ  test_demo_lib git:(main) âœ— ct   
     Compiling test_demo_lib v0.1.0 (/home/urain/learning/BackEnd/Rust/Code/test_demo_lib)
      Finished test [unoptimized + debuginfo] target(s) in 0.45s
       Running unittests src/lib.rs (target/debug/deps/test_demo_lib-8ab6a173bdd46810)
  
  running 1 test
  test tests::it_works ... ok
  
  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
  
     Doc-tests test_demo_lib
  
  running 0 tests
  
  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
  ```

+ æµ‹è¯•å¤±è´¥

  + æµ‹è¯•å‡½æ•°`panic`å°±è¡¨ç¤ºå¤±è´¥
  + æ¯ä¸ªæµ‹è¯•éƒ½è¿è¡Œåœ¨ä¸€ä¸ªæ–°çº¿ç¨‹ä¸­
  + å½“ä¸»çº¿ç¨‹è§‚å¯Ÿåˆ°æŸä¸ªæµ‹è¯•çº¿ç¨‹æŒ‚æ‰äº†ï¼Œé‚£ä¸ªæµ‹è¯•å°±ä¼šè¢«æ ‡è®°ä¸ºå¤±è´¥

  ```rust
  pub fn add(left: usize, right: usize) -> usize {
      left + right
  }
  
  #[cfg(test)]
  mod tests {
      use super::*;
  
      #[test]
      fn it_works() {
          let result = add(2, 2);
          assert_eq!(result, 4);
      }
  
      #[test]
      fn another() {
          panic!("Make this test fail");
      }
  
  }
  ```

  ```rust
  test_demo_lib git:(main) âœ— ct
     Compiling test_demo_lib v0.1.0 (/home/urain/learning/BackEnd/Rust/Code/test_demo_lib)
      Finished test [unoptimized + debuginfo] target(s) in 0.44s
       Running unittests src/lib.rs (target/debug/deps/test_demo_lib-8ab6a173bdd46810)
  
  running 2 tests
  test tests::it_works ... ok
  test tests::another ... FAILED
  
  failures:
  
  ---- tests::another stdout ----
  thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:25:9
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
  
  
  failures:
      tests::another
  
  test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
  
  error: test failed, to rerun pass `--lib`
  ```

#### 11.1.2 æ–­è¨€ï¼ˆAssertï¼‰

+ ä½¿ç”¨ assert! å®æ£€æŸ¥æµ‹è¯•ç»“æœ

  + `assert!`å®ï¼Œæ¥è‡ªæ ‡å‡†åº“ï¼Œç”¨æ¥ç¡®å®šæŸä¸ªçŠ¶æ€æ˜¯å¦ä¸º`true`

    + `true`ï¼šæµ‹è¯•é€šè¿‡
    + `false`ï¼šè°ƒç”¨`panic!`ï¼Œæµ‹è¯•å¤±è´¥

    ```rust
    #[derive(Debug)]
    struct Rectangle {
        width: u32,
        height: u32,
    }
    
    impl Rectangle {
        fn can_hold(&self, other: &Rectangle) -> bool {
            self.width > other.width && self.height > other.height
        }
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
        #[test]
        fn larger_can_hold_smaller() {
            let larger = Rectangle {
                width: 8,
                height: 7,
            };
            let smaller = Rectangle {
                width: 5,
                height: 1,
            };
    
            assert!(larger.can_hold(&smaller));
        }
    }
    ```

#### 11.1.3 ä½¿ç”¨ assert_eq! å’Œ assert_ne! æµ‹è¯•ç›¸ç­‰æ€§

+ éƒ½æ¥è‡ªæ ‡å‡†åº“

+ åˆ¤æ–­ä¸¤ä¸ªå‚æ•°æ˜¯ä½› **ç›¸ç­‰** æˆ– **ä¸ç­‰**

+ å®é™…ä¸Šï¼Œå®ƒä»¬ä½¿ç”¨çš„å°±æ˜¯`==`å’Œ`!=`è¿ç®—ç¬¦

+ æ–­è¨€å¤±è´¥ï¼šè‡ªåŠ¨æ‰“å°å‡ºä¸¤ä¸ªå‚æ•°çš„å€¼

  + ä½¿ç”¨`debug`æ ¼å¼æ‰“å°å‚æ•°
    + è¦æ±‚å‚æ•°å®ç°äº†`partialEq`å’Œ`Debug Traits`ï¼ˆæ‰€æœ‰çš„åŸºæœ¬ç±»å‹å’Œæ ‡å‡†åº“é‡Œçš„å¤§éƒ¨åˆ†ç±»å‹éƒ½å®ç°äº†ï¼‰

  ```rust
  pub fn add_two(a: i32) -> i32 {
      a + 3
  }
  
  #[cfg(test)]
  mod tests {
      use super::*;
  
      #[test]
      fn it_adds_two() {
          assert_eq!(4, add_two(2));
      }
  }
  ```

  ```rust
  test_demo_lib git:(main) âœ— ct                  
     Compiling test_demo_lib v0.1.0 (/home/urain/learning/BackEnd/Rust/Code/test_demo_lib)
      Finished test [unoptimized + debuginfo] target(s) in 0.54s
       Running unittests src/lib.rs (target/debug/deps/test_demo_lib-8ab6a173bdd46810)
  
  running 1 test
  test tests::it_adds_two ... FAILED
  
  failures:
  
  ---- tests::it_adds_two stdout ----
  thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
    left: `4`,
   right: `5`', src/lib.rs:76:9
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
  
  
  failures:
      tests::it_adds_two
  
  test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
  
  error: test failed, to rerun pass `--lib`
  ```

#### 11.1.4 è‡ªå®šä¹‰é”™è¯¯ä¿¡æ¯

+ æ·»åŠ è‡ªå®šä¹‰é”™è¯¯ä¿¡æ¯

  + å¯ä»¥å‘`assert!`ã€`assert_eq!`ã€`assert_ne!`æ·»åŠ å¯é€‰çš„è‡ªå®šä¹‰ä¿¡æ¯

    + è¿™äº›è‡ªå®šä¹‰ä¿¡æ¯å’Œå¤±è´¥ä¿¡æ¯éƒ½ä¼šæ‰“å°å‡ºæ¥
    + `assert!`ï¼šç¬¬ä¸€ä¸ªå‚æ•°å¿…å¡«ï¼Œè‡ªå®šä¹‰ä¿¡æ¯ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°
    + `assert_eq!`å’Œ`assert_ne!`ï¼šå‰ä¸¤ä¸ªå‚æ•°å¿…å¡«ï¼Œè‡ªå®šä¹‰ä¿¡æ¯ä½œä¸ºç¬¬ä¸‰ä¸ªå‚æ•°
    + è‡ªå®šä¹‰æ¶ˆæ¯å‚æ•°ä¼šè¢«ä¼ é€’ç»™`format!`å®ï¼Œå¯ä»¥ä½¿ç”¨`{}`å ä½ç¬¦

    ```rust
    pub fn greeting(name: &str) -> String {
        format!("Hello {}!", name)
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
        #[test]
        fn greeting_contains_name() {
            let result = greeting("Carol");
            assert!(result.contains("Carol"));
        }
    }
    ```

    è¿™ä¸ªç¨‹åºçš„éœ€æ±‚è¿˜æ²¡æœ‰è¢«ç¡®å®šï¼Œå› æ­¤é—®å€™æ–‡æœ¬å¼€å¤´çš„ `Hello` æ–‡æœ¬å¾ˆå¯èƒ½ä¼šæ”¹å˜ã€‚ç„¶è€Œæˆ‘ä»¬å¹¶ä¸æƒ³åœ¨éœ€æ±‚æ”¹å˜æ—¶ä¸å¾—ä¸æ›´æ–°æµ‹è¯•ï¼Œæ‰€ä»¥ç›¸æ¯”æ£€æŸ¥ `greeting` å‡½æ•°è¿”å›çš„ç¡®åˆ‡å€¼ï¼Œæˆ‘ä»¬å°†ä»…ä»…æ–­è¨€è¾“å‡ºçš„æ–‡æœ¬ä¸­åŒ…å«è¾“å…¥å‚æ•°ã€‚

    è®©æˆ‘ä»¬é€šè¿‡å°† `greeting` æ”¹ä¸ºä¸åŒ…å« `name` æ¥åœ¨ä»£ç ä¸­å¼•å…¥ä¸€ä¸ª bug æ¥æµ‹è¯•å¤±è´¥æ—¶æ˜¯æ€æ ·çš„ï¼š

    ```rust
    pub fn greeting(name: &str) -> String {
        String::from("Hello!")
    }
    ```

    ```rust
    $ cargo test
       Compiling greeter v0.1.0 (file:///projects/greeter)
        Finished test [unoptimized + debuginfo] target(s) in 0.91s
         Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)
    
    running 1 test
    test tests::greeting_contains_name ... FAILED
    
    failures:
    
    ---- tests::greeting_contains_name stdout ----
    thread 'main' panicked at 'assertion failed: result.contains(\"Carol\")', src/lib.rs:12:9
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
    
    
    failures:
        tests::greeting_contains_name
    
    test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
    
    error: test failed, to rerun pass `--lib`
    ```

    ç»“æœä»…ä»…å‘Šè¯‰äº†æˆ‘ä»¬æ–­è¨€å¤±è´¥äº†å’Œå¤±è´¥çš„è¡Œå·ã€‚ä¸€ä¸ªæ›´æœ‰ç”¨çš„å¤±è´¥ä¿¡æ¯åº”è¯¥æ‰“å°å‡º `greeting` å‡½æ•°çš„å€¼ã€‚è®©æˆ‘ä»¬ä¸ºæµ‹è¯•å‡½æ•°å¢åŠ ä¸€ä¸ªè‡ªå®šä¹‰å¤±è´¥ä¿¡æ¯å‚æ•°ï¼šå¸¦å ä½ç¬¦çš„æ ¼å¼å­—ç¬¦ä¸²ï¼Œä»¥åŠ `greeting` å‡½æ•°çš„å€¼ï¼š

    ```rust
    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{}`",
            result
        );
    }
    ```

    ç°åœ¨å¦‚æœå†æ¬¡è¿è¡Œæµ‹è¯•ï¼Œå°†ä¼šçœ‹åˆ°æ›´æœ‰ä»·å€¼çš„ä¿¡æ¯ï¼š

    ```rust
    $ cargo test
       Compiling greeter v0.1.0 (file:///projects/greeter)
        Finished test [unoptimized + debuginfo] target(s) in 0.93s
         Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)
    
    running 1 test
    test tests::greeting_contains_name ... FAILED
    
    failures:
    
    ---- tests::greeting_contains_name stdout ----
    thread 'main' panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
    
    
    failures:
        tests::greeting_contains_name
    
    test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
    
    error: test failed, to rerun pass `--lib`
    ```

    å¯ä»¥åœ¨æµ‹è¯•è¾“å‡ºä¸­çœ‹åˆ°æ‰€å–å¾—çš„ç¡®åˆ‡çš„å€¼ï¼Œè¿™ä¼šå¸®åŠ©æˆ‘ä»¬ç†è§£çœŸæ­£å‘ç”Ÿäº†ä»€ä¹ˆï¼Œè€Œä¸æ˜¯æœŸæœ›å‘ç”Ÿä»€ä¹ˆã€‚

#### 11.1.5 ç”¨ should_panic æ£€æŸ¥ panic

+ éªŒè¯é”™è¯¯å¤„ç†çš„æƒ…å†µ

  + æµ‹è¯•é™¤äº†éªŒè¯ä»£ç çš„è¿”å›å€¼æ˜¯å¦æ­£ç¡®ï¼Œè¿˜éœ€éªŒè¯ä»£ç æ˜¯å¦å¦‚é¢„æœŸçš„å¤„ç†äº†å‘ç”Ÿé”™è¯¯çš„æƒ…å†µ

  + å¯éªŒè¯ä»£ç åœ¨ç‰¹å®šæƒ…å†µä¸‹æ˜¯å¦å‘ç”Ÿäº†`panic`

  + `should_panic`å±æ€§ï¼ˆattributeï¼‰

    + å‡½æ•°`panic`ï¼šæµ‹è¯•é€šè¿‡
    + å‡½æ•°æ²¡æœ‰`panic`ï¼šæµ‹è¯•å¤±è´¥

    ```rust
    pub struct Guess {
        value: i32,
    }
    
    impl Guess {
        pub fn new(value: i32) -> Guess {
            if value < 1 || value > 100 {
                panic!("Guess value must be between 1 and 100, got {}.", value);
            }
    
            Guess { value }
        }
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
        #[test]
        #[should_panic]
        fn greater_than_100() {
            Guess::new(200);
        }
    }
    ```

    æµ‹è¯•é€šè¿‡

    ```rust
    // --snip--
    impl Guess {
        pub fn new(value: i32) -> Guess {
            if value < 1 {
                panic!("Guess value must be between 1 and 100, got {}.", value);
            }
    
            Guess { value }
        }
    }
    ```

    ```rust
    $ cargo test
       Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
        Finished test [unoptimized + debuginfo] target(s) in 0.62s
         Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)
    
    running 1 test
    test tests::greater_than_100 - should panic ... FAILED
    
    failures:
    
    ---- tests::greater_than_100 stdout ----
    note: test did not panic as expected
    
    failures:
        tests::greater_than_100
    
    test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
    
    error: test failed, to rerun pass `--lib`
    ```

    æµ‹è¯•å¤±è´¥

+ è®© should_panic æ›´ç²¾ç¡®

  + ä¸º`should_panic`å±æ€§æ·»åŠ ä¸€ä¸ªå¯é€‰çš„`expected`å‚æ•°

    + å°†æ£€æŸ¥å¤±è´¥ä¿¡æ¯ä¸­æ˜¯å¦åŒ…å«æ‰€æŒ‡å®šçš„æ–‡å­—

    ```rust
    // --snip--
    
    impl Guess {
        pub fn new(value: i32) -> Guess {
            if value < 1 {
                panic!(
                    "Guess value must be greater than or equal to 1, got {}.",
                    value
                );
            } else if value > 100 {
                panic!(
                    "Guess value must be less than or equal to 100, got {}.",
                    value
                );
            }
    
            Guess { value }
        }
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
        #[test]
        #[should_panic(expected = "less than or equal to 100")]
        fn greater_than_100() {
            Guess::new(200);
        }
    }
    ```

#### 11.1.6 åœ¨æµ‹è¯•ä¸­ä½¿ç”¨ Result<T, E>

+ æ— éœ€`panic`ï¼Œå¯ä½¿ç”¨`Result<T, E>`ä½œä¸ºè¿”å›ç±»å‹ç¼–å†™æµ‹è¯•

  + è¿”å›`Ok`ï¼šæµ‹è¯•é€šè¿‡
  + è¿”å›`Err`ï¼šæµ‹è¯•å¤±è´¥

  ```rust
  #[cfg(test)]
  mod tests {
      #[test]
      fn it_works() -> Result<(), String> {
          if 2 + 2 == 4 {
              Ok(())
          } else {
              Err(String::from("two plus two does not equal four"))
          }
      }
  }
  ```

+ ä¸è¦åœ¨ä½¿ç”¨`Rsult<T, E>`ç¼–å†™çš„æµ‹è¯•ä¸Šæ ‡æ³¨`#[should_panic]`



### 11.2 æ§åˆ¶æµ‹è¯•å¦‚ä½•è¿è¡Œ

+ æ”¹å˜`cargo test`çš„è¡Œä¸ºï¼šæ·»åŠ å‘½ä»¤è¡Œå‚æ•°
+ é»˜è®¤è¡Œä¸º
  + å¹¶è¡Œè¿è¡Œ
  + æ‰€æœ‰æµ‹è¯•
  + æ•è·ï¼ˆä¸æ˜¾ç¤ºï¼‰æ‰€æœ‰è¾“å‡ºï¼Œä½¿è¯»å–ä¸æµ‹è¯•ç»“æœç›¸å…³çš„è¾“å‡ºæ›´å®¹æ˜“
+ å‘½ä»¤è¡Œå‚æ•°
  + é’ˆå¯¹`cargo test`çš„å‚æ•°ï¼Œç´§è·Ÿ`cargo test`å
  + é’ˆå¯¹æµ‹è¯•å¯æ‰§è¡Œç¨‹åºï¼Œæ”¾åœ¨` -- `ä¹‹å

#### 11.2.1 å¹¶è¡Œæˆ–è¿ç»­çš„è¿è¡Œæµ‹è¯•

+ å¹¶è¡Œè¿è¡Œæµ‹è¯•
  + è¿è¡Œå¤šä¸ªæµ‹è¯•ï¼šé»˜è®¤ä½¿ç”¨å¤šä¸ªçº¿ç¨‹å¹¶è¡Œè¿è¡Œ
    + è¿è¡Œå¿«
  + ç¡®ä¿æµ‹è¯•ä¹‹é—´
    + ä¸ä¼šç›¸äº’ä¾èµ–
    + ä¸ä¾èµ–äºæŸä¸ªå…±äº«çŠ¶æ€ï¼ˆç¯å¢ƒã€å·¥ä½œç›®å½•ã€ç¯å¢ƒå˜é‡ç­‰ç­‰ï¼‰
+ `test-threads`å‚æ•°
  + ä¼ é€’ç»™äºŒè¿›åˆ¶æ–‡ä»¶
  + ä¸æƒ³ä»¥å¹¶è¡Œæ–¹å¼è¿è¡Œæµ‹è¯•ï¼Œæˆ–æƒ³å¯¹çº¿ç¨‹æ•°è¿›è¡Œç»†ç²’åº¦æ§åˆ¶
  + å¯ä»¥ä½¿ç”¨`--test-threads`å‚æ•°ï¼Œåè¾¹è·Ÿç€çº¿ç¨‹çš„æ•°é‡
  + ä¾‹å¦‚ï¼š`cargo test -- --test-threads=1`

#### 11.2.2 æ˜¾å¼å‡½æ•°è¾“å‡º

+ é»˜è®¤ï¼Œå¦‚æµ‹è¯•é€šè¿‡ï¼ŒRustçš„`test`åº“ä¼šæ•è·æ‰€æœ‰æ‰“å°åˆ°æ ‡å‡†è¾“å‡ºçš„å†…å®¹

+ ä¾‹å¦‚ï¼Œå¦‚æœè¢«æµ‹è¯•ä»£ç ä¸­ç”¨åˆ°äº†`println!`

  + å¦‚æœæµ‹è¯•é€šè¿‡ï¼šä¸ä¼šåœ¨ç»ˆç«¯çœ‹åˆ°`println!`æ‰“å°çš„å†…å®¹
  + å¦‚æœæµ‹è¯•å¤±è´¥ï¼šä¼šçœ‹åˆ°`println!`æ‰“å°çš„å†…å®¹å’Œå¤±è´¥ä¿¡æ¯

  ```rust
  fn prints_and_returns_10(a: i32) -> i32 {
      println!("I got the value {}", a);
      10
  }
  
  #[cfg(test)]
  mod tests {
      use super::*;
  
      #[test]
      fn this_test_will_pass() {
          let value = prints_and_returns_10(4);
          assert_eq!(10, value);
      }
  
      #[test]
      fn this_test_will_fail() {
          let value = prints_and_returns_10(8);
          assert_eq!(5, value);
      }
  }
  ```

+ å¦‚æœæƒ³åœ¨æˆåŠŸçš„æµ‹è¯•ä¸­çœ‹åˆ°æ‰“å°çš„å†…å®¹ï¼š`--show-output`

  ```rust
  test_demo_lib git:(main) âœ— ct -- --show-output
  warning: function `prints_and_returns_10` is never used
     --> src/lib.rs:162:4
      |
  162 | fn prints_and_returns_10(a: i32) -> i32 {
      |    ^^^^^^^^^^^^^^^^^^^^^
      |
      = note: `#[warn(dead_code)]` on by default
  
  warning: `test_demo_lib` (lib) generated 1 warning
      Finished test [unoptimized + debuginfo] target(s) in 0.01s
       Running unittests src/lib.rs (target/debug/deps/test_demo_lib-8ab6a173bdd46810)
  
  running 2 tests
  test tests::this_test_will_pass ... ok
  test tests::this_test_will_fail ... FAILED
  
  successes:
  
  ---- tests::this_test_will_pass stdout ----
  I got the value 4
  
  
  successes:
      tests::this_test_will_pass
  
  failures:
  
  ---- tests::this_test_will_fail stdout ----
  I got the value 8
  thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
    left: `5`,
   right: `10`', src/lib.rs:180:9
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
  
  
  failures:
      tests::this_test_will_fail
  
  test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
  
  error: test failed, to rerun pass `--lib`
  ```

#### 11.2.3 é€šè¿‡æŒ‡å®šåç§°æ¥è¿è¡Œéƒ¨åˆ†æµ‹è¯•

+ æŒ‰åç§°è¿è¡Œæµ‹è¯•çš„å­é›†

  ```rust
  pub fn add_two(a: i32) -> i32 {
      a + 2
  }
  
  #[cfg(test)]
  mod tests {
      use super::*;
  
      #[test]
      fn add_two_and_two() {
          assert_eq!(4, add_two(2));
      }
  
      #[test]
      fn add_three_and_two() {
          assert_eq!(5, add_two(3));
      }
  
      #[test]
      fn one_hundred() {
          assert_eq!(102, add_two(100));
      }
  }
  ```

  

+ é€‰æ‹©è¿è¡Œçš„æµ‹è¯•ï¼šå°†æµ‹è¯•çš„åç§°ï¼ˆä¸€ä¸ªæˆ–å¤šä¸ªï¼‰ä½œä¸º`cargo test`çš„å‚æ•°

  + è¿è¡Œå•ä¸ªæµ‹è¯•ï¼šæŒ‡å®šæµ‹è¯•å

    ```rust
    cargo test add_three_and_two
    ```

  + è¿è¡Œå¤šä¸ªæµ‹è¯•ï¼šæŒ‡å®šæµ‹è¯•åçš„ä¸€éƒ¨åˆ†ï¼ˆæ¨¡å—åä¹Ÿå¯ä»¥ï¼‰

    ```rust
    cargo test add
    ```

#### 11.2.4 å¿½ç•¥æŸäº›æµ‹è¯•

+ `ignore`å±æ€§ï¼ˆattributeï¼‰

  ```rust
  #[test]
  fn it_works() {
      assert_eq!(2 + 2, 4);
  }
  
  #[test]
  #[ignore]
  fn expensive_test() {
      // éœ€è¦è¿è¡Œä¸€ä¸ªå°æ—¶çš„ä»£ç 
  }
  ```

+ è¿è¡Œè¢«å¿½ç•¥ï¼ˆignoreï¼‰çš„æµ‹è¯•

  + `cargo test -- --ignored`



### 11.3 æµ‹è¯•çš„ç»„ç»‡ç»“æ„

#### 11.3.1 æµ‹è¯•çš„åˆ†ç±»

+ Rustå¯¹æµ‹è¯•çš„åˆ†ç±»
  + å•å…ƒæµ‹è¯•
  + é›†æˆæµ‹è¯•
+ å•å…ƒæµ‹è¯•
  + å°ã€ä¸“æ³¨
  + ä¸€æ¬¡å¯¹ä¸€ä¸ªæ¨¡å—è¿›è¡Œéš”ç¦»çš„æµ‹è¯•
  + å¯æµ‹è¯•`prvate`æ¥å£
+ é›†æˆæµ‹è¯•
  + åœ¨åº“å¤–éƒ¨ã€‚å’Œå…¶å®ƒå¤–éƒ¨ä»£ç ä¸€æ ·ä½¿ç”¨ä½ çš„ä»£ç 
  + åªèƒ½ä½¿ç”¨`public`æ¥å£
  + å¯èƒ½åœ¨æ¯ä¸ªæµ‹è¯•ä¸­ä½¿ç”¨åˆ°å¤šä¸ªæ¨¡å—

#### 11.3.2 å•å…ƒæµ‹è¯•

å•å…ƒæµ‹è¯•çš„ç›®çš„æ˜¯åœ¨ä¸å…¶ä»–éƒ¨åˆ†éš”ç¦»çš„ç¯å¢ƒä¸­æµ‹è¯•æ¯ä¸€ä¸ªå•å…ƒçš„ä»£ç ï¼Œä»¥ä¾¿äºå¿«é€Ÿè€Œå‡†ç¡®çš„æŸä¸ªå•å…ƒçš„ä»£ç åŠŸèƒ½æ˜¯å¦ç¬¦åˆé¢„æœŸã€‚å•å…ƒæµ‹è¯•ä¸ä»–ä»¬è¦æµ‹è¯•çš„ä»£ç å…±åŒå­˜æ”¾åœ¨ä½äº *src* ç›®å½•ä¸‹ç›¸åŒçš„æ–‡ä»¶ä¸­ã€‚è§„èŒƒæ˜¯åœ¨æ¯ä¸ªæ–‡ä»¶ä¸­åˆ›å»ºåŒ…å«æµ‹è¯•å‡½æ•°çš„ `tests` æ¨¡å—ï¼Œå¹¶ä½¿ç”¨ `cfg(test)` æ ‡æ³¨æ¨¡å—ã€‚

+ `#[cfg(test)]`æ ‡æ³¨

  + `tests`æ¨¡å—ä¸Šçš„`#[cfg(test)]`æ ‡æ³¨

    + åªæœ‰è¿è¡Œ`cargo test`æ‰ç¼–è¯‘å’Œè¿è¡Œä»£ç 
    + è¿è¡Œ`cargo build`åˆ™ä¸ä¼š

  + é›†æˆæµ‹è¯•åœ¨ä¸åŒçš„ç›®å½•ï¼Œå®ƒä¸éœ€è¦`#[cfg(test)]`æ ‡æ³¨

  + `cfg`ï¼šconfigurationï¼ˆé…ç½®ï¼‰

    + å‘Šè¯‰Rustä¸‹é¢çš„æ¡ç›®åªæœ‰åœ¨æŒ‡å®šçš„é…ç½®é€‰é¡¹ä¸‹æ‰è¢«åŒ…å«
    + é…ç½®é€‰é¡¹`test`ï¼šæœ‰Rustæä¾›ï¼Œç”¨æ¥ç¼–è¯‘å’Œè¿è¡Œæµ‹è¯•
      + åªæœ‰`cargo test`æ‰ä¼šç¼–è¯‘ä»£ç ï¼ŒåŒ…æ‹¬**æ¨¡å—ä¸­**çš„`helper`å‡½æ•°å’Œ`#[test]`æ ‡æ³¨çš„å‡½æ•°

    ```rust
    #[cfg(test)]
    mod tests {
        #[test]
        fn it_works() {
            let result = 2 + 2;
            assert_eq!(result, 4);
        }
    }
    ```

    ä¸Šè¿°ä»£ç å°±æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„æµ‹è¯•æ¨¡å—ã€‚`cfg` å±æ€§ä»£è¡¨ *configuration* ï¼Œå®ƒå‘Šè¯‰ Rust å…¶ä¹‹åçš„é¡¹åªåº”è¯¥è¢«åŒ…å«è¿›ç‰¹å®šé…ç½®é€‰é¡¹ä¸­ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œé…ç½®é€‰é¡¹æ˜¯ `test`ï¼Œå³ Rust æ‰€æä¾›çš„ç”¨äºç¼–è¯‘å’Œè¿è¡Œæµ‹è¯•çš„é…ç½®é€‰é¡¹ã€‚é€šè¿‡ä½¿ç”¨ `cfg` å±æ€§ï¼ŒCargo åªä¼šåœ¨æˆ‘ä»¬ä¸»åŠ¨ä½¿ç”¨ `cargo test` è¿è¡Œæµ‹è¯•æ—¶æ‰ç¼–è¯‘æµ‹è¯•ä»£ç ã€‚è¿™åŒ…æ‹¬æµ‹è¯•æ¨¡å—ä¸­å¯èƒ½å­˜åœ¨çš„å¸®åŠ©å‡½æ•°ï¼Œä»¥åŠæ ‡æ³¨ä¸º #[test] çš„å‡½æ•°ã€‚

+ æµ‹è¯•ç§æœ‰å‡½æ•°

  + Rustå…è®¸æµ‹è¯•ç§æœ‰å‡½æ•°

    ```rust
    pub fn add_two(a: i32) -> i32 {
        internal_adder(a, 2)
    }
    
    fn internal_adder(a: i32, b: i32) -> i32 {
        a + b
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
        #[test]
        fn internal() {
            assert_eq!(4, internal_adder(2, 2));
        }
    }
    ```

#### 11.3.3 é›†æˆæµ‹è¯•

åœ¨ Rust ä¸­ï¼Œé›†æˆæµ‹è¯•å¯¹äºä½ éœ€è¦æµ‹è¯•çš„åº“æ¥è¯´å®Œå…¨æ˜¯å¤–éƒ¨çš„ã€‚åŒå…¶ä»–ä½¿ç”¨åº“çš„ä»£ç ä¸€æ ·ä½¿ç”¨åº“æ–‡ä»¶ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒä»¬åªèƒ½è°ƒç”¨ä¸€éƒ¨åˆ†åº“ä¸­çš„å…¬æœ‰ APIã€‚é›†æˆæµ‹è¯•çš„ç›®çš„æ˜¯æµ‹è¯•åº“çš„å¤šä¸ªéƒ¨åˆ†èƒ½å¦ä¸€èµ·æ­£å¸¸å·¥ä½œã€‚ä¸€äº›å•ç‹¬èƒ½æ­£ç¡®è¿è¡Œçš„ä»£ç å•å…ƒé›†æˆåœ¨ä¸€èµ·ä¹Ÿå¯èƒ½ä¼šå‡ºç°é—®é¢˜ï¼Œæ‰€ä»¥é›†æˆæµ‹è¯•çš„è¦†ç›–ç‡ä¹Ÿæ˜¯å¾ˆé‡è¦çš„ã€‚ä¸ºäº†åˆ›å»ºé›†æˆæµ‹è¯•ï¼Œä½ éœ€è¦å…ˆåˆ›å»ºä¸€ä¸ª *tests* ç›®å½•ã€‚

+ testsç›®å½•

  + åˆ›å»ºé›†æˆæµ‹è¯•ï¼š`tests`ç›®å½•

  + `tests`ç›®å½•ä¸‹çš„æ¯ä¸ªæµ‹è¯•æ–‡ä»¶éƒ½æ˜¯å•ç‹¬çš„ä¸€ä¸ª`crate`

    + éœ€è¦å°†è¢«æµ‹è¯•åº“å¯¼å…¥

  + æ— éœ€æ ‡æ³¨`#[cfg(test)]`ï¼Œ`tests`ç›®å½•è¢«ç‰¹æ®Šå¯¹å¾…

    + åªè¦`cargo test`ï¼Œæ‰ä¼šç¼–è¯‘`tests`ç›®å½•ä¸‹çš„æ–‡ä»¶

    ```rust
    use test_demo_lib;
    #[test]
    fn it_adds_two() {
        assert_eq!(4, test_demo_lib::add_two(2));
    }
    ```

+ è¿è¡ŒæŒ‡å®šçš„é›†æˆæµ‹è¯•

  + è¿è¡Œä¸€ä¸ªç‰¹å®šçš„é›†æˆæµ‹è¯•ï¼š`cargo test å‡½æ•°å`

  + è¿è¡ŒæŸä¸ªæµ‹è¯•æ–‡ä»¶å†…æ‰€æœ‰æµ‹è¯•ï¼š`cargo test --test æ–‡ä»¶å`

    ```rust
    ct --test integration_tests
        Finished test [unoptimized + debuginfo] target(s) in 0.01s
         Running tests/integration_tests.rs (target/debug/deps/integration_tests-632d5c3c055e343d)
    
    running 1 test
    test it_adds_two ... ok
    
    test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
    ```

+ é›†æˆæµ‹è¯•ä¸­çš„å­æ¨¡å—

  + `tests`ç›®å½•ä¸‹çš„æ¯ä¸ªæ–‡ä»¶è¢«ç¼–è¯‘æˆå•ç‹¬çš„`crate`
    + è¿™äº›æ–‡ä»¶ä¸å…±äº«è¡Œä¸ºï¼ˆä¸srcä¸‹çš„æ–‡ä»¶è§„åˆ™ä¸åŒï¼‰

+ é’ˆå¯¹`binary crate`çš„é›†æˆæµ‹è¯•

  + å¦‚æœé¡¹ç›®æ˜¯`binary crate`ï¼Œåªå«æœ‰`src/main.rs`ï¼Œæ²¡æœ‰`src/lib.rs`
    + ä¸èƒ½åœ¨`tests`ç›®å½•ä¸‹åˆ›å»ºé›†æˆæµ‹è¯•
    + æ— æ³•æŠŠ`main.rs`çš„å‡½æ•°å¯¼å…¥ä½œç”¨åŸŸ
  + åªè¦`library crate`æ‰èƒ½æš´éœ²å‡½æ•°ç»™å…¶å®ƒ`crate`ä½¿ç”¨
  + `binary crate`æ„å‘³ç€ç‹¬ç«‹è¿è¡Œ



## 12ã€ä¸€ä¸ª I/O é¡¹ç›®ï¼šæ„å»ºä¸€ä¸ªå‘½ä»¤è¡Œç¨‹åº

### 12.1 æ¥å—å‘½ä»¤è¡Œå‚æ•°

```rust
use std::env; //collect

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{:?}", args);
    let query = &args[1];
    let filename = &args[2];
    println!("Search for  {}", query);
    println!("In file {}", filename);
}
```



### 12.2 è¯»å–æ–‡ä»¶

```rust
use std::env; //collect
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();
    let query = &args[1];
    let filename = &args[2];

    println!("Search for  {}", query);
    println!("In file {}", filename);

    let contents = fs::read_to_string(filename).expect("Something went wrong reading the file");
    println!("With text: \n{}", contents);
}
```



### 12.3 é‡æ„æ”¹è¿›æ¨¡å—æ€§å’Œé”™è¯¯å¤„ç†

#### 12.3.1 äºŒè¿›åˆ¶ç¨‹åºå…³æ³¨ç‚¹åˆ†ç¦»çš„æŒ‡å¯¼æ€§åŸåˆ™

+ å°†ç¨‹åºæ‹†åˆ†ä¸º`main.rs`å’Œ`lib.rs`ï¼Œå°†ä¸šåŠ¡é€»è¾‘æ”¾å…¥`lib.rs`
+ å½“å‘½ä»¤è¡Œè§£æé€»è¾‘è¾ƒå°‘æ—¶ï¼Œå°†å®ƒæ”¾åœ¨`main.rs`ä¹Ÿè¡Œ
+ å½“å‘½ä»¤è¡Œè§£æé€»è¾‘å˜å¤æ‚æ—¶ï¼Œéœ€è¦å°†å®ƒä»`main.rs`æå–åˆ°`lib.rs`

**ç»è¿‡ä¸Šè¿°æ‹†åˆ†ä¹‹åï¼Œç•™åœ¨`main`çš„åŠŸèƒ½æœ‰ï¼š**

+ ä½¿ç”¨å‚æ•°å€¼è°ƒç”¨å‘½ä»¤è¡Œè§£æé€»è¾‘
+ è¿›è¡Œå…¶å®ƒé…ç½®
+ è°ƒç”¨`lib.rs`ä¸­çš„`run`å‡½æ•°
+ å¤„ç†`run`å‡½æ•°å¯èƒ½å‡ºç°çš„é”™è¯¯

```rust
use std::env; //collect
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();
    
    let config = Config::new(&args);

    let contents = fs::read_to_string(config.filename).expect("Something went wrong reading the file");
    println!("With text: \n{}", contents);
}

struct Config {
    query: String, 
    filename: String,
}

impl Config {
    fn new(args: &[String]) -> Config { 
        let query = args[1].clone();
        let filename = args[2].clone();
        Config { query, filename }
    }
}
```

#### 12.3.2 ä¿®å¤é”™è¯¯å¤„ç†

```rust
use std::env; //collect
use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();
    
    let config = Config::new(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    let contents = fs::read_to_string(config.filename).expect("Something went wrong reading the file");
    println!("With text: \n{}", contents);
}

struct Config {
    query: String, 
    filename: String,
}

impl Config {
    fn new(args: &[String]) -> Result<Config, &'static str> { 
        if args.len() < 3 {
            return Err("not enough arguments");
        }
        let query = args[1].clone();
        let filename = args[2].clone();
        Ok(Config { query, filename })
    }
}
```

#### 12.3.3 ä»mainæå–é€»è¾‘

+ **main.rs**

  ```rust
  use std::env;
  use std::process;
  use minigrep::Config;
  
  
  fn main() {
      let args: Vec<String> = env::args().collect();
      
      let config = Config::new(&args).unwrap_or_else(|err| {
          println!("Problem parsing arguments: {}", err);
          process::exit(1);
      });
      if let Err(e) = minigrep::run(config) {
          println!("Application error: {}", e);
          process::exit(1);
      }
  }
  ```

  

+ **lib.rs**

  ```rust
  use std::fs;
  use std::error::Error;
  
  pub fn run(config: Config) -> Result<(), Box<dyn Error>>{
      let contents = fs::read_to_string(config.filename)?;
      println!("With text: \n{}", contents);
      Ok(())
  }
  
  pub struct Config {
      pub query: String, 
      pub filename: String,
  }
  
  impl Config {
      pub fn new(args: &[String]) -> Result<Config, &'static str> { 
          if args.len() < 3 {
              return Err("not enough arguments");
          }
          let query = args[1].clone();
          let filename = args[2].clone();
          Ok(Config { query, filename })
      }
  }
  ```

  

### 12.4 ä½¿ç”¨æµ‹è¯•é©±åŠ¨å¼€å‘ï¼ˆTest Driven Developmentï¼ŒTDDï¼‰å¼€å‘åº“åŠŸèƒ½

1. ç¼–å†™ä¸€ä¸ªå¤±è´¥çš„æµ‹è¯•ï¼Œå¹¶è¿è¡Œå®ƒä»¥ç¡®ä¿å®ƒå¤±è´¥çš„åŸå› æ˜¯ä½ æ‰€æœŸæœ›çš„ã€‚
2. ç¼–å†™æˆ–ä¿®æ”¹è¶³å¤Ÿçš„ä»£ç æ¥ä½¿æ–°çš„æµ‹è¯•é€šè¿‡ã€‚
3. é‡æ„åˆšåˆšå¢åŠ æˆ–ä¿®æ”¹çš„ä»£ç ï¼Œå¹¶ç¡®ä¿æµ‹è¯•ä»ç„¶èƒ½é€šè¿‡ã€‚
4. ä»æ­¥éª¤ 1 å¼€å§‹é‡å¤ï¼

+ **lib.rs**

  ```rust
  use std::fs;
  use std::error::Error;
  
  pub fn run(config: Config) -> Result<(), Box<dyn Error>>{
      let contents = fs::read_to_string(config.filename)?;
      for line in search(&config.query, &contents) {
          println!("{}", line);
      }
      Ok(())
  }
  
  pub struct Config {
      pub query: String, 
      pub filename: String,
  }
  
  impl Config {
      pub fn new(args: &[String]) -> Result<Config, &'static str> { 
          if args.len() < 3 {
              return Err("not enough arguments");
          }
          let query = args[1].clone();
          let filename = args[2].clone();
          Ok(Config { query, filename })
      }
  }
  
  pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
      let mut results = Vec::new();
      for line in contents.lines() {
          if line.contains(query) {
              results.push(line);
          }
      }
      results
  }
  
  
  #[cfg(test)]
  mod tests {
      use  super::*;
  
      #[test]
      fn one_result() {
          let query = "duct";
          let contents = "\
  Rust:
  safe, fast, productive.
  Pick three.";
          assert_eq!(vec!["safe, fast, productive."], search(query, contents))
      }
  }
  ```

  

### 12.5 ä½¿ç”¨ç¯å¢ƒå˜é‡

æˆ‘ä»¬å°†å¢åŠ ä¸€ä¸ªé¢å¤–çš„åŠŸèƒ½æ¥æ”¹è¿› `minigrep`ï¼šç”¨æˆ·å¯ä»¥é€šè¿‡è®¾ç½®ç¯å¢ƒå˜é‡æ¥è®¾ç½®æœç´¢æ˜¯å¦æ˜¯å¤§å°å†™æ•æ„Ÿçš„ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°†å…¶è®¾è®¡ä¸ºä¸€ä¸ªå‘½ä»¤è¡Œå‚æ•°å¹¶è¦æ±‚ç”¨æˆ·æ¯æ¬¡éœ€è¦æ—¶éƒ½åŠ ä¸Šå®ƒï¼Œä¸è¿‡åœ¨è¿™é‡Œæˆ‘ä»¬å°†ä½¿ç”¨ç¯å¢ƒå˜é‡ã€‚è¿™å…è®¸ç”¨æˆ·è®¾ç½®ç¯å¢ƒå˜é‡ä¸€æ¬¡ä¹‹ååœ¨æ•´ä¸ªç»ˆç«¯ä¼šè¯ä¸­æ‰€æœ‰çš„æœç´¢éƒ½å°†æ˜¯å¤§å°å†™ä¸æ•æ„Ÿçš„ã€‚

+ **lib.rs**

  ```rust
  use std::fs;
  use std::error::Error;
  use std::env;
  
  pub fn run(config: Config) -> Result<(), Box<dyn Error>>{
      let contents = fs::read_to_string(config.filename)?;
      let results = if config.case_sensitive {
          search(&config.query, &contents)
      } else {
          search_case_insensitive(&config.query, &contents)
      };
      for line in results {
          println!("{}", line);
      }
      Ok(())
  }
  
  pub struct Config {
      pub query: String, 
      pub filename: String,
      pub case_sensitive: bool,
  }
  
  impl Config {
      pub fn new(args: &[String]) -> Result<Config, &'static str> { 
          if args.len() < 3 {
              return Err("not enough arguments");
          }
          let query = args[1].clone();
          let filename = args[2].clone();
          let case_sensitive = env::var("CASE_INSENSITIVE").is_err();
          Ok(Config { query, filename, case_sensitive })
      }
  }
  
  pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
      let mut results = Vec::new();
      for line in contents.lines() {
          if line.contains(query) {
              results.push(line);
          }
      }
      results
  }
  
  pub fn search_case_insensitive<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
      let mut results = Vec::new();
      let query = query.to_lowercase();
      for line in contents.lines() {
          if line.to_lowercase().contains(&query) {
              results.push(line);
          }
      }
      results
  }
  
  
  #[cfg(test)]
  mod tests {
      use  super::*;
  
      #[test]
      fn case_sensitive() {
          let query = "duct";
          let contents = "\
  Rust:
  safe, fast, productive.
  Pick three.
  Duct tape.";
          assert_eq!(vec!["safe, fast, productive."], search(query, contents))
      }
  
      #[test]
      fn case_insensitive() {
          let query = "rUsT";
          let contents = "\
  Rust:
  safe, fast, productive.
  Pick three.
  Trust me.";
          assert_eq!(vec!["Rust:", "Trust me."], search_case_insensitive(query, contents))
      }
  }
  ```



### 12.6 å°†é”™è¯¯ä¿¡æ¯è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯è€Œä¸æ˜¯æ ‡å‡†è¾“å‡º

+ æ ‡å‡†è¾“å‡ºï¼š`stdout`
  + `println!`
  
+ æ ‡å‡†é”™è¯¯ï¼š`stderr`
  + `eprintln!`
  
  ```rust
  use std::env;
  use std::process;
  use minigrep::Config;
  
  
  fn main() {
      let args: Vec<String> = env::args().collect();
      
      let config = Config::new(&args).unwrap_or_else(|err| {
          eprintln!("Problem parsing arguments: {}", err);
          process::exit(1);
      });
      if let Err(e) = minigrep::run(config) {
          eprintln!("Application error: {}", e);
          process::exit(1);
      }
  }
  ```
  



## 13ã€Rustä¸­çš„å‡½æ•°å¼è¯­è¨€ç‰¹æ€§ï¼šè¿­ä»£å™¨ä¸é—­åŒ…
### 13.1 é—­åŒ…ï¼ˆ*closures*ï¼‰ï¼šå¯ä»¥æ•è·ç¯å¢ƒçš„åŒ¿åå‡½æ•°

Rust çš„ **é—­åŒ…**ï¼ˆ*closures*ï¼‰æ˜¯å¯ä»¥ä¿å­˜åœ¨ä¸€ä¸ªå˜é‡ä¸­æˆ–ä½œä¸ºå‚æ•°ä¼ é€’ç»™å…¶ä»–å‡½æ•°çš„åŒ¿åå‡½æ•°ã€‚å¯ä»¥åœ¨ä¸€ä¸ªåœ°æ–¹åˆ›å»ºé—­åŒ…ï¼Œç„¶ååœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œé—­åŒ…è¿ç®—ã€‚ä¸åŒäºå‡½æ•°ï¼Œé—­åŒ…å…è®¸æ•è·è¢«å®šä¹‰æ—¶æ‰€åœ¨ä½œç”¨åŸŸä¸­çš„å€¼ã€‚

#### 13.1.1 ä½¿ç”¨é—­åŒ…æ¥åˆ›å»ºæŠ½è±¡åŒ–çš„ç¨‹åºè¡Œä¸º

**ä¾‹å­ï¼šç”Ÿæˆè‡ªå®šä¹‰è¿åŠ¨è®¡åˆ’çš„ç¨‹åº**

å‡è®¾æœ‰è¿™æ ·ä¸€ä¸ªåœºæ™¯ï¼šæˆ‘ä»¬èº«å¤„çš„åˆåˆ›å…¬å¸æ­£åœ¨å¼€å‘ä¸€ä¸ªä¸ºç”¨æˆ·æä¾›å¥èº«è®¡åˆ’çš„åº”ç”¨ã€‚ä½¿ç”¨Rustç¼–å†™çš„åç«¯ç¨‹åºåœ¨ç”Ÿæˆè®¡åˆ’çš„è¿‡ç¨‹ä¸­éœ€è¦è€ƒè™‘åˆ°å¹´é¾„ã€èº«ä½“è´¨é‡æŒ‡æ•°ï¼ˆBMIï¼‰ã€å¥èº«åå¥½ã€è¿åŠ¨å†å²ã€æŒ‡å®šå¼ºåº¦å€¼ç­‰å› ç´ ã€‚å…·ä½“çš„ç®—æ³•ç©¶ç«Ÿé•¿ä»€ä¹ˆæ ·å­åœ¨è¿™ä¸ªä¾‹å­ä¸­å¹¶ä¸é‡è¦ï¼Œé‡è¦çš„æ˜¯è¿™ä¸ªè®¡ç®—è¿‡ç¨‹ä¼šæ¶ˆè€—æ‰æ•°ç§’é’Ÿæ—¶é—´ã€‚æˆ‘ä»¬å¸Œæœ›åªåœ¨å¿…è¦çš„æ—¶å€™è°ƒç”¨ç®—æ³•ï¼Œå¹¶ä¸”åªè°ƒç”¨ä¸€æ¬¡ï¼Œä»¥å…è®©ç”¨æˆ·ç­‰å¾…è¿‡ä¹…ã€‚

+ ç®—æ³•çš„é€»è¾‘å¹¶ä¸æ˜¯é‡ç‚¹ï¼Œé‡ç‚¹æ˜¯ç®—æ³•ä¸­çš„è®¡ç®—è¿‡ç¨‹éœ€è¦å‡ ç§’ç§æ—¶é—´

+ ç›®æ ‡ï¼šä¸è®©ç”¨æˆ·å‘ç”Ÿä¸å¿…è¦çš„ç­‰å¾…

  + ä»…åœ¨å¿…è¦æ—¶è°ƒç”¨è¯¥ç®—æ³•
  + åªè°ƒç”¨ä¸€æ¬¡

+ **main.rs**

  ```rust
  use std::thread;
  use std::time::Duration;
  
  fn main() {
      let simulated_user_specified_value = 10;
      let simulated_random_number = 7;
      generate_workout(simulated_user_specified_value, simulated_random_number)
  }
  
  // fn simulated_expensive_calculation(intensity: u32) -> u32 {
  //     println!("calculating slowly ...");
  //     thread::sleep(Duration::from_secs(2));
  //     intensity
  // }
  
  fn generate_workout(intensity: u32, random_number: u32) {
      let expensive_closure = |num| {
          println!("calculating slowly ...");
          thread::sleep(Duration::from_secs(2));
          num
      };
  
      // let expensive_result = simulated_expensive_calculation(intensity);
      if intensity < 25 {
          println!("Today, do {} pushups!", expensive_closure(intensity));
          println!("Next, do {} situps!", expensive_closure(intensity));
      } else {
          if random_number == 3 {
              println!("Take a break today! Remember to stay hydrated!");
          } else {
              println!("Today, run for {} minutes!", expensive_closure(intensity));
          }
      }
  }
  ```

#### 13.1.2 é—­åŒ…ç±»å‹æ¨æ–­å’Œæ³¨è§£

+ é—­åŒ…ä¸è¦æ±‚æ ‡æ³¨å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹
+ é—­åŒ…é€šå¸¸å¾ˆçŸ­å°ï¼Œåªåœ¨ç‹­å°çš„ä¸Šä¸‹æ–‡ä¸­å·¥ä½œï¼Œç¼–è¯‘å™¨é€šå¸¸èƒ½æ¨æ–­å‡ºç±»å‹
+ å¯ä»¥æ‰‹åŠ¨æ·»åŠ ç±»å‹æ ‡æ³¨

  + `let expensive_closure = |num: u32| -> u32 {}`

##### å‡½æ•°é—­åŒ…çš„å®šä¹‰è¯­æ³•

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

æ³¨æ„ï¼šé—­åŒ…çš„å®šä¹‰æœ€ç»ˆåªä¼šä¸ºå‚æ•° / è¿”å›å€¼æ¨æ–­å‡ºå”¯ä¸€å…·ä½“çš„ç±»å‹

```rust
let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);
```

```rust
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --> src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected struct `String`, found integer
  |             arguments to this function are incorrect
  |
note: closure parameter defined here
 --> src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
```

ç¬¬ä¸€æ¬¡ä½¿ç”¨ `String` å€¼è°ƒç”¨ `example_closure` æ—¶ï¼Œç¼–è¯‘å™¨æ¨æ–­è¿™ä¸ªé—­åŒ…ä¸­ `x` çš„ç±»å‹ä»¥åŠè¿”å›å€¼çš„ç±»å‹æ˜¯ `String`ã€‚æ¥ç€è¿™äº›ç±»å‹è¢«é”å®šè¿›é—­åŒ… `example_closure` ä¸­ï¼Œå¦‚æœå°è¯•å¯¹åŒä¸€é—­åŒ…ä½¿ç”¨ä¸åŒç±»å‹åˆ™å°±ä¼šå¾—åˆ°ç±»å‹é”™è¯¯ã€‚

#### 13.1.3 ä½¿ç”¨æ³›å‹å‚æ•°å’Œ fn trait æ¥å­˜å‚¨é—­åŒ…

+ å¦ä¸€ä¸­è§£å†³æ–¹æ¡ˆ
+ åˆ›å»ºä¸€ä¸ª`struct`ï¼Œå®ƒæŒæœ‰é—­åŒ…åŠå…¶è°ƒç”¨ç»“æœ
  + åªä¼šåœ¨éœ€è¦ç»“æœæ—¶æ‰æ‰§è¡Œè¯¥é—­åŒ…
  + å¯ç¼“å­˜ç»“æœ
+ è¿™ç§æ¨¡å¼ä¸€èˆ¬ç§°ä½œè®°å¿†åŒ–ï¼ˆmemoizationï¼‰æˆ– å»¶è¿Ÿè®¡ç®— / æƒ°æ€§æ±‚å€¼ï¼ˆlazy evaluationï¼‰

##### å¦‚ä½•è®©structæŒæœ‰é—­åŒ…

+ `struct`çš„å®šä¹‰éœ€è¦çŸ¥é“æ‰€æœ‰å­—æ®µçš„ç±»å‹
  + éœ€è¦æŒ‡æ˜é—­åŒ…çš„ç±»å‹
+ æ¯ä¸ªé—­åŒ…å®ä¾‹éƒ½æœ‰è‡ªå·±å”¯ä¸€çš„åŒ¿åç±»å‹ï¼Œå³ä½¿ä¸¤ä¸ªé—­åŒ…ç­¾åå®Œå…¨ä¸€æ ·
+ æ‰€ä»¥éœ€è¦ä½¿ç”¨ï¼šæ³›å‹å’Œ`Trait Bound`

##### Fn Trait

+ `Fn traits`ç”±æ ‡å‡†åº“æä¾›
+ æ‰€æœ‰çš„é—­åŒ…éƒ½è‡³å°‘å®ç°äº†ä»¥ä¸‹`trait`ä¹‹ä¸€
  + `Fn`
  + `FnMut`
  + `FnOnce`

##### è§£å†³è¿åŠ¨è®¡åˆ’ä¾‹å­ä¸­çš„é—®é¢˜

ä»£ç ä¾ç„¶ä¸å¿…è¦åœ°å¤šæ¬¡è°ƒç”¨äº†è€—æ—¶çš„è®¡ç®—é—­åŒ…ã€‚è¿™ä¸ªé—®é¢˜çš„ä¸€ä¸ªè§£å†³æ–¹æ¡ˆæ˜¯å°†è€—æ—¶é—­åŒ…çš„ç»“æœå­˜å‚¨è‡³å˜é‡ä¸­ï¼Œå¹¶åœ¨éšåéœ€è¦ç»“æœçš„åœ°æ–¹ä½¿ç”¨è¯¥å˜é‡è€Œä¸æ˜¯ç»§ç»­è°ƒç”¨é—­åŒ…ã€‚ä½†éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ç§æ–¹æ³•å¯èƒ½ä¼šé€ æˆå¤§é‡çš„ä»£ç é‡å¤ã€‚

```rust
use std::thread;
use std::time::Duration;

struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    calculation: T,
    value: Option<u32>,
}

impl<T> Cacher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}

fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;
    generate_workout(simulated_user_specified_value, simulated_random_number)
}

fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_closure = Cacher::new(|num| {
        println!("calculating slowly ...");
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_closure.value(intensity));
        println!("Next, do {} situps!", expensive_closure.value(intensity));
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!("Today, run for {} minutes!", expensive_closure.value(intensity));
        }
    }
}
```

##### ä½¿ç”¨ç¼“å­˜å™¨ï¼ˆCacherï¼‰å®ç°çš„é™åˆ¶

+ Cacherå®ä¾‹å‡å®šé’ˆå¯¹ä¸åŒçš„å‚æ•°`arg`ï¼Œ`value`æ–¹æ³•æ€»ä¼šå¾—åˆ°åŒæ ·çš„å€¼

  ```rust
  #[cfg(test)]
  mod tests {
      #[test]
      fn call_with_different_values() {
          let mut c = super::Cacher::new(|a| a);
          let v1 = c.value(1);
          let v2 = c.value(2);
          assert_eq!(v2, 2);
      }
  }
  ```

  + å¯ä»¥ä½¿ç”¨`HashMap`ä»£æ›¿å•ä¸ªå€¼
    + key: argå‚æ•°
    + value: æ‰§è¡Œé—­åŒ…çš„ç»“æœ

+ åªèƒ½æ¥å—ä¸€ä¸ª`u32`ç±»å‹çš„å‚æ•°å’Œ`u32`ç±»å‹çš„è¿”å›å€¼

  + å°è¯•å¼•å…¥æ›´å¤šçš„æ³›å‹å‚æ•°

#### 13.1.4 ä½¿ç”¨é—­åŒ…æ¥æ•è·ä¸Šä¸‹æ–‡ç¯å¢ƒ

##### é—­åŒ…ä¼šæ•è·å…¶ç¯å¢ƒ

+ é—­åŒ…å¯ä»¥è®¿é—®å®šä¹‰å®ƒçš„ä½œç”¨åŸŸå†…çš„å˜é‡ï¼Œè€Œæ™®é€šå‡½æ•°åˆ™ä¸èƒ½

  ```rust
  fn main() {
  
      let x = 4;
  
      let equal_to_x = |z| z == x;
  
      fn equal_to_x(z: i32) -> bool {
          z == x  // can't capture dynamic environment in a fn item
      }
  
      let y = 4;
  
      assert!(equal_to_x(y));
  
  }
  ```

+ ä¼šäº§ç”Ÿå†…å­˜å¼€é”€

##### é—­åŒ…ä»æ‰€åœ¨ç¯å¢ƒæ•è·å€¼çš„æ–¹å¼

+ ä¸å‡½æ•°è·å¾—å‚æ•°çš„ä¸‰ç§æ–¹å¼ä¸€æ ·
  + è·å¾—æ‰€æœ‰æƒï¼š`FnOnce`
  + å¯å˜å€Ÿç”¨ï¼š`FnMut`
  + ä¸å¯å˜å€Ÿç”¨ï¼š`Fn`
+ åˆ›å»ºé—­åŒ…æ—¶ï¼Œé€šè¿‡é—­åŒ…å¯¹ç¯å¢ƒå€¼çš„ä½¿ç”¨ï¼ŒRustæ¨æ–­å‡ºå…·ä½“ä½¿ç”¨å“ªä¸ª`trait`
  + æ‰€æœ‰çš„é—­åŒ…éƒ½å®ç°äº†`FnOnce`
  + æ²¡æœ‰ç§»åŠ¨æ•è·å˜é‡çš„å®ç°äº†`FnMut`
  + æ— éœ€å¯å˜è®¿é—®æ•è·å˜é‡çš„é—­åŒ…å®ç°äº†`Fn`

##### moveå…³é”®å­—

+ åœ¨å‚æ•°åˆ—è¡¨å‰ä½¿ç”¨`move`å…³é”®å­—ï¼Œå¯ä»¥å¼ºåˆ¶é—­åŒ…å–å¾—å®ƒæ‰€ä½¿ç”¨çš„ç¯å¢ƒå€¼çš„æ‰€æœ‰æƒ

  + å½“å°†é—­åŒ…ä¼ é€’ç»™æ–°çº¿ç¨‹ä»¥ç§»åŠ¨æ•°æ®ä½¿å…¶å½’æ–°çº¿ç¨‹æ‰€æœ‰æ—¶ï¼Œæ­¤æŠ€æœ¯æœ€ä¸ºæœ‰ç”¨

  ```rust
  let x = vec![1, 2, 3];
  let equal_to_x = move |z| z == x;
  
  println!("can't use x here: {:?}", x);
  
  let y = vec![1, 2, 3];
  
  assert!(equal_to_x(y))
  ```

##### æœ€ä½³å®è·µ

+ å½“æŒ‡å®š`Fn trait bound`ä¹‹ä¸€æ—¶ï¼Œé¦–å…ˆç”¨`Fn`ï¼ŒåŸºäºé—­åŒ…ä½“é‡Œçš„æƒ…å†µï¼Œå¦‚æœéœ€è¦`FnOnce`æˆ–`FnMut`ï¼Œç¼–è¯‘å™¨ä¼šå†å‘Šè¯‰ä½ 



### 13.2 è¿­ä»£å™¨ï¼ˆiteratorï¼‰

è¿­ä»£å™¨æ¨¡å¼å…è®¸ä½ å¯¹ä¸€ä¸ªåºåˆ—çš„é¡¹è¿›è¡ŒæŸäº›å¤„ç†ã€‚**è¿­ä»£å™¨**ï¼ˆ*iterator*ï¼‰è´Ÿè´£éå†åºåˆ—ä¸­çš„æ¯ä¸€é¡¹å’Œå†³å®šåºåˆ—ä½•æ—¶ç»“æŸçš„é€»è¾‘ã€‚å½“ä½¿ç”¨è¿­ä»£å™¨æ—¶ï¼Œæˆ‘ä»¬æ— éœ€é‡æ–°å®ç°è¿™äº›é€»è¾‘ã€‚

åœ¨ Rust ä¸­ï¼Œè¿­ä»£å™¨æ˜¯ **æƒ°æ€§çš„**ï¼ˆ*lazy*ï¼‰ï¼Œè¿™æ„å‘³ç€åœ¨è°ƒç”¨æ–¹æ³•ä½¿ç”¨è¿­ä»£å™¨ä¹‹å‰å®ƒéƒ½ä¸ä¼šæœ‰æ•ˆæœã€‚

#### 13.2.1 ä»€ä¹ˆæ˜¯è¿­ä»£å™¨

+ è¿­ä»£å™¨æ¨¡å¼ï¼šå¯¹ä¸€ç³»åˆ—é¡¹æ‰§è¡ŒæŸäº›ä»»åŠ¡

+ è¿­ä»£å™¨è´Ÿè´£

  +  éå†æ¯ä¸ªé¡¹
  + ç¡®å®šåºåˆ—ï¼ˆéå†ï¼‰ä½•æ—¶å®Œæˆ

+ Rustçš„è¿­ä»£å™¨

  + æƒ°æ€§çš„ï¼ˆlazyï¼‰ï¼šé™¤éè°ƒç”¨æ¶ˆè´¹è¿­ä»£å™¨çš„æ–¹æ³•ï¼Œå¦åˆ™è¿­ä»£å™¨æœ¬èº«æ²¡æœ‰ä»»ä½•æ•ˆæœ

    ```rust
    let v1 = vec![1, 2, 3];
    let v1_iter = v1.iter();
    
    for val in v1_iter {
        println!("Got: {}", val);
    }
    ```

#### 13.2.2 Iterator traitå’Œnextæ–¹æ³•

##### Iterator trait

+ æ‰€æœ‰çš„è¿­ä»£å™¨éƒ½å®ç°äº†`Iterator trait`æ ‡å‡†åº“ï¼Œå®šä¹‰å¤§è‡´å¦‚ä¸‹ï¼š

  ```rust
  pub trait Iterator {
      type Item;
  
      fn next(&mut self) -> Option<Self::Item>;
  
      // è¿™é‡Œçœç•¥äº†ç”±Rustç»™å‡ºçš„é»˜è®¤å®ç°æ–¹æ³•
  
  }
  ```

+ `type Item`å’Œ`Self::Item`å®šä¹‰äº†ä¸è¯¥`trait`å…³è”çš„ç±»å‹

  + å®ç°`Iterator trait`éœ€è¦ä½ å®šä¹‰ä¸€ä¸ª`Item`ç±»å‹ï¼Œå®ƒç”¨äº`next`æ–¹æ³•çš„è¿”å›çš„ç±»å‹ï¼ˆè¿­ä»£å™¨çš„è¿”å›ç±»å‹ï¼‰

+ `Iterator trait`ä»…è¦æ±‚å®ç°ä¸€ä¸ªæ–¹æ³•ï¼š`next`

+ `next`

  + æ¯æ¬¡è¿”å›è¿­ä»£å™¨ä¸­çš„ä¸€é¡¹
  + è¿”å›ç»“æœåŒ…è£¹åœ¨`Some`é‡Œ
  + è¿­ä»£ç»“æŸï¼Œè¿”å›`None`

+ å¯ç›´æ¥åœ¨è¿­ä»£å™¨ä¸Šè°ƒç”¨`next`æ–¹æ³•

  ```rust
  let v1 = vec![1, 2, 3];
  let mut v1_iter = v1.iter();
  
  assert_eq!(v1_iter.next(), Some(&1));
  assert_eq!(v1_iter.next(), Some(&2));
  assert_eq!(v1_iter.next(), Some(&3));
  ```

##### å‡ ä¸ªè¿­ä»£æ–¹æ³•

+ `iter`æ–¹æ³•ï¼šåœ¨ä¸å¯å˜å¼•ç”¨ä¸Šåˆ›å»ºè¿­ä»£å™¨
+ `into_iter`æ–¹æ³•ï¼šåˆ›å»ºçˆ±çš„è¿­ä»£å™¨ä¼šè·å¾—æ‰€æœ‰æƒ
+ `iter_mut`æ–¹æ³•ï¼šè¿­ä»£å¯å˜çš„å¼•ç”¨

#### 13.2.3 æ¶ˆè€— / äº§ç”Ÿè¿­ä»£å™¨

##### æ¶ˆè€—è¿­ä»£å™¨çš„æ–¹æ³•

+ åœ¨æ ‡å‡†åº“ä¸­ï¼Œ`Iterator trait`æœ‰ä¸€äº›å¸¦é»˜è®¤å®ç°çš„æ–¹æ³•

+ å…¶ä¸­æœ‰ä¸€äº›æ–¹æ³•ä¼šè°ƒç”¨`next`æ–¹æ³•

  + å®ç°`Iterator trait`æ—¶å¿…é¡»å®ç°`next`æ–¹æ³•çš„åŸå› ä¹‹ä¸€

+ è°ƒç”¨`next`æ–¹æ³•çš„æ–¹æ³•å«åšâ€æ¶ˆè€—å‹é€‚é…å™¨â€œ

  + å› ä¸ºè°ƒç”¨å®ƒä»¬ä¼šæŠŠè¿­ä»£å™¨æ¶ˆè€—å°½

+ ä¾‹å¦‚ï¼š`sum`æ–¹æ³•ï¼ˆå°±ä¼šè€—å°½è¿­ä»£å™¨ï¼‰

  + ä¼šå–å¾—è¿­ä»£å™¨çš„æ‰€æœ‰æƒ
  + é€šè¿‡åå¤è°ƒç”¨`next`ï¼Œéå†æ‰€æœ‰å…ƒç´ 
  + æ¯æ¬¡è¿­ä»£ï¼ŒæŠŠå½“å‰å…ƒç´ æ·»åŠ åˆ°ä¸€ä¸ªæ€»å’Œé‡Œï¼Œè¿­ä»£ç»“æŸï¼Œè¿”å›æ€»å’Œ

  ```rust
  let v1 = vec![1, 2, 3];
      let v1_iter = v1.iter();
      let total: i32 = v1_iter.sum();
  
      assert_eq!(total, 6);
  ```

##### äº§ç”Ÿå…¶å®ƒè¿­ä»£å™¨çš„æ–¹æ³•

+ å®šä¹‰åœ¨`Iterator trait`ä¸Šçš„å¦å¤–ä¸€ç±»æ–¹æ³•å«åšâ€œè¿­ä»£å™¨é€‚é…å™¨â€

  + æŠŠè¿­ä»£å™¨è½¬æ¢ä¸ºä¸åŒç§ç±»çš„è¿­ä»£å™¨

+ å¯ä»¥é€šè¿‡é“¾å¼è°ƒç”¨ä½¿ç”¨å¤šä¸ªè¿­ä»£å™¨é€‚é…å™¨æ¥æ‰§è¡Œå¤æ‚çš„æ“ä½œï¼Œè¿™ç§è°ƒç”¨å¯è¯»æ€§è¾ƒé«˜

+ ä¾‹å¦‚ï¼š`map`

  + æ¥æ”¶ä¸€ä¸ªé—­åŒ…ï¼Œé—­åŒ…ä½œç”¨äºæ¯ä¸ªå…ƒç´ 
  + äº§ç”Ÿä¸€ä¸ªæ–°çš„è¿­ä»£å™¨

  ```rust
  let v1 = vec![1, 2, 3];
  let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();
  assert_eq!(v2, vec![2, 3, 4]);
  ```


#### 13.2.4 ä½¿ç”¨é—­åŒ…æ•è·ç¯å¢ƒ

+ `filter`æ–¹æ³•

  + æ¥å—ä¸€ä¸ªé—­åŒ…
  + è¿™ä¸ªé—­åŒ…åœ¨éå†è¿­ä»£å™¨çš„æ¯ä¸ªå…ƒç´ æ—¶ï¼Œè¿”å›`bool`ç±»å‹
  + å¦‚æœé—­åŒ…è¿”å›`true`ï¼šå½“å‰å…ƒç´ å°†ä¼šåŒ…å«åœ¨`filter`äº§ç”Ÿçš„è¿­ä»£å™¨ä¸­
  + å¦‚æœé—­åŒ…è¿”å›`false`ï¼šå½“å‰å…ƒç´ å°†ä¸ä¼šåŒ…å«åœ¨`filter`äº§ç”Ÿçš„è¿­ä»£å™¨ä¸­

  ```rust
  #[derive(PartialEq, Debug)]
  struct Shoe {
      size: u32,
      style: String,
  }
  
  fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
      shoes.into_iter().filter(|x| x.size == shoe_size).collect()
  }
  
  #[test]
  fn filter_by_size() {
      let shoes = vec![
          Shoe {
              size: 10,
              style: String::from("sneaker"),
          },
          Shoe {
              size: 13,
              style: String::from("sandal"),
          },
          Shoe {
              size: 10,
              style: String::from("boot"),
          },
      ];
      let in_my_size = shoes_in_my_size(shoes, 10);
  
      assert_eq!(
          in_my_size,
          vec![
              Shoe {
                  size: 10,
                  style: String::from("sneaker"),
              },
              Shoe {
                  size: 10,
                  style: String::from("boot"),
              },
          ]
      )
  }
  ```

#### 13.2.5 ä½¿ç”¨Iterator traitæ¥åˆ›å»ºè‡ªå®šä¹‰è¿­ä»£å™¨

+ å®ç°`next`æ–¹æ³•

  ```rust
  #[derive(Debug)]
  struct Counter {
      count: u32,
  }
  
  impl Counter {
      fn new() -> Counter {
          Counter { count: 0 }
      }
  }
  
  impl Iterator for Counter {
      type Item = u32;
  
      fn next(&mut self) -> Option<Self::Item> {
          if self.count < 5 {
              self.count += 1;
              Some(self.count)
          } else {
              None
          }
      }
  }
  
  #[test]
  fn calling_next_directly() {
      let mut counter = Counter::new();
  
      assert_eq!(counter.next(), Some(1));
      assert_eq!(counter.next(), Some(2));
      assert_eq!(counter.next(), Some(3));
      assert_eq!(counter.next(), Some(4));
      assert_eq!(counter.next(), Some(5));
      assert_eq!(counter.next(), None);
  }
  
  #[test]
  fn using_other_iterator_trait_methods() {
      // let sum: Vec<u32> = Counter::new()
      //     .zip(Counter::new().skip(1))
      //     .map(|(a, b)| a * b).collect();
          
      // println!("{:#?}", sum);
  
      let sum: u32 = Counter::new()
          .zip(Counter::new().skip(1))
          .map(|(a, b)| a * b)
          .filter(|x| x % 3 == 0)
          .sum();
          
      assert_eq!(18, sum);
  }
  ```
  



### 13.3 æ”¹è¿›I/Oé¡¹ç›®

#### 13.3.1 ä½¿ç”¨è¿­ä»£å™¨ä»£æ›¿clone

+ **src/lib.rs**

  ```rust
  impl Config {
      pub fn new(args: &[String]) -> Result<Config, &'static str> {
          if args.len() < 3 {
              return Err("not enough arguments");
          }
  
          let query = args[1].clone();
          let filename = args[2].clone();
  
          let case_sensitive = env::var("CASE_INSENSITIVE").is_err();
  
          Ok(Config { query, filename, case_sensitive })
      }
  }
  ```

  ```rust
  pub fn new(mut args: std::env::Args) -> Result<Config, &'static str> { 
      if args.len() < 3 {
          return Err("not enough arguments");
      }
      args.next();
      let query = match args.next() {
          Some(arg) => arg,
          None => return Err("Didn't get a query string"),
  
      };
      let filename = match args.next() {
          Some(arg) => arg,
          None => return Err("Didn't get a file name"),
  
      };
      let case_sensitive = env::var("CASE_INSENSITIVE").is_err();
      Ok(Config { query, filename, case_sensitive })
  }
  ```

+ **src/main.rs**

  ```rust
  fn main() {
  
      // let args: Vec<String> = env::args().collect();
  
      let config = Config::new(env::args()).unwrap_or_else(|err| {
          eprintln!("Problem parsing arguments: {}", err);
          process::exit(1);
      });
      if let Err(e) = minigrep::run(config) {
          eprintln!("Application error: {}", e);
          process::exit(1);
      }
  }
  ```

#### 13.3.2 ä½¿ç”¨è¿­ä»£å™¨é€‚é…å™¨è®©ä»£ç æ›´åŠ æ¸…æ™°

+ **src/lib.rs**

  ```rust
  pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
      let mut results = Vec::new();
  
      for line in contents.lines() {
          if line.contains(query) {
              results.push(line);
          }
      }
  
      results
  }
  ```

  ```rust
  pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
      contents.lines()
          .filter(|line| line.contains(query))
          .collect()
  }
  ```



### 13.4 æ€§èƒ½æ¯”è¾ƒï¼šå¾ªç¯ vs è¿­ä»£å™¨

#### 13.4.1 é›¶å¼€é”€æŠ½è±¡ï¼ˆZero-Cost Abstractionï¼‰

+ ä½¿ç”¨æŠ½è±¡æ—¶ï¼Œä¸ä¼šå¼•å…¥é¢å¤–çš„è¿è¡Œæ—¶å¼€é”€



## 14ã€è¿›ä¸€æ­¥è®¤è¯†CargoåŠcrates.io

### 14.1 ä½¿ç”¨å‘å¸ƒé…ç½®ï¼ˆrelease profileï¼‰æ¥å®šåˆ¶æ„å»º

#### 14.1.1 release profile

+ æ˜¯é¢„å®šä¹‰çš„
+ å¯è‡ªå®šä¹‰ï¼šå¯ä½¿ç”¨ä¸åŒçš„é…ç½®ï¼Œå¯¹ä»£ç ç¼–è¯‘æ‹¥æœ‰æ›´å¤šçš„æ§åˆ¶
+ æ¯ä¸ª`profile`çš„é…ç½®éƒ½ç‹¬ç«‹äºå…¶å®ƒçš„`profile`
+ `Cargo`ä¸»è¦çš„ä¸¤ä¸ª`profile`
  + `dev profile`ï¼šé€‚ç”¨äºå¼€å‘ï¼Œ`cargo build`
  + `release profile`ï¼šé€‚ç”¨äºå‘å¸ƒï¼Œ`cargo build --release`

#### 14.1.2 è‡ªå®šä¹‰profile

+ é’ˆå¯¹æ¯ä¸ª`profile`ï¼Œ`Cargo`éƒ½æä¾›äº†é»˜è®¤çš„é…ç½®

+ å¦‚æœæƒ³è‡ªå®šä¹‰`xxxx profile`çš„é…ç½®

  + å¯ä»¥åœ¨`Cargo.toml`é‡Œæ·»åŠ `[profile.xxxx]`åŒºåŸŸï¼Œåœ¨é‡Œé¢è¦†ç›–é»˜è®¤é…ç½®çš„å­é›†

  ```toml
  [profile.dev]
  opt-level = 1
  
  [profile.release]
  opt-level = 3
  ```

  é€‰é¡¹`opt-level`å†³å®šäº†Ruståœ¨ç¼–è¯‘æ—¶ä¼šå¯¹ä»£ç æ‰§è¡Œä½•ç§ç¨‹åº¦çš„ä¼˜åŒ–ï¼Œä»0åˆ°3éƒ½æ˜¯åˆæ³•çš„é…ç½®å€¼ã€‚è¿™æ®µé…ç½®è¦†ç›–äº†å¯¹åº”é€‰é¡¹çš„é»˜è®¤å€¼0ã€‚å½“ä½ å†æ¬¡è¿è¡Œ`cargo build`æ—¶ï¼Œ`Cargo`ä¼šä½¿ç”¨æˆ‘ä»¬æŒ‡å®šçš„`opt-level`å€¼å¹¶åœ¨å…¶ä»–é€‰é¡¹ä¸Šä¿æŒ`dev`çš„é»˜è®¤é…ç½®ã€‚å°†`opt-level`è®¾ç½®ä¸º1ä¼šè®©`Cargo`æ¯”åœ¨é»˜è®¤é…ç½®ä¸‹å¤šæ‰§è¡Œä¸€äº›ä¼˜åŒ–ï¼Œä½†ä»ç„¶æ²¡æœ‰å‘å¸ƒæ—¶ä½¿ç”¨çš„ä¼˜åŒ–é‚£ä¹ˆå¤šã€‚

  å¯¹äºæ¯ä¸ªé€‰é¡¹çš„é»˜è®¤å€¼å’Œå®Œæ•´é€‰é¡¹ï¼Œè¯¦è§ï¼šhttps://doc.rust-lang.org/cargo/reference/profiles.html



### 14.2 å°†åŒ…å‘å¸ƒåˆ°crates.ioä¸Š

#### 14.2.1 crates.io

+ å¯ä»¥é€šè¿‡å‘å¸ƒåŒ…æ¥å…±äº«ä½ çš„ä»£ç 
+ `crate`çš„æ³¨å†Œè¡¨åœ¨ https://crates.io
  + å®ƒä¼šåˆ†å‘å·²æ³¨å†Œçš„åŒ…çš„æºä»£ç 
  + ä¸»è¦æ‰˜ç®¡å¼€æºçš„ä»£ç 

#### 14.2.2 æ–‡æ¡£æ³¨é‡Š

+ æ–‡æ¡£æ³¨é‡Šï¼šç”¨äºç”Ÿæˆæ–‡æ¡£

  + ç”ŸæˆHTMLæ–‡æ¡£
  + æ˜¾å¼å…¬å…±APIçš„æ–‡æ¡£æ³¨é‡Šï¼šå¦‚ä½•ä½¿ç”¨API
  + ä½¿ç”¨`///`
  + æ”¯æŒMarkdown
  + æ”¾ç½®åœ¨è¢«è¯´æ˜æ¡ç›®ä¹‹å‰

  ```rust
  /// Adds one to the number given
  ///
  /// # Examples
  ///
  /// ```
  /// let arg = 5;
  /// let answer = cargo_crates_demo::add_one(arg);
  ///
  /// assert_eq!(6, answer);
  ///
  pub fn add_one(x: i32) -> i32 {
    x + 1
  }
  ```

##### ç”ŸæˆHTMLæ–‡æ¡£çš„å‘½ä»¤

+ `cargo doc`
  + å®ƒä¼šè¿è¡Œ`rustdoc`å·¥å…·ï¼ˆrustå®‰è£…åŒ…è‡ªå¸¦ï¼‰
  + æŠŠç”Ÿæˆçš„HTMLæ–‡æ¡£æ”¾åœ¨`target/doc`ç›®å½•ä¸‹
+ `cargo doc --open`
  + æ„å»ºå½“å‰`crate`çš„æ–‡æ¡£ï¼ˆä¹ŸåŒ…å«crateä¾èµ–é¡¹çš„æ–‡æ¡£ï¼‰
  + åœ¨æµè§ˆå™¨æ‰“å¼€æ–‡æ¡£

##### å¸¸ç”¨æ–‡æ¡£æ³¨é‡ŠåŒºåŸŸ

+ `#Examples`
+ å…¶å®ƒå¸¸ç”¨åŒºåŸŸ
  + `Panics`ï¼šå‡½æ•°å¯èƒ½å‘ç”Ÿ`panic`çš„åœºæ™¯
  + `Errors`ï¼šå¦‚æœå‡½æ•°è¿”å›`Result`ï¼Œæè¿°å¯èƒ½çš„é”™è¯¯ç§ç±»ï¼Œä»¥åŠå¯èƒ½å¯¼è‡´é”™è¯¯çš„æ¡ä»¶
  + `Safety`ï¼šå¦‚æœå‡½æ•°å¤„äº`unsafe`è°ƒç”¨ï¼Œå°±åº”è¯¥è§£é‡Šå‡½æ•°`unsafe`çš„åŸå› ï¼Œä»¥åŠè°ƒç”¨è€…ç¡®ä¿çš„ä½¿ç”¨å‰æ

##### æ–‡æ¡£æ³¨é‡Šä½œä¸ºæµ‹è¯•

+ ç¤ºä¾‹ä»£ç å—çš„é™„åŠ å€¼
  + è¿è¡Œ`cargo test`ï¼šå°†æŠŠæ–‡æ¡£æ³¨é‡Šä¸­çš„ç¤ºä¾‹ä»£ç ä½œä¸ºæµ‹è¯•æ¥è¿è¡Œ

##### ä¸ºåŒ…å«æ³¨é‡Šçš„é¡¹æ·»åŠ æ–‡æ¡£æ³¨é‡Š

+ ç¬¦å·ï¼š`//!`

+ è¿™ç±»æ³¨é‡Šé€šå¸¸ç”¨äºæè¿°`crate`å’Œæ¨¡å—

  + `crate root`ï¼ˆæŒ‰æƒ¯ä¾‹ src / lib.rsï¼‰
  + ä¸€ä¸ªæ¨¡å—å†…ï¼Œå°†`crate`æˆ–æ¨¡å—ä½œä¸ºä¸€ä¸ªæ•´ä½“è¿›è¡Œè®°å½•

  ```rust
  //! # cargo_crates_demo
  //!
  //! cargo_crates_demoæ˜¯ä¸€ç³»åˆ—å·¥å…·çš„é›†åˆï¼Œ
  //! è¿™äº›å·¥å…·è¢«ç”¨æ¥ç®€åŒ–ç‰¹å®šçš„è®¡ç®—æ“ä½œ
  
  /// Adds one to the number given
  ///
  /// # Examples
  ///
  /// ```
  /// let arg = 5;
  /// let answer = cargo_crates_demo::add_one(arg);
  ///
  /// assert_eq!(6, answer);
  ///
  pub fn add_one(x: i32) -> i32 {
    x + 1
  }
  ```

  ![rustdoc](./assets/rustdoc.png)

#### 14.2.3 ä½¿ç”¨ pub use å¯¼å‡ºæ–¹ä¾¿ä½¿ç”¨çš„å…¬å…± API

+ é—®é¢˜ï¼š`crate`çš„ç¨‹åºç»“æ„åœ¨å¼€å‘æ—¶å¯¹äºå¼€å‘è€…å¾ˆåˆç†ï¼Œä½†å¯¹äºå®ƒçš„ä½¿ç”¨è€…ä¸å¤Ÿæ–¹ä¾¿

  + å¼€å‘è€…ä¼šæŠŠç¨‹åºç»“æ„åˆ†ä¸ºå¾ˆå¤šå±‚ï¼Œä½¿ç”¨è€…æƒ³æ‰¾åˆ°è¿™ç§æ·±å±‚ç»“æ„ä¸­çš„æŸä¸ªç±»å‹å¾ˆè´¹åŠ²

+ ä¾‹å¦‚ï¼š

  + éº»çƒ¦ï¼š`my_crate::some_module::another_module::UsefulType`
  + æ–¹ä¾¿ï¼š`my_crate::UsefulType`

+ è§£å†³åŠæ³•ï¼š

  + ä¸éœ€è¦é‡æ–°ç»„ç»‡å†…éƒ¨ä»£ç ç»“æ„
  + ä½¿ç”¨`pub use`ï¼šå¯ä»¥é‡æ–°å¯¼å‡ºï¼Œåˆ›å»ºä¸€ä¸ªä¸å†…éƒ¨ç§æœ‰ç»“æ„ä¸åŒçš„å¯¹å¤–å…¬å…±ç»“æ„

  **src/lib.sr**

  ```rust
  pub use self::kinds::PrimaryColor;
  pub use self::kinds::SecondaryColor;
  pub use self::utils::mix;
  
  pub mod kinds {
      pub enum PrimaryColor {
          Red,
          Yellow,
          Blue,
      }
  
      pub enum SecondaryColor {
          Orange,
          Green,
          Purple,
      }
  }
  
  pub mod utils {
      use crate::kinds::*;
  
      pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
          SecondaryColor::Green
      }
  }
  ```

  **src/main.rs**

  ```rust
  // use cargo_crates_demo::kinds::PrimaryColor;
  // use cargo_crates_demo::utils::mix;
  use cargo_crates_demo::PrimaryColor;
  use cargo_crates_demo::mix;
  
  fn main() {
      let red = PrimaryColor::Red;
      let yellow = PrimaryColor::Yellow;
      mix(red, yellow);
  }
  
  ```

#### 14.2.4 åˆ›å»ºå¹¶è®¾ç½® Crates.io è´¦å·

+ å‘å¸ƒ`crate`å‰ï¼Œéœ€è¦åœ¨`crates.io`åˆ›å»ºè´¦å·å¹¶è·å–`API token`
+ è¿è¡Œå‘½ä»¤ï¼š`cargo login [API token]
  + é€šçŸ¥`cargo`ï¼Œä½ çš„`API token`å­˜å‚¨åœ¨æœ¬åœ°`~/.cargo/credentials`
+ `API token`å¯ä»¥åœ¨ https://crates.io è¿›è¡Œæ’¤é”€

#### 14.2.5 ä¸ºæ–°çš„ crate æ·»åŠ å…ƒæ•°æ®

+ åœ¨å‘å¸ƒ`crate`ä¹‹å‰ï¼Œéœ€è¦åœ¨`Cargo.toml`çš„[package]åŒºåŸŸä¸º`crate`æ·»åŠ ä¸€äº›å…ƒæ•°æ®
  + nameï¼š`crate`éœ€è¦å”¯ä¸€çš„åç§°
  + descriptionï¼šä¸€ä¸¤å¥è¯å³å¯ï¼Œä¼šå‡ºç°åœ¨`crate`æœç´¢çš„ç»“æœé‡Œ
  + licenseï¼šéœ€è¦æä¾›è®¸å¯è¯æ ‡è¯†å€¼ï¼ˆå¯åˆ° http://spdx.org/licenses æŸ¥æ‰¾ï¼‰
    + å¯æŒ‡å®šå¤šä¸ª licenseï¼šç”¨ OR
  + version
  + author
+ å‘å¸ƒï¼š`cargo publish`

#### 14.2.6 å‘å¸ƒåˆ° Crates.io

+ `crate`ä¸€æ—¦å‘å¸ƒï¼Œå°±æ˜¯æ°¸ä¹…æ€§çš„ï¼šè¯¥ç‰ˆæœ¬æ— æ³•è¦†ç›–ï¼Œä»£ç æ— æ³•åˆ é™¤
  + ç›®çš„ï¼šä¾èµ–äºè¯¥ç‰ˆæœ¬çš„é¡¹ç›®å¯ç»§ç»­æ­£å¸¸å·¥ä½œ

#### 14.2.7 å‘å¸ƒå·²å­˜åœ¨ crate çš„æ–°ç‰ˆæœ¬

+ ä¿®æ”¹`crate`åï¼Œéœ€è¦å…ˆä¿®æ”¹`Cargo.toml`é‡Œé¢çš„ version å€¼ï¼Œå†è¿›è¡Œé‡æ–°å‘å¸ƒ
+ å‚ç…§ http://semver.org æ¥ä½¿ç”¨ä½ çš„è¯­ä¹‰ç‰ˆæœ¬
+ å†æ‰§è¡Œ`cargo publish`è¿›è¡Œå‘å¸ƒ

#### 14.2.8 ä½¿ç”¨ cargo yank ä» Crates.io æ’¤å›ç‰ˆæœ¬

+ ä¸å¯ä»¥åˆ é™¤`crate`ä¹‹å‰çš„ç‰ˆæœ¬
+ ä½†å¯ä»¥é˜²æ­¢å…¶å®ƒé¡¹ç›®æŠŠå®ƒä½œä¸ºæ–°çš„ä¾èµ–ï¼š`yank`ï¼ˆæ’¤å›ï¼‰ä¸€ä¸ª`crate`ç‰ˆæœ¬
  + é˜²æ­¢æ–°é¡¹ç›®ä¾èµ–äºè¯¥ç‰ˆæœ¬
  + å·²ç»å­˜åœ¨é¡¹ç›®å¯ç»§ç»­å°†å…¶ä½œä¸ºä¾èµ–ï¼ˆå¹¶å¯ä¸‹è½½ï¼‰
+ `yank`æ„å‘³ç€
  + æ‰€æœ‰å·²ç»äº§ç”Ÿ`Cargo.lock`çš„é¡¹ç›®éƒ½ä¸ä¼šä¸­æ–­
  + ä»»ä½•å°†æ¥ç”Ÿæˆçš„`Cargo.lock`æ–‡ä»¶éƒ½ä¸ä¼šä½¿ç”¨è¢«`yank`çš„ç‰ˆæœ¬
+ å‘½ä»¤
  + `yank`ä¸€ä¸ªç‰ˆæœ¬ï¼ˆä¸ä¼šåˆ é™¤ä»»ä½•ä»£ç ï¼‰ï¼š`cargo yank --vers 1.0.1`
  + å–æ¶ˆ`yank`ï¼š`cargo yank --vers 1.0.1 --undo`



### 14.3 Cargo å·¥ä½œç©ºé—´ï¼ˆWorkspaceï¼‰

+ `Cargo`å·¥ä½œç©ºé—´ï¼šå¸®åŠ©ç®¡ç†å¤šä¸ªç›¸äº’å…³è”ä¸”éœ€è¦ååŒå¼€å‘çš„`crate`
+ `Cargo`å·¥ä½œç©ºé—´æ˜¯ä¸€å¥—å…±äº«åŒä¸€ä¸ª`Cargo.lock`å’Œè¾“å‡ºæ–‡ä»¶å¤¹çš„åŒ…

#### 14.3.1 åˆ›å»ºå·¥ä½œç©ºé—´

+ æœ‰å¤šç§æ–¹å¼æ¥ç»„å»ºå·¥ä½œç©ºé—´ï¼šä¾‹ï¼š1 ä¸ªäºŒè¿›åˆ¶`crate`ï¼Œ2 ä¸ªåº“`crate`
  + äºŒè¿›åˆ¶`crate`ï¼š`main`å‡½æ•°ï¼Œä¾èµ–äºå…¶å®ƒ 2 ä¸ªåº“`crate`
  + å…¶ä¸­ 1 ä¸ªåº“`crate`æä¾›`add_one`å‡½æ•°
  + å¦å¤– 1 ä¸ªåº“`crate`æä¾›`add_two`å‡½æ•°

1. åˆ›å»ºå·¥ä½œç©ºé—´ç›®å½• addï¼Œæ·»åŠ `Cargo.toml`

   ```shell
   mkdir add
   cd add
   touch Cargo.toml && echo '[workspace]
   members = [
       "adder",
   ]' > Cargo.toml
   ```

2. åˆ›å»ºäºŒè¿›åˆ¶åŒ…ï¼šadder

   `cargo new addr`

#### 14.3.2 åœ¨å·¥ä½œç©ºé—´ä¸­åˆ›å»ºç¬¬äºŒä¸ªåŒ…

1. å‘æ ¹ç›®å½•ä¸‹çš„`Cargo.toml`æ–‡ä»¶æ·»åŠ `add-one`è·¯å¾„

   ```toml
   [workspace]
   members = [
       "adder",
       "add-one",
   ]
   ```

2. ç”Ÿæˆä¸€ä¸ªåä¸º add-one çš„æ–°ä»£ç åŒ…

   `cargo new add-one --lib`

   æ­¤æ—¶ï¼Œ*add* ç›®å½•ä¸‹åº”è¯¥æœ‰å¦‚ä¸‹æ‰€ç¤ºçš„ç›®å½•å’Œæ–‡ä»¶ï¼š

   ```shell
   â”œâ”€â”€ Cargo.lock
   â”œâ”€â”€ Cargo.toml
   â”œâ”€â”€ add-one
   â”‚   â”œâ”€â”€ Cargo.toml
   â”‚   â””â”€â”€ src
   â”‚       â””â”€â”€ lib.rs
   â”œâ”€â”€ adder
   â”‚   â”œâ”€â”€ Cargo.toml
   â”‚   â””â”€â”€ src
   â”‚       â””â”€â”€ main.rs
   â””â”€â”€ target
   ```

3. åœ¨*add-one/src/lib.rs* æ–‡ä»¶ä¸­æ·»åŠ ä¸€ä¸ªadd_oneå‡½æ•°å¹¶è°ƒç”¨ï¼š

   ###### add-one/src/lib.rs

   ```rust
   pub fn add_one(x: i32) -> i32 {
        x + 1
   }
   ```

   åˆ›å»ºå¥½æ–°çš„ä»£ç åŒ…åï¼Œæˆ‘ä»¬å¯ä»¥è®©äºŒè¿›åˆ¶åŒ…adderä¾èµ–äºä»£ç åŒ…add-oneã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åœ¨adder/Cargo.toml ä¸­æ·»åŠ add-oneçš„è·¯å¾„ä½œä¸ºä¾èµ–ï¼š

   ###### adder/Cargo.toml

   ```toml
   [dependencies]
   add-one = { path = "../add-one" }
   ```

   ä¿®æ”¹mainå‡½æ•°æ¥è°ƒç”¨add_oneå‡½æ•°ï¼Œå¦‚ç¤ºä¾‹14-7æ‰€ç¤ºã€‚

   ###### adder/src/main.rs

   ```rust
   use add_one;
   
   fn main() {
       let num = 10;
       println!("Hello, world! {} plus one is {}!", num, add_one::add_one(num));
   }
   ```

   åœ¨add æ ¹ç›®å½•ä¸‹è¿è¡Œcargo buildæ¥æ„å»ºæ•´ä¸ªå·¥ä½œç©ºé—´ï¼š

   ```shell
   $ cargo build
   
      Compiling add-one v0.1.0 (file:///projects/add/add-one)
      Compiling adder v0.1.0 (file:///projects/add/adder)
       Finished dev [unoptimized + debuginfo] target(s) in 0.68 secs
   ```

   ä¸ºäº†åœ¨add æ ¹ç›®å½•ä¸‹è¿è¡ŒäºŒè¿›åˆ¶åŒ…ï¼Œæˆ‘ä»¬éœ€è¦åœ¨è°ƒç”¨cargo runæ—¶é€šè¿‡-på‚æ•°æ¥æŒ‡å®šéœ€è¦è¿è¡Œçš„åŒ…åï¼š

   ```shell
   $ cargo run -p adder
   
       Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
        Running `target/debug/adder`
   Hello, world! 10 plus one is 11!
   ```

   ä¸Šé¢çš„å‘½ä»¤è¿è¡Œäº†adder/src/main.rs ä¸­çš„ä»£ç ï¼Œè€Œè¿™æ®µä»£ç åˆ™ä¾èµ–äº†add-oneåŒ…ã€‚

#### 14.3.3 åœ¨å·¥ä½œç©ºé—´ä¸­ä¾èµ–å¤–éƒ¨ crate

+ å·¥ä½œç©ºé—´åªæœ‰ä¸€ä¸ª`Cargo.lock`æ–‡ä»¶ï¼Œåœ¨å·¥ä½œç©ºé—´çš„é¡¶å±‚ç›®å½•

  + ä¿è¯å·¥ä½œç©ºé—´å†…æ‰€æœ‰`crate`ä½¿ç”¨çš„ä¾èµ–çš„ç‰ˆæœ¬éƒ½ç›¸åŒ
  + å·¥ä½œç©ºé—´å†…æ‰€æœ‰`crate`ç›¸äº’å…¼å®¹

+ **add-one/Cargo.toml**

  ```toml
  [dependencies]
  rand = "0.8.2"
  ```

+ **adder/Cargo.toml**

  ```toml
  [dependencies]
  rand = "0.8.1"
  ```

+ **add/Cargo.lock**

  ```lock
  [[package]]
  name = "rand"
  version = "0.8.5"
  source = "registry+https://github.com/rust-lang/crates.io-index"
  checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
  dependencies = [
   "libc",
   "rand_chacha",
   "rand_core",
  ]
  ```

#### 14.3.4 è¿è¡Œä»£ç æµ‹è¯•

+ åœ¨ *add* æ ¹ç›®å½•ä¸‹æ‰§è¡Œ`cargo test`å‘½ä»¤ï¼Œä¼šä¸€æ¬¡æ€§æ‰§è¡Œå·¥ä½œç©ºé—´ä¸­æ‰€æœ‰åŒ…çš„æµ‹è¯•ã€‚

+ æˆ‘ä»¬åŒæ ·å¯ä»¥åœ¨å·¥ä½œç©ºé—´æ ¹ç›®å½•ä¸‹ï¼Œä½¿ç”¨å‚æ•°-påŠæŒ‡å®šçš„åŒ…åç§°æ¥è¿è¡ŒæŸä¸€ä¸ªç‰¹å®šåŒ…çš„æµ‹è¯•ï¼Œä¾‹ï¼š`cargo test -p add-one`




### 14.4 ä» crates.io å®‰è£…äºŒè¿›åˆ¶ crate

+ å‘½ä»¤ï¼š`cargo install`
+ æ¥æºï¼šhttps://crates.io
+ é™åˆ¶ï¼šåªèƒ½å®‰è£…å…·æœ‰äºŒè¿›åˆ¶ç›®æ ‡ï¼ˆbinary targetï¼‰çš„`crate`
+ äºŒè¿›åˆ¶ç›®æ ‡`binary target`ï¼šæ˜¯ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åº
  + ç”±æ‹¥æœ‰`src/main.rs`æˆ–å…¶å®ƒè¢«æŒ‡å®šä¸ºäºŒè¿›åˆ¶æ–‡ä»¶çš„`crate`ç”Ÿæˆ
+ é€šå¸¸ï¼šREADMEé‡Œæœ‰å…³äº`crate`çš„æè¿°
  + æ˜¯å¦æ‹¥æœ‰`library target`
  + æ˜¯å¦æ‹¥æœ‰`binary target`
  + ä¸¤è€…å…¼å¤‡

#### 14.4.1 cargo install

+ `cargo install`å®‰è£…çš„äºŒè¿›åˆ¶`crate`å­˜æ”¾åœ¨æ ¹ç›®å½•çš„`bin`æ–‡ä»¶å¤¹
+ å¦‚æœä½ ç”¨`rustup`å®‰è£…çš„Rustï¼Œæ²¡æœ‰ä»»ä½•è‡ªå®šä¹‰çš„é…ç½®ï¼Œé‚£ä¹ˆäºŒè¿›åˆ¶`crate`å­˜æ”¾çš„ç›®å½•æ˜¯`$HOME/.cargo/bin`
  + è¦ç¡®ä¿è¯¥ç›®å½•åœ¨ç¯å¢ƒå˜é‡`$PATH`ä¸­

#### 14.4.2 ä½¿ç”¨è‡ªå®šä¹‰å‘½ä»¤æ‰©å±• cargo

+ `Cargo`è¢«è®¾è®¡æˆå¯ä»¥ä½¿ç”¨å­å‘½ä»¤æ¥æ‰©å±•
+ å¦‚æœä½ çš„$PATHè·¯å¾„ä¸­å­˜åœ¨äºŒè¿›åˆ¶æ–‡ä»¶cargo-somethingï¼Œå°±å¯ä»¥é€šè¿‡è¿è¡Œ`cargo something`æ¥è¿è¡Œè¯¥äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå°±å¥½åƒå®ƒæ˜¯`Cargo`çš„å­å‘½ä»¤ä¸€æ ·
+ ç±»ä¼¼è¿™æ ·çš„è‡ªå®šä¹‰å‘½ä»¤å¯ä»¥é€šè¿‡`cargo --list`å‘½ä»¤åˆ—å‡º
+ ä¼˜ç‚¹ï¼šå¯ä½¿ç”¨`cargo install`æ¥å®‰è£…æ‰©å±•ï¼Œå¹¶æƒ³å†…ç½®å·¥å…·ä¸€æ ·æ¥è¿è¡Œ



## 15ã€æ™ºèƒ½æŒ‡é’ˆ

### ç›¸å…³æ¦‚å¿µ

#### æŒ‡é’ˆå’Œå¼•ç”¨

+ æŒ‡é’ˆï¼šä¸€ä¸ªå˜é‡åœ¨å†…å­˜ä¸­åŒ…å«çš„æ˜¯ä¸€ä¸ªåœ°å€ï¼ˆæŒ‡å‘å…¶å®ƒæ•°æ®ï¼‰
+ Rustä¸­æœ€å¸¸è§çš„æŒ‡é’ˆå°±æ˜¯â€œå¼•ç”¨â€
+ å¼•ç”¨
  + ä½¿ç”¨`&`
  + å€Ÿç”¨å®ƒæŒ‡å‘çš„å€¼
  + æ²¡æœ‰å…¶ä½™å¼€é”€
  + æœ€å¸¸è§çš„æŒ‡é’ˆç±»å‹

#### æ™ºèƒ½æŒ‡é’ˆ

+ æ™ºèƒ½æŒ‡é’ˆæ˜¯è¿™æ ·çš„ä¸€å†™æ•°æ®ç»“æ„
  + è¡Œä¸ºå’ŒæŒ‡é’ˆç›¸ä¼¼
  + æœ‰é¢å¤–çš„å…ƒæ•°æ®å’ŒåŠŸèƒ½

#### å¼•ç”¨è®¡æ•°ï¼ˆreference countingï¼‰æ™ºèƒ½æŒ‡é’ˆç±»å‹

+ é€šè¿‡è®°å½•æ‰€æœ‰è€…çš„æ•°é‡ï¼Œä½¿ä¸€ä»½æ•°æ®è¢«å¤šä¸ªæ‰€æœ‰è€…åŒæ—¶æŒæœ‰
+ å¹¶åœ¨æ²¡æœ‰ä»»ä½•æ‰€æœ‰è€…æ—¶è‡ªåŠ¨æ¸…ç†æ•°æ®

#### å¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆçš„å…¶å®ƒä¸åŒ

+ å¼•ç”¨ï¼šåªå€Ÿç”¨æ•°æ®
+ æ™ºèƒ½æŒ‡é’ˆï¼šå¾ˆå¤šæ—¶å€™éƒ½æ‹¥æœ‰å®ƒæ‰€æŒ‡å‘çš„æ•°æ®

#### æ™ºèƒ½æŒ‡é’ˆçš„ä¾‹å­

+ `String`å’Œ`Vec<T>`
+ éƒ½æ‹¥æœ‰ä¸€ç‰‡å†…å­˜åŒºåŸŸï¼Œä¸”å…è®¸ç”¨æˆ·å¯¹å…¶è¿›è¡Œæ“ä½œ
+ éƒ½æ‹¥æœ‰å…ƒæ•°æ®ï¼ˆä¾‹å¦‚å®¹é‡ç­‰ï¼‰
+ æä¾›é¢å¤–çš„åŠŸèƒ½æˆ–ä¿éšœï¼ˆ`String`ä¿éšœå…¶æ•°æ®æ˜¯åˆæ³•çš„ UTF-8 ç¼–ç ï¼‰

#### æ™ºèƒ½æŒ‡é’ˆçš„å®ç°

+ æ™ºèƒ½æŒ‡é’ˆé€šå¸¸ä½¿ç”¨`struct`å®ç°ï¼Œå¹¶ä¸”å®ç°äº†
  + `Deref`å’Œ`Drop`è¿™ä¸¤ä¸ª`trait`
+ `Deref trait`ï¼šå…è®¸æ™ºèƒ½æŒ‡é’ˆ`struct`çš„å®ä¾‹åƒå¼•ç”¨ä¸€æ ·ä½¿ç”¨
+ `Drop trait`ï¼šå…è®¸ä½ è‡ªå®šä¹‰å½“æ™ºèƒ½æŒ‡é’ˆå®ä¾‹èµ°å‡ºä½œç”¨åŸŸæ—¶çš„ä»£ç 



### 15.1 ä½¿ç”¨ Box\<T> æ¥æŒ‡å‘ Heap ä¸Šçš„æ•°æ®

#### 15.1.1 Box\<T>

+ `Box<T>` æ˜¯æœ€ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆ
  + å…è®¸ä½ åœ¨`heap`ä¸Šå­˜å‚¨æ•°æ®ï¼ˆè€Œä¸æ˜¯`stack`ï¼‰
  + `stack`ä¸Šæ˜¯æŒ‡å‘`heap`æ•°æ®çš„æŒ‡é’ˆ
  + æ²¡æœ‰æ€§èƒ½å¼€é”€
  + æ²¡æœ‰å…¶å®ƒé¢å¤–çš„åŠŸèƒ½
  + å®ç°äº†`Deref trait`å’Œ`Drop trait`

##### Box\<T> çš„ä½¿ç”¨åœºæ™¯

+ åœ¨ç¼–è¯‘æ—¶ï¼ŒæŸç±»å‹çš„å¤§å°æ— æ³•ç¡®å®šï¼Œä½†ä½¿ç”¨è¯¥ç±»å‹æ—¶ï¼Œä¸Šä¸‹æ–‡å´éœ€è¦çŸ¥é“å®ƒçš„ç¡®åˆ‡å¤§å°
+ å½“ä½ æœ‰å¤§é‡æ•°æ®ï¼Œæƒ³ç§»äº¤æ‰€æœ‰æƒï¼Œä½†éœ€è¦ç¡®ä¿åœ¨æ“ä½œæ—¶æ•°æ®ä¸ä¼šè¢«å¤åˆ¶
+ ä½¿ç”¨æŸä¸ªå€¼æ—¶ï¼Œä½ åªå…³å¿ƒå®ƒæ˜¯å¦å®ç°äº†ç‰¹å®šçš„`trait`ï¼Œè€Œä¸å…³å¿ƒå®ƒçš„å…·ä½“ç±»å‹

#### 15.1.2 ä½¿ç”¨ Box\<T> åœ¨å †ä¸Šå­˜å‚¨æ•°æ®

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

#### 15.1.3 ä½¿ç”¨ Box èµ‹èƒ½é€’å½’ç±»å‹

+ åœ¨ç¼–è¯‘æ—¶ï¼ŒRust éœ€è¦çŸ¥é“ä¸€ä¸ªç±»å‹æ‰€å çš„ç©ºé—´å¤§å°
+ è€Œé€’å½’ç±»å‹çš„å¤§å°æ— æ³•åœ¨ç¼–è¯‘æ—¶ç¡®å®š
+ Box ç±»å‹å¯ä»¥ç¡®å®šå…¶å¤§å°

##### ä¸€ä¸ªé€’å½’ç±»å‹ï¼šé“¾æ¥åˆ—è¡¨ï¼ˆCons Listï¼‰

+ `Cons List`æ˜¯æ¥è‡ª Lisp è¯­è¨€çš„ä¸€ç§æ•°æ®ç»“æ„
+ `Cons List`é‡Œæ¯ä¸ªæˆå‘˜ç”±ä¸¤ä¸ªå…ƒç´ ç»„æˆ
  + å½“å‰é¡¹çš„å€¼
  + ä¸‹ä¸€å…ƒç´ 
+ `Cons List`é‡Œæœ€åä¸€ä¸ªæˆå‘˜åªåŒ…å«ä¸€ä¸ª`Nil`å€¼ï¼Œæ²¡æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ 

##### Cons List å¹¶ä¸æ˜¯ Rust çš„å¸¸ç”¨é›†åˆ

+ é€šå¸¸æƒ…å†µä¸‹ï¼Œ`Vec<T>`æ˜¯æ›´å¥½çš„é€‰æ‹©

+ åˆ›å»ºä¸€ä¸ª`Cons List`

  ```rust
  enum List {
      Cons(i32, List),
      Nil,
  }
  fn main() {
      use crate::List::{Cons, Nil};
  	let list = Cons(1, Cons(2, Cons(3, Nil())));
  }
  ```

  ```rust
    --> src/main.rs:11:1
     |
  11 | enum List {
     | ^^^^^^^^^ recursive type has infinite size
  12 |     Cons(i32, List),
     |               ---- recursive without indirection
     |
  help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` representable
     |
  12 |     Cons(i32, Box<List>),
     |               ++++    +
  
  Some errors have detailed explanations: E0072, E0425.
  For more information about an error, try `rustc --explain E0072`.
  ```

  ![recursive](./assets/recursive.png)

  ç¼–è¯‘å™¨ä¼šé¦–å…ˆæ£€æŸ¥`Cons`å˜ä½“ï¼Œå¹¶å‘ç°å®ƒæŒæœ‰ä¸€ä¸ªi32ç±»å‹çš„å€¼åŠå¦å¤–ä¸€ä¸ª`List`ç±»å‹çš„å€¼ã€‚å› æ­¤ï¼Œ`Cons`å˜ä½“éœ€è¦çš„ç©ºé—´ä¹Ÿå°±ç­‰äºä¸€ä¸ª`i32`å€¼çš„å¤§å°åŠ ä¸Šä¸€ä¸ªListå€¼çš„å¤§å°ã€‚ä¸ºäº†ç¡®å®šListå€¼æ‰€éœ€çš„ç©ºé—´å¤§å°ï¼Œç¼–è¯‘å™¨åˆä¼šä»`Cons`å¼€å§‹éå†å…¶ä¸‹çš„æ‰€æœ‰å˜ä½“ï¼Œè¿™æ ·çš„æ£€æŸ¥è¿‡ç¨‹å°†æ°¸æ— ç©·å°½åœ°è¿›è¡Œä¸‹å»

+ Rust å¦‚ä½•ç¡®å®šä¸ºæšä¸¾åˆ†é…çš„ç©ºé—´å¤§å°

  ```rust
  enum Message {
      Quit,
      Move {x: i32, y: i32},
      Write(String),
      ChangeColor(i32, i32, i32),
  }
  ```

  ä¸ºäº†è®¡ç®—å‡ºMessageå€¼éœ€è¦å¤šå¤§çš„å­˜å‚¨ç©ºé—´ï¼ŒRustä¼šéå†æšä¸¾ä¸­çš„æ¯ä¸€ä¸ªæˆå‘˜æ¥æ‰¾åˆ°éœ€è¦æœ€å¤§ç©ºé—´çš„é‚£ä¸ªå˜ä½“ã€‚åœ¨Rustçœ¼ä¸­ï¼Œ`Message::Quit`ä¸éœ€è¦å ç”¨ä»»ä½•ç©ºé—´ï¼Œ`Message::Move`éœ€è¦ä¸¤ä¸ªå­˜å‚¨`i32`å€¼çš„ç©ºé—´ï¼Œä»¥æ­¤ç±»æ¨ã€‚å› ä¸ºåœ¨æ¯ä¸ªæ—¶é—´ç‚¹åªä¼šæœ‰ä¸€ä¸ªå˜ä½“å­˜åœ¨ï¼Œæ‰€ä»¥Messageå€¼éœ€è¦çš„ç©ºé—´å¤§å°ä¹Ÿå°±æ˜¯èƒ½å¤Ÿå­˜å‚¨å¾—ä¸‹æœ€å¤§å˜ä½“çš„ç©ºé—´å¤§å°ã€‚

##### ä½¿ç”¨ Box æ¥è·å¾—ç¡®å®šå¤§å°çš„é€’å½’ç±»å‹

+ `Box<T>`æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒRust çŸ¥é“å®ƒéœ€è¦å¤šå°‘ç©ºé—´

  + æŒ‡é’ˆçš„å¤§å°ä¸ä¼šåŸºäºå®ƒæŒ‡å‘çš„æ•°æ®çš„å¤§å°å˜åŒ–è€Œå˜åŒ–

  ![box](./assets/box.png)

+ `Box<T>`

  + åªæä¾›äº†â€œé—´æ¥â€å­˜å‚¨å’Œ`heap`å†…å­˜åˆ†é…çš„åŠŸèƒ½
  + æ²¡æœ‰å…¶å®ƒé¢å¤–åŠŸèƒ½
  + æ²¡æœ‰æ€§èƒ½å¼€é”€
  + é€‚ç”¨äºéœ€è¦â€œé—´æ¥â€å­˜å‚¨çš„åœºæ™¯ï¼Œä¾‹å¦‚`Cons List`
  + å®ç°äº†`Deref trait`å’Œ`Drop trait`



### 15.2 é€šè¿‡Deref traitå°†æ™ºèƒ½æŒ‡é’ˆè§†ä½œå¸¸è§„å¼•ç”¨

#### 15.2.1 Deref Trait

+ å®ç°`Deref Trait`ä½¿æˆ‘ä»¬å¯ä»¥è‡ªå®šä¹‰è§£å¼•ç”¨è¿ç®—ç¬¦`*`çš„è¡Œä¸º
+ é€šè¿‡å®ç°`Deref`ï¼Œæ™ºèƒ½æŒ‡é’ˆå¯ä»¥åƒå¸¸è§„å¼•ç”¨ä¸€æ ·æ¥å¤„ç†

#### 15.2.2 è§£å¼•ç”¨è¿ç®—ç¬¦ *

+ å¸¸è§„å¼•ç”¨æ˜¯ä¸€ç§æŒ‡é’ˆ

  ```rust
  fn main() {
      let x = 5;
      let y = &x;
  
      assert_eq!(5, x);
      assert_eq!(5, *y);
  }
  ```

#### 15.2.3 æŠŠ Box\<T> å½“åšå¼•ç”¨

+ `Box<T>`å¯ä»¥ä»£æ›¿ä¸Šä¾‹ä¸­çš„å¼•ç”¨

  ```rust
  fn main() {
      let x = 5;
      let y = Box::new(x);
  
      assert_eq!(5, x);
      assert_eq!(5, *y);
  }
  ```

#### 15.2.4 å®šä¹‰è‡ªå·±çš„æ™ºèƒ½æŒ‡é’ˆ

+ `Box<T>`è¢«å®šä¹‰ä¸ºæ‹¥æœ‰ä¸€ä¸ªå…ƒç´ çš„`tuple struct`

  ```rust
  struct MyBox<T>(T);
  
  impl<T> MyBox<T> {
      fn new(x:T) -> MyBox<T> {
          MyBox(x)
      }
  }
  
  let x = 5;
  let y = MyBox::new(x);
  assert_eq!(5, x);
  assert_eq!(5, *y); // type `MyBox<{integer}>` cannot be dereferenced
  ```

#### 15.2.5 å®ç° Deref Trait

+ æ ‡å‡†åº“ä¸­çš„`Deref trait`è¦æ±‚æˆ‘ä»¬å®ç°ä¸€ä¸ª`deref`æ–¹æ³•

  + è¯¥æ–¹æ³•å€Ÿç”¨`self`
  + è¿”å›ä¸€ä¸ªæŒ‡å‘å†…éƒ¨æ•°æ®çš„å¼•ç”¨

  ```rust
  use std::ops::Deref;
  
  struct MyBox<T>(T);
  
  impl<T> MyBox<T> {
      fn new(x:T) -> MyBox<T> {
          MyBox(x)
      }
  }
  
  impl<T> Deref for MyBox<T> {
      type Target = T;
  
      fn deref(&self) -> &T {
          &self.0
      }
  }
  
  let x = 5;
  let y = MyBox::new(x);
  assert_eq!(5, x);
  assert_eq!(5, *y); // *y <==> *(y.der)
  ```

  







