# Rust

## 1ã€å…¥é—¨æŒ‡å—

```rust
println!("hello world") // æ‰“å°æ–‡æœ¬
```

+ rustçš„ç¼©è¿›æ˜¯4ä¸ªç©ºæ ¼ï¼Œè€Œä¸æ˜¯tab
+ println!æ˜¯ä¸€ä¸ªrust macroï¼Œå¦‚æœæ˜¯å‡½æ•°çš„è¯ï¼Œå°±æ²¡æœ‰!
+ rustæ–‡ä»¶å‘½åè§„åˆ™ä¸ºä¸‹åˆ’çº¿å‘½åæ³•
+ cargo build [--release]
  + ç¼–è¯‘rustæºä»£ç å¹¶ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Œ--releaseä¼šåœ¨ç¼–è¯‘æ—¶å¯¹ä»£ç è¿›è¡Œä¼˜åŒ–
+ cargo check
  + æ£€æŸ¥ä»£ç ï¼Œç¡®ä¿ä»£ç å¯ä»¥é€šè¿‡ç¼–è¯‘ï¼Œä½†æ˜¯ä¸ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶
+ cargo run
  + ç¼–è¯‘rustæºä»£ç å¹¶æ‰§è¡Œå¯æ‰§è¡Œæ–‡ä»¶ï¼Œå¦‚æœå·²ç»å¯¹æºä»£ç è¿›è¡Œè¿‡ç¼–è¯‘ä¸”æ²¡æœ‰å¯¹æºä»£ç è¿›è¡Œä¿®æ”¹ï¼Œè¿™ä¼šç›´æ¥è·³è¿‡ç¼–è¯‘ï¼Œæ‰§è¡Œå¯æ‰§è¡Œæ–‡ä»¶

## 2ã€çŒœæ•°æ¸¸æˆ

```rust
use rand::Rng;
use std::io; // trait
             // use rand::thread_rng;
use std::cmp::Ordering;

fn main() {
    println!("çŒœæ•°ï¼");
    let secret_number = rand::thread_rng().gen_range(1..101); // i32 u32 i64 u64
    println!("ç¥ç§˜æ•°å­—æ˜¯ï¼š{}", secret_number);

    loop {
        println!("çŒœæµ‹ä¸€ä¸ªæ•°");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess).expect("æ— æ³•è¯»å–è¡Œ");

        // shadow
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("ä½ çŒœæµ‹çš„æ•°æ˜¯ï¼š{}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small"), // arm
            Ordering::Greater => println!("Too large"),
            Ordering::Equal => {
                println!("You win");
                break;
            }
        }
    }
}

```



+ ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œrustä¼šå°†preludeæ¨¡å—å¯¼å…¥åˆ°æ¯ä¸€ä¸ªç¨‹åºçš„ä½œç”¨åŸŸä¸­
+ ä½¿ç”¨useå…³é”®å­—å¯¼å…¥éœ€è¦çš„åº“ï¼Œä¾‹å¦‚ï¼š`use std::io;`
+ letå…³é”®å­—ç”¨æ¥å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œä½†æ˜¯è¿™ä¸ªå˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼Œå¦‚æœæƒ³è¦ä¿®æ”¹è¿™ä¸ªå˜é‡ï¼Œéœ€è¦åœ¨letåé¢åŠ ä¸Š`mut`ï¼ˆmutableï¼‰å…³é”®å­—ï¼Œä¾‹å¦‚ï¼š`let mut a = 1;`
+ String::new()å°†è¿”å›ä¸€ä¸ªç©ºç™½çš„å­—ç¬¦ä¸²ï¼Œnew()æ˜¯Stringç±»å‹çš„å…³è”å‡½æ•°ï¼Œç±»ä¼¼äºJavaä¸­çš„é™æ€æ–¹æ³•
+ io::stdin()å°†è¿”å›ä¸€ä¸ªStdinç±»å‹çš„å®ä¾‹ï¼Œè¯¥å®ä¾‹ä¼šè¢«ç”¨ä½œå¥æŸ„ï¼ˆhandleï¼‰ç”¨æ¥å¤„ç†ç»ˆç«¯ä¸­çš„è¾“å…¥
+ `&mut`è¡¨ç¤ºè·å–guessçš„å¼•ç”¨ï¼Œrustä¸­å¼•ç”¨é»˜è®¤åŒæ ·æ˜¯ä¸å¯å˜å¾—ï¼Œå› æ­¤åŒæ ·éœ€è¦åŠ ä¸Šmut
+ read_lineæ–¹æ³•ä¼šè¿”å›io::Result\<usize\>ç±»å‹ï¼Œè¿™ä¸ªç±»å‹æ˜¯ä¸€ä¸ªenumsç±»å‹ï¼Œå…¶å…±æœ‰ä¸¤ä¸ªå€¼ï¼šOkã€Errï¼Œå½“ç¨‹åºå‘ç”Ÿå¼‚å¸¸æ—¶ï¼Œä¼šè°ƒç”¨expectæ–¹æ³•ï¼Œå¹¶å°†å…¶ä¸­çš„å­—ç¬¦ä¸²æ˜¾ç¤ºç»™ç”¨æˆ·
+ rand::Rngæ˜¯ä¸€ä¸ª`trait`ï¼Œç±»ä¼¼äºJavaä¸­çš„æ¥å£ï¼Œé€šè¿‡rand::thread_rng()è¿”å›Rngçš„å®ç°ThreadRngç±»å‹
+ matchè¡¨è¾¾å¼å¯ä»¥é€šè¿‡guess.cmp()è¿”å›çš„Orderingç±»å‹ï¼ˆenumsç±»å‹ï¼‰çš„å€¼æ¥å†³å®šä¸‹ä¸€æ­¥æ‰§è¡Œçš„åˆ†æ”¯ï¼ˆarmï¼‰ï¼Œå› æ­¤ä¹Ÿå¸¸è¢«ç”¨ä½œå¤„ç†å¯èƒ½ä¼šå‘ç”Ÿçš„å¼‚å¸¸çš„æ‰‹æ®µ
+ loopè¡¨è¾¾å¼è¡¨ç¤ºæ— é™å¾ªç¯ï¼Œä¸è¦ä½¿ç”¨while trueæ¥å®ç°æ— é™å¾ªç¯ï¼Œwhileå¾ªç¯ä¾§é‡äºwhile conditionï¼Œè€Œä¸æ˜¯ç›´æ¥çš„while trueï¼Œè¿™æ›´ç¬¦åˆwhileçš„è¯­ä¹‰
+ Err(\_)ï¼Œ\_ä¸ºé€šé…ç¬¦ï¼Œå› ä¸ºè¿™é‡Œä¸éœ€è¦é”™è¯¯ä¿¡æ¯ï¼Œå› æ­¤ä½¿ç”¨é€šé…ç¬¦è¡¨ç¤º

## 3ã€é€šç”¨ç¼–ç¨‹æ¦‚å¿µ

### 3.1 å˜é‡ä¸å¯å˜æ€§

```rust
const MAX_POINTS: u32 = 100_000;
println!("The maximum number of {}", MAX_POINTS);

let mut x = 5;
println!("The value of x is {}", x);

x = 6;
println!("The value of x is {}", x);

let y = 5;
let y = y + 1;
let y = y * 2;
println!("The value of y is {}", y);

let spaces = "        ";
let spaces = spaces.len();
println!("{}", spaces);
```



#### 3.1.1 å˜é‡

+ å£°æ˜å˜é‡ä½¿ç”¨`let`å…³é”®å­—
+ é»˜è®¤æƒ…å†µä¸‹ï¼Œå˜é‡æ˜¯ä¸å¯å˜çš„ï¼ˆImmutableï¼‰
+ å£°æ˜å˜é‡æ—¶ï¼Œåœ¨å˜é‡å‰åŠ ä¸Š`mut`ï¼ˆmutableï¼‰å…³é”®å­—ï¼Œå°±å¯ä»¥ä½¿å˜é‡å¯å˜

#### 3.1.2 å¸¸é‡ï¼ˆconstantï¼‰

+ å¸¸é‡åœ¨ç»‘å®šå€¼ä¹‹åä¹Ÿæ˜¯ä¸å¯å˜çš„ï¼Œä½†æ˜¯å®ƒä¸ä¸å¯å˜çš„å˜é‡æœ‰å¾ˆå¤šåŒºåˆ«ï¼š
  + å¸¸é‡ä¸å¯ä»¥ä½¿ç”¨`mut`å…³é”®å­—ä¿®é¥°ï¼Œå¸¸é‡æ°¸è¿œéƒ½æ˜¯ä¸å¯å˜çš„
  + å£°æ˜å¸¸é‡ä½¿ç”¨`const`å…³é”®å­—ï¼Œå…¶ç±»å‹å¿…é¡»è¢«æ ‡æ³¨
  + å¸¸é‡å¯ä»¥åœ¨ä»»ä½•ä½œç”¨åŸŸå†…è¿›è¡Œå£°æ˜ï¼ŒåŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸ
  + å¸¸é‡åªå¯ä»¥ç»‘å®šåˆ°å¸¸é‡è¡¨è¾¾å¼ï¼Œæ— æ³•ç»‘å®šåˆ°å‡½æ•°çš„è°ƒç”¨ç»“æœæˆ–åªèƒ½åœ¨è¿è¡Œæ—¶æ‰èƒ½è®¡ç®—å‡ºçš„å€¼
+ åœ¨ç¨‹åºè¿è¡ŒæœŸé—´ï¼Œå¸¸é‡åœ¨å…¶å£°æ˜çš„ä½œç”¨åŸŸå†…ä¸€ç›´æœ‰æ•ˆ
+ Rustä¸­å¸¸é‡ä½¿ç”¨å…¨å¤§å†™å­—æ¯ï¼Œæ¯ä¸ªå•è¯ä¹‹é—´ç”¨ä¸‹åˆ’çº¿åˆ†å¼€
+ ä¾‹å­ï¼š`const MAX_POINTS : u32 = 100_000;`

#### 3.1.3 éšè—ï¼ˆshadowingï¼‰

+ å¯ä»¥ä½¿ç”¨ç›¸åŒçš„åå­—å£°æ˜æ–°çš„å˜é‡ï¼Œæ–°çš„å˜é‡å°±ä¼šshadowï¼ˆéšè—ï¼‰ä¹‹å‰å£°æ˜çš„åŒåå˜é‡
+ shadowå’ŒæŠŠå˜é‡æ ‡è®°ä¸º`mut`æ˜¯ä¸ä¸€æ ·çš„ï¼š
  + å¦‚æœä¸ä½¿ç”¨`let `å…³é”®å­—ï¼Œé‚£ä¹ˆé‡æ–°ç»™é`mut`çš„å˜é‡èµ‹å€¼ä¼šå¯¼è‡´ç¼–è¯‘æ—¶é”™è¯¯
  + è€Œä½¿ç”¨`let`å£°æ˜çš„åŒåæ–°å˜é‡ï¼Œä¹Ÿæ˜¯ä¸å¯å˜çš„
  + ä½¿ç”¨`let`å£°æ˜çš„åŒåæ–°å˜é‡ï¼Œå…¶ç±»å‹å¯ä»¥ä¸ä¹‹å‰çš„ä¸åŒ



### 3.2 æ•°æ®ç±»å‹

#### 3.2.1 æ ‡é‡ç±»å‹

> ä¸€ä¸ªæ ‡é‡ç±»å‹ä»£è¡¨ä¸€ä¸ªå•ä¸ªçš„å€¼

> Rustæœ‰å››ä¸ªä¸»è¦çš„æ ‡é‡ç±»å‹ï¼š
>
> + æ•´æ•°ç±»å‹
> + æµ®ç‚¹ç±»å‹
> + å¸ƒå°”ç±»å‹
> + å­—ç¬¦ç±»å‹

+ **æ•´æ•°ç±»å‹**

  + æ•´æ•°ç±»å‹æ²¡æœ‰å°æ•°éƒ¨åˆ†

  + ä¾‹å¦‚u32å°±æ˜¯ä¸€ä¸ªæ— ç¬¦å·çš„æ•´æ•°ç±»å‹ï¼Œå æ®32ä½çš„ç©ºé—´

  + æ— ç¬¦å·æ•´æ•°ç±»å‹ä»¥uå¼€å¤´

  + æœ‰ç¬¦å·æ•´æ•°ç±»å‹ä»¥iå¼€å¤´

  + Rustçš„æ•´æ•°ç±»å‹åˆ—è¡¨å¦‚ä¸‹ï¼š

    | Length  | Signed  | Unsigned |
    | ------- | ------- | -------- |
    | 8-bit   | `i8`    | `u8`     |
    | 16-bit  | `i16`   | `u16`    |
    | 32-bit  | `i32`   | `u32`    |
    | 64-bit  | `i64`   | `u64`    |
    | 128-bit | `i128`  | `u128`   |
    | arch    | `isize` | `usize`  |

  + isizeå’Œusizeç±»å‹

    + isizeå’Œusizeç±»å‹çš„ä½æ•°ç”±ç¨‹åºè¿è¡Œçš„è®¡ç®—æœºçš„æ¶æ„æ‰€å†³å®šï¼šå¦‚æœæ˜¯64ä½çš„è®¡ç®—æœºï¼Œé‚£å°±æ˜¯64ä½çš„
    + ä½¿ç”¨isizeå’Œusizeçš„ä¸»è¦åœºæ™¯æ˜¯å¯¹æŸç§é›†åˆè¿›è¡Œç´¢å¼•æ“ä½œ

  + æ•´æ•°å­—é¢å€¼

    | Number Literals               | Example       |
    | ----------------------------- | ------------- |
    | Decimal (åè¿›åˆ¶)              | `98_222`      |
    | Hex (åå…­è¿›åˆ¶)                | `0xff`        |
    | Octal (å…«è¿›åˆ¶)                | `0o77`        |
    | Binary (äºŒè¿›åˆ¶)               | `0b1111_0000` |
    | Byte (å•å­—èŠ‚å­—ç¬¦)(ä»…é™äº`u8`) | `b'A'`        |

    + é™¤äº†byteç±»å‹å¤–ï¼Œæ‰€æœ‰çš„æ•°å€¼å­—é¢å€¼éƒ½å…è®¸ä½¿ç”¨ç±»å‹åç¼€ï¼šä¾‹å¦‚ 57u8
    + å¦‚æœä½ ä¸å¤ªæ¸…æ¥šåº”è¯¥ä½¿ç”¨å“ªç§ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨Rustå“åº”çš„é»˜è®¤ç±»å‹
    + æ•´æ•°çš„é»˜è®¤ç±»å‹å°±æ˜¯i32ï¼šæ€»ä½“ä¸Šæ¥è¯´i32çš„é€Ÿåº¦å¾ˆå¿«ï¼Œå³ä½¿åœ¨64ä½ç³»ç»Ÿä¸­

  + æ•´æ•°æº¢å‡º

    + ä¾‹å¦‚ï¼šu8çš„èŒƒå›´æ˜¯0-255ï¼Œå¦‚æœæŠŠä¸€ä¸ªu8å˜é‡çš„å€¼è®¾ä¸º256ï¼Œé‚£ä¹ˆï¼š
      + è°ƒè¯•æ¨¡å¼ä¸‹ç¼–è¯‘ï¼šRustä¼šæ£€æŸ¥æ•´æ•°æº¢å‡ºï¼Œå¦‚æœå‘ç”Ÿæº¢å‡ºï¼Œç¨‹åºåœ¨è¿è¡Œæ—¶å°±ä¼španic
      + å‘å¸ƒæ¨¡å¼ä¸‹ï¼ˆ--releaseï¼‰ç¼–è¯‘ï¼šRustä¸ä¼šæ£€æŸ¥å¯èƒ½å¯¼è‡´panicçš„æ•´æ•°æº¢å‡º
        + å¦‚æœå‘ç”Ÿæº¢å‡ºï¼šRustä¼šæ‰§è¡Œâ€œç¯ç»•â€æ“ä½œï¼š256å˜æˆ0ï¼Œ257å˜æˆ1...

  ```rust
  let guess: u32 = "42".parse().expect("Not a number");
  println!("{}", guess);
  ```

+ **æµ®ç‚¹ç±»å‹**
  + Rustæœ‰ä¸¤ç§åŸºç¡€çš„æµ®ç‚¹ç±»å‹ï¼Œä¹Ÿå°±æ˜¯å«æœ‰å°æ•°éƒ¨åˆ†çš„ç±»å‹
    + f32ï¼Œ32ä½ï¼Œå•ç²¾åº¦
    + f64ï¼Œ64ä½ï¼ŒåŒç²¾åº¦
    
  + Rustçš„æµ®ç‚¹ç±»å‹ä½¿ç”¨äº†IEEE-754æ ‡å‡†æ¥è¡¨è¿°
  
  + f64æ˜¯é»˜è®¤ç±»å‹ï¼Œå› ä¸ºåœ¨ç°ä»£CPUä¸Šf64å’Œf32çš„é€Ÿåº¦å·®ä¸å¤šï¼Œè€Œä¸”ç²¾åº¦æ›´é«˜
  
    ```rust
    let x = 2.0;
    let y: f32 = 3.0;
    ```

+ æ•°å€¼æ“ä½œ
  + åŠ å‡ä¹˜é™¤ä½™

+ **å¸ƒå°”ç±»å‹**
  + Rustå¸ƒå°”ç±»å‹ä¹Ÿæœ‰ä¸¤ä¸ªå€¼ï¼štrueå’Œfalse
  
  + ä¸€ä¸ªå­—èŠ‚å¤§å°
  
  + ç¬¦å·æ˜¯`bool`
  
    ```rust
    let t = true;
    let f: bool = false;
    ```

+ **å­—ç¬¦ç±»å‹**
  + Rustä¸­å›½charç±»å‹è¢«ç”¨æ¥æè¿°è¯­è¨€ä¸­æœ€åŸºç¡€çš„å•ä¸ªå­—ç¬¦
  
  + å­—ç¬¦ç±»å‹çš„å­—é¢å€¼ä½¿ç”¨å•å¼•å·
  
  + å ç”¨4ä¸ªå­—èŠ‚å¤§å°
  
  + æ˜¯Unicodeæ ‡é‡å€¼ï¼Œå¯ä»¥è¡¨ç¤ºæ¯”ASCIIå¤šå¾—å¤šçš„å­—ç¬¦å†…å®¹ï¼šæ‹¼éŸ³ã€ä¸­æ—¥éŸ©æ–‡ã€é›¶é•¿åº¦ç©ºç™½å­—ç¬¦ã€emojiè¡¨æƒ…ç­‰
    + U+0000åˆ°U+D7FF
    + U+E000åˆ°U+10FFFF
    
  + ä½†æ˜¯Unicodeä¸­å¹¶æ²¡æœ‰â€œå­—ç¬¦â€çš„æ¦‚å¿µï¼Œæ‰€ä»¥ç›´æ¥ä¸Šè®¤è¯†çš„å­—ç¬¦ä¹Ÿè®¸ä¸Rustä¸­çš„æ¦‚å¿µå¹¶ä¸ç›¸ç¬¦
  
    ```rust
    let x = 'x';
    let y: char = 'å';
    let z = 'ğŸ˜‚';
    ```

#### 3.2.2 å¤åˆç±»å‹

+ å¤åˆç±»å‹å¯ä»¥å°†å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹é‡Œ

+ Rustæä¾›äº†ä¸¤ç§åŸºç¡€çš„å¤åˆç±»å‹ï¼šå…ƒç»„ï¼ˆTupleï¼‰ã€æ•°ç»„

+ **Tuple**
  + Tupleå¯ä»¥å°†å¤šä¸ªç±»å‹çš„å¤šä¸ªå€¼æ”¾åœ¨åŒä¸€ä¸ªç±»å‹é‡Œ
  
  + Tupleçš„é•¿åº¦æ˜¯å›ºå®šçš„ï¼šä¸€æ—¦å£°æ˜å°±æ— æ³•æ”¹å˜
  
  + åˆ›å»ºTuple
    + åœ¨å°æ‹¬å·é‡Œï¼Œå°†å€¼ç”¨é€—å·åˆ†å¼€
    + Tupleä¸­çš„æ¯ä¸ªä½ç½®éƒ½å¯¹åº”ä¸€ä¸ªç±»å‹ï¼ŒTupleä¸­å„å…ƒç´ çš„ç±»å‹ä¸å¿…ç›¸åŒ
    
  + è·å–Tupleçš„å…ƒç´ å€¼
    + å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥è§£æ„ï¼ˆ*destructuring*ï¼‰ä¸€ä¸ªTupleæ¥è·å–å…ƒç´ çš„å€¼
    
  + è®¿é—®Tupleçš„å…ƒç´ 
    + åœ¨Tupleå˜é‡ä½¿ç”¨ç‚¹æ ‡è®°æ³•ï¼Œåæ¥å…ƒç´ çš„ç´¢å¼•å·
    
  + ä¸å¸¦ä»»ä½•å€¼çš„å…ƒç»„æœ‰ä¸ªç‰¹æ®Šçš„åç§°ï¼Œå«åš **å•å…ƒï¼ˆunitï¼‰** å…ƒç»„ã€‚è¿™ç§å€¼ä»¥åŠå¯¹åº”çš„ç±»å‹éƒ½å†™ä½œ `()`ï¼Œè¡¨ç¤ºç©ºå€¼æˆ–ç©ºçš„è¿”å›ç±»å‹ã€‚å¦‚æœè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å…¶ä»–å€¼ï¼Œåˆ™ä¼šéšå¼è¿”å›å•å…ƒå€¼
  
  ```rust
  let tup: (i32, f64, u8) = (500, 6.3, 1);
  
  let (x, y, z) = tup;
  println!("{}, {}, {}", x, y, z);
  
  println!("{}, {}, {}", tup.0, tup.1, tup.2);
  ```
  
+ **æ•°ç»„**
  + æ•°ç»„ä¹Ÿå¯ä»¥å°†å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹é‡Œ
  
  + æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ çš„ç±»å‹å¿…é¡»ç›¸åŒ
  
  + æ•°ç»„çš„é•¿åº¦ä¹Ÿæ˜¯å›ºå®šçš„
  
  + å£°æ˜ä¸€ä¸ªæ•°ç»„
    + åœ¨ä¸­æ‹¬å·é‡Œï¼Œå„å€¼ç”¨é€—å·åˆ†å¼€
    
  + æ•°ç»„çš„ç”¨å¤„
    + å¦‚æœæƒ³è®©ä½ çš„æ•°æ®å­˜æ”¾åœ¨stackï¼ˆæ ˆï¼‰ä¸Šè€Œä¸æ˜¯heapï¼ˆå †ï¼‰ä¸Šï¼Œæˆ–è€…æƒ³ä¿è¯æœ‰å›ºå®šæ•°é‡çš„å…ƒç´ ï¼Œè¿™æ—¶ä½¿ç”¨æ•°ç»„æ›´æœ‰å¥½å¤„
    
  + æ•°ç»„æ²¡æœ‰Vectorçµæ´»
    + Vectorå’Œæ•°ç»„ç±»ä¼¼ï¼Œå®ƒç”±æ ‡å‡†åº“æä¾›
    + Vectorçš„é•¿åº¦å¯ä»¥æ”¹å˜
    + å¦‚æœä½ ä¸ç¡®å®šåº”è¯¥ç”¨æ•°ç»„è¿˜æ˜¯Vectorï¼Œé‚£ä¹ˆä¼°è®¡ä½ åº”è¯¥ç”¨Vector
    
  + æ•°ç»„çš„ç±»å‹
    + æ•°ç»„çš„ç±»å‹ä»¥è¿™ç§å½¢å¼è¡¨ç¤ºï¼š[ç±»å‹; é•¿åº¦]ï¼Œä¾‹å¦‚ï¼š `let a: [i32; 5] = [1, 2, 3, 4, 5];`
    
  + å¦ä¸€ç§å£°æ˜æ•°ç»„çš„æ–¹æ³•
    + å¦‚æœæ•°ç»„çš„æ¯ä¸ªå…ƒç´ å€¼éƒ½ç›¸åŒï¼Œé‚£ä¹ˆå¯ä»¥åœ¨ï¼š
      + åœ¨ä¸­æ‹¬å·é‡ŒæŒ‡å®šåˆå§‹å€¼
      + ç„¶åæ˜¯ä¸€ä¸ª â€œ ; â€
      + æœ€åæ˜¯æ•°ç»„çš„é•¿åº¦
      + ä¾‹å¦‚ï¼š`let a = [3; 5];`å®ƒå°±ç›¸å½“äºï¼š`let a = [3, 3, 3, 3, 3]`
    
  + è®¿é—®æ•°ç»„çš„å…ƒç´ 
    + æ•°ç»„æ˜¯åœ¨Stackä¸Šåˆ†é…çš„å•ä¸ªå—çš„å†…å­˜
    + å¯ä»¥ä½¿ç”¨ç´¢å¼•æ¥è®¿é—®æ•°ç»„çš„å…ƒç´ 
    + å¦‚æœè®¿é—®çš„ç´¢å¼•è¶…å‡ºäº†æ•°ç»„ç´¢å¼•çš„èŒƒå›´ï¼Œé‚£ä¹ˆï¼š
      + cargo checkä¼šé€šè¿‡
      + ç¼–è¯‘è¿è¡Œæ—¶ä¼šæŠ¥é”™ï¼ˆindex out of boundsï¼‰ï¼ŒRustä¸ä¼šå…è®¸å…¶ç»§ç»­è®¿é—®ç›¸åº”åœ°å€çš„å†…å­˜
    
    ```rust
    let a = [1, 2, 3, 4, 5];
    let b: [i32; 5] = [1, 2, 3, 4, 5];
    let c = [3; 5];
    
    let first = a[0];
    let second = a[1];
    let third = a[27]; // index out of bounds
    ```
    
    

### 3.3 å‡½æ•°ä¸æ³¨é‡Š

#### 3.3.1 å‡½æ•°

+ å£°æ˜å‡½æ•°ä½¿ç”¨`fn`å…³é”®å­—

+ é’ˆå¯¹å‡½æ•°å’Œå˜é‡åï¼ŒRustä½¿ç”¨snake caseå‘½åè§„èŒƒï¼šæ‰€æœ‰çš„å­—æ¯éƒ½æ˜¯å°å†™çš„ï¼Œå•è¯ä¹‹é—´ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†å¼€

+ **å‡½æ•°çš„å‚æ•°**
  + parametersã€arguments
  
  + åœ¨å‡½æ•°ç­¾åé‡Œï¼Œå¿…é¡»å£°æ˜æ¯ä¸ªå‚æ•°çš„ç±»å‹
  
    ```rust
    fn another_function(x: i32, y: i32) {
        println!("Another function!");
        println!("the value of x and y is: {}, {}", x, y);
    }
    ```

+ **å‡½æ•°ä½“ä¸­çš„è¯­å¥ä¸è¡¨è¾¾å¼**
  + å‡½æ•°ä½“ç”±ä¸€ç³»åˆ—è¯­å¥ç»„æˆï¼Œå¯é€‰çš„æœ‰ä¸€ä¸ªè¡¨è¾¾å¼ç»“æŸ
  
  + Rustæ˜¯ä¸€ä¸ªåŸºäºè¡¨è¾¾å¼çš„è¯­è¨€
  
  + è¯­å¥æ˜¯æ‰§è¡Œä¸€äº›åŠ¨ä½œçš„æŒ‡ä»¤
  
  + è¡¨è¾¾å¼ä¼šè®¡ç®—äº§ç”Ÿä¸€ä¸ªå€¼
  
  + å‡½æ•°çš„å®šä¹‰ä¹Ÿæ˜¯è¯­å¥
  
  + è¯­å¥ä¸è¿”å›å€¼ï¼Œæ‰€ä»¥ä¸å¯ä»¥ä½¿ç”¨`let`å°†è¯­å¥èµ‹å€¼ ç»™ä¸€ä¸ªå˜é‡
  
    ```rust
    // let x = (let y = 6); // expected expression, found statement (`let`)
    
    let y = {
        let x = 1;
        x + 3
    };
    ```

+ å‡½æ•°çš„è¿”å›å€¼
  + åœ¨ `->`ç¬¦å·åé¢å£°æ˜å‡½æ•°è¿”å›å€¼çš„ç±»å‹ï¼Œä½†æ˜¯ä¸å¯ä»¥ä¸ºè¿”å›å€¼å‘½å
  
  + åœ¨Rustä¸­ï¼Œè¿”å›å€¼å°±æ˜¯å‡½æ•°ä½“é‡Œé¢æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼
  
  + è‹¥æƒ³æå‰è¿”å›ï¼Œéœ€ä½¿ç”¨returnå…³é”®å­—ï¼Œå¹¶æŒ‡å®šä¸€ä¸ªå€¼
    + å¤§å¤šæ•°å‡½æ•°éƒ½æ˜¯é»˜è®¤ä½¿ç”¨æœ€åä¸€ä¸ªè¡¨è¾¾å¼ä½œä¸ºè¿”å›å€¼
    
      ```rust
      fn five(x: i32) -> i32 {
          5 + x
      }
      let x = five(6);
      println!("The value of x is {}", x);
      ```

#### 3.3.2 æ³¨é‡Š

> ä¸Cå’ŒJavaä¸€æ ·



### 3.4 æµç¨‹æ§åˆ¶

#### 3.4.1 ifè¡¨è¾¾å¼

+ `if`è¡¨è¾¾å¼å…è®¸ä½ æ ¹æ®æ¡ä»¶æ¥æ‰§è¡Œä¸åŒçš„ä»£ç åˆ†æ”¯
  + è¿™ä¸ªæ¡ä»¶å¿…é¡»æ˜¯boolç±»å‹
  
+ `if`è¡¨è¾¾å¼ä¸­ï¼Œä¸æ¡ä»¶ç›¸å…³è”çš„ä»£ç å—å°±å«åšåˆ†æ”¯ï¼ˆarmï¼‰

+ å¯é€‰çš„ï¼Œå¯ä»¥åœ¨åé¢åŠ ä¸Šä¸€ä¸ª`else`è¡¨è¾¾å¼

  ```rust
  let number = 3;
  
  if number < 5 {
      println!("condition was true");
  } else {
      println!("condition was false");
  }
  ```

+ ä½¿ç”¨`else if`å¤„ç†å¤šé‡æ¡ä»¶
  + å¦‚æœä½¿ç”¨äº†å¤šäºä¸€ä¸ª`else if`ï¼Œé‚£ä¹ˆæœ€å¥½ä½¿ç”¨`match`æ¥é‡æ„ä»£ç 
  
+ åœ¨`let`è¯­å¥ä¸­ä½¿ç”¨`if`
  + å› ä¸º`if`æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæ‰€ä»¥å¯ä»¥å°†å®ƒæ”¾åœ¨`let`è¯­å¥ä¸­ç­‰å·çš„å³è¾¹
  
    ```rust
    let condition = true;
    let number = if condition {5} else {6};
    println!("The value of number is: {}", number);
    ```

#### 3.4.2 å¾ªç¯

+ Rustæä¾›äº†3ç§å¾ªç¯ï¼š`loop`ã€`while`å’Œ`for`

+ **loopå¾ªç¯**
  + `loop`å…³é”®å­—å‘Šè¯‰Ruståå¤æ‰§è¡Œä¸€å—ä»£ç ï¼Œç›´åˆ°ä½ å–Šåœ
  
  + å¯ä»¥åœ¨`loop`å¾ªç¯ä¸­ä½¿ç”¨`break`å…³é”®å­—æ¥å‘Šè¯‰ç¨‹åºä½•æ—¶åœæ­¢å¾ªç¯
  
    ```rust
    let mut counter = 0;
    
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2
        }
    };
    
    println!("The result is: {}", result);
    ```

+ **whileæ¡ä»¶å¾ªç¯**
  + å¦å¤–çš„ä¸€ç§å¸¸è§çš„å¾ªç¯æ¨¡å¼æ˜¯æ¯æ¬¡æ‰§è¡Œå¾ªç¯ä½“ä¹‹å‰éƒ½åˆ¤æ–­ä¸€æ¬¡æ¡ä»¶
  
    ```rust
    let mut number = 3;
    while number != 0 {
        println!("{}!", number);
    
        number = number - 1;
    }
    
    println!("LIFTOFF!!!")
    ```

+ **ä½¿ç”¨forå¾ªç¯éå†é›†åˆ**
  + å¯ä»¥ä½¿ç”¨`while`æˆ–`loop`æ¥éå†é›†åˆï¼Œä½†æ˜¯æ˜“é”™ä¸”ä½æ•ˆ
  
  + ä½¿ç”¨`for`å¾ªç¯æ›´ç®€æ´ç´§å‡‘ï¼Œå®ƒå¯ä»¥é’ˆå¯¹é›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ æ¥æ‰§è¡Œä¸€äº›ä»£ç 
  
  + ç”±äº`for`å¾ªç¯çš„å®‰å…¨ã€ç®€æ´æ€§ï¼Œæ‰€ä»¥å®ƒåœ¨Rusté‡Œç”¨çš„æœ€å¤š
  
    ```rust
    let a = [10, 20, 30, 40, 50, 60];
    let mut index = 0;
    while index < a.len() {
        println!("The value is: {}", a[index]);
        index += 1;
    }
    
    for element in a.iter() {
        println!("The value is: {}", element);
    }
    ```

+ **Range**
  + ç”±æ ‡å‡†åº“æä¾›
  
  + æŒ‡å®šä¸€ä¸ªå¼€å§‹æ•°å­—å’Œä¸€ä¸ªç»“æŸæ•°å­—ï¼Œ`Range`å¯ä»¥ç”Ÿæˆå®ƒä»¬ä¹‹é—´çš„æ•°å­—ï¼ˆä¸å«ç»“æŸï¼‰
  
  + `rev`æ–¹æ³•å¯ä»¥åè½¬`Range`
  
    ```rust
    for number in (1 .. 4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
    ```
  
    

## 4ã€è®¤è¯†æ‰€æœ‰æƒ

### 4.1 ä»€ä¹ˆæ˜¯æ‰€æœ‰æƒ

> æ‰€æœ‰æƒæ˜¯Rustæœ€ç‹¬ç‰¹çš„ç‰¹æ€§ï¼Œå®ƒè®©Rustæ— éœ€GCå°±å¯ä»¥ä¿è¯å†…å­˜å®‰å…¨

+ Rustçš„æ ¸å¿ƒç‰¹æ€§å°±æ˜¯æ‰€æœ‰æƒ
+ æ‰€æœ‰çš„ç¨‹åºåœ¨è¿è¡Œæ—¶éƒ½å¿…é¡»ç®¡ç†å®ƒä»¬ä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„æ–¹å¼
  + æœ‰äº›è¯­è¨€æœ‰åƒåœ¾å›æ”¶æœºåˆ¶ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶ï¼Œå®ƒä»¬ä¼šä¸æ–­åœ°å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜
  + åœ¨å…¶å®ƒè¯­è¨€ä¸­ï¼Œç¨‹åºå‘˜å¿…é¡»æ˜¾å¼åœ°åˆ†é…å’Œé‡Šæ”¾å†…å­˜
+ Rusté‡‡ç”¨äº†ç¬¬ä¸‰ç§æ–¹å¼
  + å†…å­˜é€šè¿‡ä¸€ä¸ªæ‰€æœ‰æƒç³»ç»Ÿæ¥ç®¡ç†çš„ï¼Œå…¶ä¸­åŒ…å«ä¸€ç»„ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥çš„è§„åˆ™
  + å½“å†…å­˜è¿è¡Œæ—¶ï¼Œæ‰€æœ‰æƒç‰¹æ€§ä¸ä¼šå‡æ…¢ç¨‹åºçš„è¿è¡Œé€Ÿåº¦

#### 4.1.1 Stack vs Heap

+ åœ¨åƒ Rust è¿™æ ·çš„ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå€¼æ˜¯ä½äºæ ˆä¸Šè¿˜æ˜¯å †ä¸Šåœ¨æ›´å¤§ç¨‹åº¦ä¸Šå½±å“äº†è¯­è¨€çš„è¡Œä¸ºä»¥åŠä¸ºä½•å¿…é¡»åšå‡ºè¿™æ ·çš„æŠ‰æ‹©
+ åœ¨ä½ çš„ä»£ç è¿è¡Œçš„æ—¶å€™ï¼Œæ ˆå’Œå †éƒ½æ˜¯ä»£ç åœ¨è¿è¡Œæ—¶å¯ä¾›ä½¿ç”¨çš„å†…å­˜ï¼Œä½†æ˜¯å®ƒä»¬çš„ç»“æ„ä¸åŒ
+ æ ˆä»¥æ”¾å…¥å€¼çš„é¡ºåºå­˜å‚¨å€¼å¹¶ä»¥ç›¸åé¡ºåºå–å‡ºå€¼ã€‚è¿™ä¹Ÿè¢«ç§°ä½œ **åè¿›å…ˆå‡º**ï¼ˆ*last in, first out*ï¼‰
  + å¢åŠ æ•°æ®å«åš **è¿›æ ˆ**ï¼ˆ*pushing onto the stack*ï¼‰ï¼Œè€Œç§»å‡ºæ•°æ®å«åš **å‡ºæ ˆ**ï¼ˆ*popping off the stack*ï¼‰
  + æ ˆä¸­çš„æ‰€æœ‰æ•°æ®éƒ½å¿…é¡»å ç”¨å·²çŸ¥ä¸”å›ºå®šçš„å¤§å°ã€‚
  + åœ¨ç¼–è¯‘æ—¶å¤§å°æœªçŸ¥æˆ–å¤§å°å¯èƒ½å˜åŒ–çš„æ•°æ®ï¼Œè¦æ”¹ä¸ºå­˜å‚¨åœ¨å †ä¸Šã€‚ 
+ å †æ˜¯ç¼ºä¹ç»„ç»‡çš„
  + å½“å‘å †æ”¾å…¥æ•°æ®æ—¶ï¼Œä½ è¦è¯·æ±‚ä¸€å®šå¤§å°çš„ç©ºé—´ã€‚
  + å†…å­˜åˆ†é…å™¨ï¼ˆmemory allocatorï¼‰åœ¨å †çš„æŸå¤„æ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„ç©ºä½ï¼ŒæŠŠå®ƒæ ‡è®°ä¸ºå·²ä½¿ç”¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªè¡¨ç¤ºè¯¥ä½ç½®åœ°å€çš„ **æŒ‡é’ˆ**ï¼ˆ*pointer*ï¼‰ã€‚è¿™ä¸ªè¿‡ç¨‹ç§°ä½œ **åœ¨å †ä¸Šåˆ†é…å†…å­˜**ï¼ˆ*allocating on the heap*ï¼‰ï¼Œæœ‰æ—¶ç®€ç§°ä¸º â€œåˆ†é…â€ï¼ˆallocatingï¼‰å†…å­˜åˆ†é…å™¨ï¼ˆmemory allocatorï¼‰åœ¨å †çš„æŸå¤„æ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„ç©ºä½ï¼ŒæŠŠå®ƒæ ‡è®°ä¸ºå·²ä½¿ç”¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªè¡¨ç¤ºè¯¥ä½ç½®åœ°å€çš„ **æŒ‡é’ˆ**ï¼ˆ*pointer*ï¼‰ã€‚è¿™ä¸ªè¿‡ç¨‹ç§°ä½œ **åœ¨å †ä¸Šåˆ†é…å†…å­˜**ï¼ˆ*allocating on the heap*ï¼‰ï¼Œæœ‰æ—¶ç®€ç§°ä¸º â€œåˆ†é…â€ï¼ˆallocatingï¼‰
+ æŠŠå€¼å‹åˆ°stackä¸Šä¸å«åˆ†é…ï¼Œå› ä¸ºæŒ‡é’ˆçš„å¤§å°æ˜¯å·²çŸ¥å›ºå®šçš„ï¼Œå¯ä»¥æŠŠæŒ‡é’ˆå­˜æ”¾åœ¨stackä¸Š
  + ä½†å¦‚æœåƒè¦è®¿é—®å®é™…æ•°æ®ï¼Œåˆ™å¿…é¡»ä½¿ç”¨æŒ‡é’ˆæ¥å®šä½
+ å…¥æ ˆæ¯”åœ¨å †ä¸Šåˆ†é…å†…å­˜è¦å¿«
  + å› ä¸ºï¼ˆå…¥æ ˆæ—¶ï¼‰åˆ†é…å™¨æ— éœ€ä¸ºå­˜å‚¨æ–°æ•°æ®å»æœç´¢å†…å­˜ç©ºé—´ï¼›å…¶ä½ç½®æ€»æ˜¯åœ¨æ ˆé¡¶
  + ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨å †ä¸Šåˆ†é…å†…å­˜åˆ™éœ€è¦æ›´å¤šçš„å·¥ä½œï¼Œè¿™æ˜¯å› ä¸ºåˆ†é…å™¨å¿…é¡»é¦–å…ˆæ‰¾åˆ°ä¸€å—è¶³å¤Ÿå­˜æ”¾æ•°æ®çš„å†…å­˜ç©ºé—´ï¼Œå¹¶æ¥ç€åšä¸€äº›è®°å½•ä¸ºä¸‹ä¸€æ¬¡åˆ†é…åšå‡†å¤‡ã€‚
+ è®¿é—®å †ä¸Šçš„æ•°æ®æ¯”è®¿é—®æ ˆä¸Šçš„æ•°æ®æ…¢ï¼Œå› ä¸ºå¿…é¡»é€šè¿‡æŒ‡é’ˆæ¥è®¿é—®
  + å¯¹äºç°ä»£çš„å¤„ç†å™¨æ¥è¯´ï¼Œç”±äºç¼“å­˜çš„ç¼˜æ•…ï¼Œå¦‚æœæŒ‡ä»¤åœ¨å†…å­˜ä¸­è·³è½¬çš„æ¬¡æ•°è¶Šå°‘ï¼Œé‚£ä¹ˆé€Ÿåº¦å°±è¶Šå¿«
+ å‡ºäºåŒæ ·åŸå› ï¼Œå¤„ç†å™¨åœ¨å¤„ç†çš„æ•°æ®å½¼æ­¤è¾ƒè¿‘çš„æ—¶å€™ï¼ˆæ¯”å¦‚åœ¨æ ˆä¸Šï¼‰æ¯”è¾ƒè¿œçš„æ—¶å€™ï¼ˆæ¯”å¦‚å¯èƒ½åœ¨å †ä¸Šï¼‰èƒ½æ›´å¥½çš„å·¥ä½œã€‚
  + åœ¨heapä¸Šåˆ†é…å¤§é‡çš„ç©ºé—´ä¹Ÿæ˜¯éœ€è¦æ—¶é—´çš„
+ å½“ä½ çš„ä»£ç è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œä¼ é€’ç»™å‡½æ•°çš„å€¼ï¼ˆåŒ…æ‹¬å¯èƒ½æŒ‡å‘å †ä¸Šæ•°æ®çš„æŒ‡é’ˆï¼‰å’Œå‡½æ•°çš„å±€éƒ¨å˜é‡è¢«å‹å…¥æ ˆä¸­ã€‚å½“å‡½æ•°ç»“æŸæ—¶ï¼Œè¿™äº›å€¼è¢«ç§»å‡ºæ ˆã€‚

#### 4.1.2 æ‰€æœ‰æƒå­˜åœ¨çš„åŸå› 

+ æ‰€æœ‰æƒè§£å†³çš„é—®é¢˜
  + è·Ÿè¸ªä»£ç çš„å“ªäº›éƒ¨åˆ†æ­£åœ¨ä½¿ç”¨heapçš„å“ªäº›æ•°æ®
  + æœ€å°åŒ–heapä¸Šçš„é‡å¤æ•°æ®é‡
  + æ¸…ç†heapä¸Šæœªä½¿ç”¨çš„æ•°æ®ä»¥é¿å…ç©ºé—´ä¸è¶³
+ ä¸€æ—¦ç†è§£äº†æ‰€æœ‰æƒï¼Œä½ å°±ä¸éœ€è¦ç»å¸¸è€ƒè™‘æ ˆå’Œå †äº†ï¼Œä¸è¿‡æ˜ç™½äº†æ‰€æœ‰æƒçš„ä¸»è¦ç›®çš„å°±æ˜¯ä¸ºäº†ç®¡ç†å †æ•°æ®ï¼Œè¿™ä¹Ÿèƒ½å¤Ÿå¸®åŠ©è§£é‡Šä¸ºä»€ä¹ˆæ‰€æœ‰æƒè¦ä»¥è¿™ç§æ–¹å¼å·¥ä½œã€‚

#### 4.1.3 æ‰€æœ‰æƒè§„åˆ™

+ æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡ï¼Œè¿™ä¸ªå˜é‡æ˜¯è¯¥å€¼çš„æ‰€æœ‰è€…ï¼ˆownerï¼‰
+ æ¯ä¸ªå€¼åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
+ å½“æ‰€æœ‰è€…ç¦»å¼€ä½œç”¨åŸŸï¼ˆscopeï¼‰æ—¶ï¼Œè¯¥å€¼å°†è¢«åˆ é™¤

#### 4.1.4 å˜é‡ä½œç”¨åŸŸ

+ `Scope`å°±æ˜¯ç¨‹åºä¸­ä¸€ä¸ªé¡¹ï¼ˆitemï¼‰åœ¨ç¨‹åºä¸­çš„æœ‰æ•ˆèŒƒå›´

  ```rust
  fn main() {
      // s ä¸å¯ç”¨
      let s = "hello"; // s å¯ç”¨
      // å¯ä»¥å¯¹ s è¿›è¡Œç›¸å…³çš„æ“ä½œ
  } // ä½œç”¨åŸŸåˆ°æ­¤ç»“æŸï¼Œs ä¸å†å¯ç”¨
  ```

#### 4.1.5 Stringç±»å‹

+ `String`æ¯”åŸºç¡€æ ‡é‡æ•°æ®ç±»å‹æ›´å¤æ‚

+ å­—ç¬¦ä¸²å­—é¢å€¼ï¼šç¨‹åºé‡Œæ‰‹å†™çš„å“ªäº›å­—ç¬¦ä¸²å€¼ã€‚å®ƒä»¬æ˜¯ä¸å¯å˜çš„

+ Rustè¿˜æœ‰ç¬¬äºŒç§å­—ç¬¦ä¸²ç±»å‹ï¼šString

  + `String`ç±»å‹ç®¡ç†è¢«åˆ†é…åˆ°å †ä¸Šçš„æ•°æ®ï¼Œæ‰€ä»¥èƒ½å¤Ÿå­˜å‚¨åœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„æ–‡æœ¬

+ åˆ›å»º`String`ç±»å‹çš„å€¼

  + å¯ä»¥ä½¿ç”¨ `from` å‡½æ•°åŸºäºå­—ç¬¦ä¸²å­—é¢å€¼æ¥åˆ›å»º `String`

  + `let s = String::from("hello")`

    + `::` æ˜¯è¿ç®—ç¬¦ï¼Œå…è®¸å°†ç‰¹å®šçš„ `from` å‡½æ•°ç½®äº `String` ç±»å‹çš„å‘½åç©ºé—´ï¼ˆnamespaceï¼‰ä¸‹ï¼Œè€Œä¸éœ€è¦ä½¿ç”¨ç±»ä¼¼ `string_from` è¿™æ ·çš„åå­—ï¼Œä¹Ÿå°±æ˜¯`from`æ˜¯`String`ç±»å‹ä¸‹çš„å‡½æ•°

    + è¿™ç±»å­—ç¬¦ä¸²æ˜¯å¯ä»¥è¢«ä¿®æ”¹çš„

      ```rust
      fn main() {
          let mut s = String::from("hello");
      
          s.push_str(", world");
      
          println!("{}", s);
      }
      ```

    + ä¸ºä»€ä¹ˆ`String`ç±»å‹çš„å€¼å¯ä»¥ä¿®æ”¹ï¼Œè€Œå­—ç¬¦ä¸²å­—é¢å€¼å´ä¸èƒ½ä¿®æ”¹ï¼Ÿ
      + å› ä¸ºå®ƒä»¬å¤„ç†å†…å­˜çš„æ–¹å¼ä¸åŒ

#### 4.1.6 å†…å­˜ä¸åˆ†é…

+ å°±å­—ç¬¦ä¸²å­—é¢å€¼æ¥è¯´ï¼Œæˆ‘ä»¬åœ¨ç¼–è¯‘æ—¶å°±çŸ¥é“å…¶å†…å®¹ï¼Œæ‰€ä»¥æ–‡æœ¬è¢«ç›´æ¥ç¡¬ç¼–ç è¿›æœ€ç»ˆçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸­

  + è¿™ä½¿å¾—å­—ç¬¦ä¸²å­—é¢å€¼å¿«é€Ÿä¸”é«˜æ•ˆï¼Œè¿™äº›ç‰¹æ€§éƒ½åªå¾—ç›Šäºå­—ç¬¦ä¸²å­—é¢å€¼çš„ä¸å¯å˜æ€§

+ å¯¹äº `String` ç±»å‹ï¼Œä¸ºäº†æ”¯æŒä¸€ä¸ªå¯å˜ï¼Œå¯å¢é•¿çš„æ–‡æœ¬ç‰‡æ®µï¼Œéœ€è¦åœ¨å †ä¸Šåˆ†é…ä¸€å—åœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„å†…å­˜æ¥å­˜æ”¾å†…å®¹

  + å¿…é¡»åœ¨è¿è¡Œæ—¶å‘å†…å­˜åˆ†é…å™¨ï¼ˆmemory allocatorï¼‰è¯·æ±‚å†…å­˜

    + â€‹	è¿™æ­¥é€šè¿‡è°ƒç”¨`String::from`æ¥å®ç°

  + å½“æˆ‘ä»¬å¤„ç†å®Œ `String` æ—¶ï¼Œéœ€è¦ä½¿ç”¨æŸç§æ–¹å¼å°†å†…å­˜è¿”å›ç»™åˆ†é…å™¨

    + åœ¨æœ‰ **åƒåœ¾å›æ”¶**ï¼ˆ*garbage collector*ï¼Œ*GC*ï¼‰çš„è¯­è¨€ä¸­ï¼Œ GC è®°å½•å¹¶æ¸…é™¤ä¸å†ä½¿ç”¨çš„å†…å­˜
    + åœ¨å¤§éƒ¨åˆ†æ²¡æœ‰ GC çš„è¯­è¨€ä¸­ï¼Œè¯†åˆ«å‡ºä¸å†ä½¿ç”¨çš„å†…å­˜å¹¶è°ƒç”¨ä»£ç æ˜¾å¼é‡Šæ”¾å°±æ˜¯æˆ‘ä»¬çš„è´£ä»»äº†
      + å¦‚æœå¿˜è®°å›æ”¶äº†ä¼šæµªè´¹å†…å­˜
      + å¦‚æœè¿‡æ—©å›æ”¶äº†ï¼Œå°†ä¼šå‡ºç°æ— æ•ˆå˜é‡ï¼Œå˜é‡å°±ä¼šéæ³•
      + å¦‚æœé‡å¤å›æ”¶ï¼Œè¿™ä¹Ÿæ˜¯ä¸ª bugã€‚æˆ‘ä»¬éœ€è¦ç²¾ç¡®çš„ä¸ºä¸€ä¸ª `allocate` é…å¯¹ä¸€ä¸ª `free`

  + Rust é‡‡å–äº†ä¸€ä¸ªä¸åŒçš„ç­–ç•¥ï¼šå†…å­˜åœ¨æ‹¥æœ‰å®ƒçš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸåå°±è¢«è‡ªåŠ¨é‡Šæ”¾ã€‚

    ```rust
    fn main() {
        {
            let s = String::from("hello"); // ä»æ­¤å¤„èµ·ï¼Œs æ˜¯æœ‰æ•ˆçš„
            // ä½¿ç”¨ s
        }                                  // æ­¤ä½œç”¨åŸŸå·²ç»“æŸ       
    }                                      // s ä¸å†æœ‰æ•ˆ
    ```
    
  + å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸï¼ŒRust ä¸ºæˆ‘ä»¬è°ƒç”¨ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°å«åš [`drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop)ï¼Œåœ¨è¿™é‡Œ `String` çš„ä½œè€…å¯ä»¥æ”¾ç½®é‡Šæ”¾å†…å­˜çš„ä»£ç ã€‚Rust åœ¨ç»“å°¾çš„ `}` å¤„è‡ªåŠ¨è°ƒç”¨ `drop`

#### 4.1.7 å˜é‡ä¸æ•°æ®äº¤äº’çš„æ–¹å¼

> åœ¨Rust ä¸­ï¼Œå¤šä¸ªå˜é‡å¯ä»¥é‡‡å–ä¸åŒçš„æ–¹å¼ä¸åŒä¸€æ•°æ®è¿›è¡Œäº¤äº’

+ ç§»åŠ¨

  ```rust
  fn main() {
      let x = 5;
      let y = x;
  }
  ```
  
  æ•´æ•°æ˜¯æœ‰å·²çŸ¥å›ºå®šå¤§å°çš„ç®€å•å€¼ï¼Œæ‰€ä»¥è¿™ä¸¤ä¸ª 5 è¢«æ”¾å…¥äº†æ ˆä¸­
  
  ```rust
  fn main() {
      let s1 = String::from("hello");
      let s2 = s1;
  }
  ```
  
  æƒ…å†µå’Œå‰é¢çš„ä¾‹å­ä¸åŒ
  
  + `String` ç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼Œè¿™ä¸€ç»„æ•°æ®å­˜å‚¨åœ¨æ ˆä¸Š
  
    + ä¸€ä¸ªæŒ‡å‘å­˜æ”¾å­—ç¬¦ä¸²å†…å®¹å†…å­˜çš„æŒ‡é’ˆ
    + ä¸€ä¸ªé•¿åº¦
    + ä¸€ä¸ªå®¹é‡
  
  + å­˜æ”¾å­—ç¬¦ä¸²å†…å®¹çš„éƒ¨åˆ†åœ¨heapä¸Š
  
  + é•¿åº¦lenï¼Œå°±æ˜¯å­˜æ”¾å­—ç¬¦ä¸²å†…å®¹æ‰€éœ€çš„å­—èŠ‚æ•°
  
  + å®¹é‡capacityæ˜¯æŒ‡`String`ä»å†…å­˜åˆ†é…å™¨æ€»å…±è·å¾—çš„å†…å­˜çš„æ€»å­—èŠ‚æ•°
  
  ![String in memory](assets\String in memory.svg)
  
  + å½“æˆ‘ä»¬å°† `s1` èµ‹å€¼ç»™ `s2`ï¼Œ`String` çš„æ•°æ®è¢«å¤åˆ¶äº†ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬ä»æ ˆä¸Šæ‹·è´äº†å®ƒçš„æŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡ã€‚æˆ‘ä»¬å¹¶æ²¡æœ‰å¤åˆ¶æŒ‡é’ˆæŒ‡å‘çš„å †ä¸Šæ•°æ®ã€‚
  
    ![the same value](E:\Files\Learning\BackEnd\Rust\Note\assets\the same value.svg)
  
  + å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸåï¼ŒRust è‡ªåŠ¨è°ƒç”¨ `drop` å‡½æ•°å¹¶æ¸…ç†å˜é‡çš„å †å†…å­˜
  
  + è¿™å°±æœ‰äº†ä¸€ä¸ªé—®é¢˜ï¼šå½“ `s2` å’Œ `s1` ç¦»å¼€ä½œç”¨åŸŸï¼Œä»–ä»¬éƒ½ä¼šå°è¯•é‡Šæ”¾ç›¸åŒçš„å†…å­˜
  
    + è¿™æ˜¯ä¸€ä¸ªå«åš **äºŒæ¬¡é‡Šæ”¾**ï¼ˆ*double free*ï¼‰çš„é”™è¯¯ï¼Œä¹Ÿæ˜¯ä¹‹å‰æåˆ°è¿‡çš„å†…å­˜å®‰å…¨æ€§ bug ä¹‹ä¸€
    + ä¸¤æ¬¡é‡Šæ”¾ï¼ˆç›¸åŒï¼‰å†…å­˜ä¼šå¯¼è‡´å†…å­˜æ±¡æŸ“ï¼Œå®ƒå¯èƒ½ä¼šå¯¼è‡´æ½œåœ¨çš„å®‰å…¨æ¼æ´
  
  + ç¡®ä¿å†…å­˜å®‰å…¨
  
    + Rustæ²¡æœ‰å°è¯•å¤åˆ¶è¢«åˆ†é…çš„å†…å­˜
    + Rust è®¤ä¸º `s1` ä¸å†æœ‰æ•ˆ
      + Rust ä¸éœ€è¦åœ¨ `s1` ç¦»å¼€ä½œç”¨åŸŸåæ¸…ç†ä»»ä½•ä¸œè¥¿
  
    ```rust
    fn main() {
        let s1 = String::from("hello");
        let s2 = s1;
    
        println!("{}, world!", s1);
    }
    ```
  
  + ä½ ä¼šå¾—åˆ°ä¸€ä¸ªç±»ä¼¼å¦‚ä¸‹çš„é”™è¯¯ï¼Œå› ä¸º Rust ç¦æ­¢ä½ ä½¿ç”¨æ— æ•ˆçš„å¼•ç”¨
  
    ```rust
    error[E0382]: borrow of moved value: `s1`
     --> src\main.rs:5:28
      |
    2 |     let s1 = String::from("hello");
      |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
    3 |     let s2 = s1;
      |              -- value moved here
    4 |
    5 |     println!("{}, world!", s1);
      |                            ^^ value borrowed here after move
      |
      = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
    
    For more information about this error, try `rustc --explain E0382`.
    warning: `owner` (bin "owner") generated 1 warning
    error: could not compile `owner` due to previous error; 1 warning emitted
    ```
  
  + å¦‚æœä½ åœ¨å…¶ä»–è¯­è¨€ä¸­å¬è¯´è¿‡æœ¯è¯­ **æµ…æ‹·è´**ï¼ˆ*shallow copy*ï¼‰å’Œ **æ·±æ‹·è´**ï¼ˆ*deep copy*ï¼‰ï¼Œé‚£ä¹ˆæ‹·è´æŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡è€Œä¸æ‹·è´æ•°æ®å¯èƒ½å¬èµ·æ¥åƒæµ…æ‹·è´ã€‚ä¸è¿‡å› ä¸º Rust åŒæ—¶ä½¿ç¬¬ä¸€ä¸ªå˜é‡æ— æ•ˆäº†ï¼Œè¿™ä¸ªæ“ä½œè¢«ç§°ä¸º **ç§»åŠ¨**ï¼ˆ*move*ï¼‰ï¼Œè€Œä¸æ˜¯æµ…æ‹·è´ã€‚ä¸Šé¢çš„ä¾‹å­å¯ä»¥è§£è¯»ä¸º `s1` è¢« **ç§»åŠ¨** åˆ°äº† `s2` ä¸­ã€‚
  
    ![s1 moved to s2](assets/s1 moved to s2.svg)
  
  + è¿™é‡Œè¿˜éšå«äº†ä¸€ä¸ªè®¾è®¡é€‰æ‹©ï¼šRust æ°¸è¿œä¹Ÿä¸ä¼šè‡ªåŠ¨åˆ›å»ºæ•°æ®çš„ â€œæ·±æ‹·è´â€ã€‚å› æ­¤ï¼Œä»»ä½• **è‡ªåŠ¨** çš„å¤åˆ¶å¯ä»¥è¢«è®¤ä¸ºå¯¹è¿è¡Œæ—¶æ€§èƒ½å½±å“è¾ƒå°
  
+ å…‹éš†

  + å¦‚æœæˆ‘ä»¬ **ç¡®å®** éœ€è¦æ·±åº¦å¤åˆ¶ `String` ä¸­å †ä¸Šçš„æ•°æ®ï¼Œè€Œä¸ä»…ä»…æ˜¯æ ˆä¸Šçš„æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªå«åš `clone` çš„é€šç”¨å‡½æ•°

    ```rust
    fn main() {
        let s1 = String::from("hello");
        let s2 = s1.clone();
    
        println!("s1 = {}, s2 = {}", s1, s2);
    }
    ```

  + åªåœ¨æ ˆä¸Šçš„æ•°æ®ï¼šæ‹·è´
  
    + è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªæ²¡æœ‰æåˆ°çš„å°çªé—¨ã€‚è¿™äº›ä»£ç ä½¿ç”¨äº†æ•´å‹å¹¶ä¸”æ˜¯æœ‰æ•ˆçš„
  
      ```rust
      fn main() {
          let x = 5;
          let y = x;
      
          println!("x = {}, y = {}", x, y);
      }
      ```
  
    + ä½†è¿™æ®µä»£ç ä¼¼ä¹ä¸æˆ‘ä»¬åˆšåˆšå­¦åˆ°çš„å†…å®¹ç›¸çŸ›ç›¾ï¼šæ²¡æœ‰è°ƒç”¨ `clone`ï¼Œä¸è¿‡ `x` ä¾ç„¶æœ‰æ•ˆä¸”æ²¡æœ‰è¢«ç§»åŠ¨åˆ° `y` ä¸­
    + åŸå› æ˜¯åƒæ•´å‹è¿™æ ·çš„åœ¨ç¼–è¯‘æ—¶å·²çŸ¥å¤§å°çš„ç±»å‹è¢«æ•´ä¸ªå­˜å‚¨åœ¨æ ˆä¸Šï¼Œæ‰€ä»¥æ‹·è´å…¶å®é™…çš„å€¼æ˜¯å¿«é€Ÿçš„ã€‚è¿™æ„å‘³ç€æ²¡æœ‰ç†ç”±åœ¨åˆ›å»ºå˜é‡ `y` åä½¿ `x` æ— æ•ˆã€‚æ¢å¥è¯è¯´ï¼Œè¿™é‡Œæ²¡æœ‰æ·±æµ…æ‹·è´çš„åŒºåˆ«ï¼Œæ‰€ä»¥è¿™é‡Œè°ƒç”¨ `clone` å¹¶ä¸ä¼šä¸é€šå¸¸çš„æµ…æ‹·è´æœ‰ä»€ä¹ˆä¸åŒï¼Œæˆ‘ä»¬å¯ä»¥ä¸ç”¨ç®¡å®ƒã€‚
    + Rust æœ‰ä¸€ä¸ªå«åš `Copy` trait çš„ç‰¹æ®Šæ³¨è§£ï¼Œå¯ä»¥ç”¨åœ¨ç±»ä¼¼æ•´å‹è¿™æ ·çš„å­˜å‚¨åœ¨æ ˆä¸Šçš„ç±»å‹ä¸Šï¼Œå¦‚æœä¸€ä¸ªç±»å‹å®ç°äº† `Copy` traitï¼Œé‚£ä¹ˆä¸€ä¸ªæ—§çš„å˜é‡åœ¨å°†å…¶èµ‹å€¼ç»™å…¶ä»–å˜é‡åä»ç„¶å¯ç”¨
    + å¦‚æœä¸€ä¸ªç±»å‹æˆ–è€…è¯¥ç±»å‹çš„ä¸€éƒ¨åˆ†å®ç°ç±» `Drop`traitï¼Œé‚£ä¹ˆRustä¸å…è®¸è®©å®ƒå†å»å®ç°`Copy`trait
      + ä»»ä½•ä¸€ç»„ç®€å•æ ‡é‡å€¼çš„ç»„åˆéƒ½å¯ä»¥å®ç° `Copy`
      + ä»»ä½•ä¸éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§å½¢å¼èµ„æºçš„ç±»å‹éƒ½å¯ä»¥å®ç° `Copy`
      + ä¸€äº›æ‹¥æœ‰`Copy`traitçš„ç±»å‹
        + æ‰€æœ‰æ•´æ•°ç±»å‹ï¼Œæ¯”å¦‚ `u32`ã€‚
        + å¸ƒå°”ç±»å‹ï¼Œ`bool`ï¼Œå®ƒçš„å€¼æ˜¯ `true` å’Œ `false`ã€‚
        + æ‰€æœ‰æµ®ç‚¹æ•°ç±»å‹ï¼Œæ¯”å¦‚ `f64`ã€‚
        + å­—ç¬¦ç±»å‹ï¼Œ`char`ã€‚
        + å…ƒç»„ï¼Œå½“ä¸”ä»…å½“å…¶åŒ…å«çš„ç±»å‹ä¹Ÿéƒ½å®ç° `Copy` çš„æ—¶å€™ã€‚æ¯”å¦‚ï¼Œ`(i32, i32)` å®ç°äº† `Copy`ï¼Œä½† `(i32, String)` å°±æ²¡æœ‰ã€‚
  

#### 4.1.8 æ‰€æœ‰æƒä¸å‡½æ•°

+ å°†å€¼ä¼ é€’ç»™å‡½æ•°ä¸ç»™å˜é‡èµ‹å€¼çš„åŸç†ç›¸ä¼¼

  + å°†å€¼ä¼ é€’ç»™å‡½æ•°å°†å‘ç”Ÿç§»åŠ¨æˆ–å¤åˆ¶

  ```rust
  fn main() {
      let s = String::from("hello");  // s è¿›å…¥ä½œç”¨åŸŸ
  
      takes_ownership(s);             // s çš„å€¼ç§»åŠ¨åˆ°å‡½æ•°é‡Œ ...
                                      // ... æ‰€ä»¥åˆ°è¿™é‡Œä¸å†æœ‰æ•ˆ
  
      let x = 5;                      // x è¿›å…¥ä½œç”¨åŸŸ
  
      makes_copy(x);                  // x åº”è¯¥ç§»åŠ¨å‡½æ•°é‡Œï¼Œ
                                      // ä½† i32 æ˜¯ Copy çš„ï¼Œ
                                      // æ‰€ä»¥åœ¨åé¢å¯ç»§ç»­ä½¿ç”¨ x
  
  } // è¿™é‡Œ, x å…ˆç§»å‡ºäº†ä½œç”¨åŸŸï¼Œç„¶åæ˜¯ sã€‚ä½†å› ä¸º s çš„å€¼å·²è¢«ç§»èµ°ï¼Œ
    // æ²¡æœ‰ç‰¹æ®Šä¹‹å¤„
  
  fn takes_ownership(some_string: String) { // some_string è¿›å…¥ä½œç”¨åŸŸ
      println!("{}", some_string);
  } // è¿™é‡Œï¼Œsome_string ç§»å‡ºä½œç”¨åŸŸå¹¶è°ƒç”¨ `drop` æ–¹æ³•ã€‚
    // å ç”¨çš„å†…å­˜è¢«é‡Šæ”¾
  
  fn makes_copy(some_integer: i32) { // some_integer è¿›å…¥ä½œç”¨åŸŸ
      println!("{}", some_integer);
  } // è¿™é‡Œï¼Œsome_integer ç§»å‡ºä½œç”¨åŸŸã€‚æ²¡æœ‰ç‰¹æ®Šä¹‹å¤„
  ```

#### 4.1.9 è¿”å›å€¼ä¸ä½œç”¨åŸŸ

+ å‡½æ•°åœ¨è¿”å›å€¼çš„è¿‡ç¨‹ä¸­åŒæ ·ä¹Ÿä¼šå‘ç”Ÿæ‰€æœ‰æƒçš„è½¬ç§»

  ```rust
  fn main() {
      let s1 = gives_ownership(); // gives_ownership å°†è¿”å›å€¼
                                      // è½¬ç§»ç»™ s1
  
      let s2 = String::from("hello"); // s2 è¿›å…¥ä½œç”¨åŸŸ
  
      let s3 = takes_and_gives_back(s2); // s2 è¢«ç§»åŠ¨åˆ°
                                         // takes_and_gives_back ä¸­,
                                         // å®ƒä¹Ÿå°†è¿”å›å€¼ç§»ç»™ s3
  } // è¿™é‡Œ, s3 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚s2 ä¹Ÿç§»å‡ºä½œç”¨åŸŸï¼Œä½†å·²è¢«ç§»èµ°ï¼Œ
    // æ‰€ä»¥ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿã€‚s1 ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ
  
  fn gives_ownership() -> String {
      // gives_ownership ä¼šå°†
      // è¿”å›å€¼ç§»åŠ¨ç»™
      // è°ƒç”¨å®ƒçš„å‡½æ•°
  
      let some_string = String::from("yours"); // some_string è¿›å…¥ä½œç”¨åŸŸ.
  
      some_string // è¿”å› some_string
                  // å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
                  //
  }
  
  // takes_and_gives_back å°†ä¼ å…¥å­—ç¬¦ä¸²å¹¶è¿”å›è¯¥å€¼
  fn takes_and_gives_back(a_string: String) -> String {
      // a_string è¿›å…¥ä½œç”¨åŸŸ
      //
  
      a_string // è¿”å› a_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
  }
  ```

+ ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒæ€»æ˜¯éµå¾ªåŒæ ·çš„æ¨¡å¼

  + æŠŠä¸€ä¸ªå€¼èµ‹ç»™å…¶å®ƒå˜é‡æ—¶å°±ä¼šå‘ç”Ÿç§»åŠ¨
  + å½“ä¸€ä¸ªåŒ…å«heapæ•°æ®çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒçš„å€¼å°±ä¼šè¢«`drop`å‡½æ•°æ¸…ç†ï¼Œé™¤éæ•°æ®çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°å¦ä¸€ä¸ªå˜é‡ä¸Šäº†

+ å¦‚æœæˆ‘ä»¬æƒ³è¦å‡½æ•°ä½¿ç”¨ä¸€ä¸ªå€¼ä½†ä¸è·å–æ‰€æœ‰æƒè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ

  ```rust
  fn main() {
      let s1 = String::from("hello");
  
      let (s2, len) = calculate_length(s1);
  
      println!("The length of '{}' is {}.", s2, len);
  }
  
  fn calculate_length(s: String) -> (String, usize) {
      let length = s.len(); // len() è¿”å›å­—ç¬¦ä¸²çš„é•¿åº¦
  
      (s, length)
  }
  ```

  ä½†æ˜¯è¿™æœªå…æœ‰äº›å½¢å¼ä¸»ä¹‰ï¼Œè€Œä¸”è¿™ç§åœºæ™¯åº”è¯¥å¾ˆå¸¸è§

+ Rust å¯¹æ­¤æä¾›äº†ä¸€ä¸ªä¸ç”¨è·å–æ‰€æœ‰æƒå°±å¯ä»¥ä½¿ç”¨å€¼çš„åŠŸèƒ½ï¼Œå«åš **å¼•ç”¨**ï¼ˆ*references*ï¼‰



### 4.2 å¼•ç”¨å’Œå€Ÿç”¨

#### 4.2.1 å¼•ç”¨ï¼ˆreferenceï¼‰

+ æˆ‘ä»¬å¯ä»¥æä¾›ä¸€ä¸ª `String` å€¼çš„å¼•ç”¨ï¼ˆreferenceï¼‰ã€‚**å¼•ç”¨**ï¼ˆ*reference*ï¼‰åƒä¸€ä¸ªæŒ‡é’ˆï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªåœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥ç”±æ­¤è®¿é—®å‚¨å­˜äºè¯¥åœ°å€çš„å±äºå…¶ä»–å˜é‡çš„æ•°æ®ã€‚ ä¸æŒ‡é’ˆä¸åŒï¼Œå¼•ç”¨ç¡®ä¿æŒ‡å‘æŸä¸ªç‰¹å®šç±»å‹çš„æœ‰æ•ˆå€¼ã€‚

  ```rust
  fn main() {
      let s1 = String::from("hello");
  
      let len = calculate_length(&s1);
  
      println!("The length of '{}' is {}.", s1, len);
  }
  
  fn calculate_length(s: &String) -> usize {
      s.len()
  }
  ```

+ æˆ‘ä»¬ä¼ é€’ `&s1` ç»™ `calculate_length`ï¼ŒåŒæ—¶åœ¨å‡½æ•°å®šä¹‰ä¸­ï¼Œæˆ‘ä»¬è·å– `&String` è€Œä¸æ˜¯ `String`ã€‚è¿™äº› & ç¬¦å·å°±æ˜¯ **å¼•ç”¨**ï¼Œå®ƒä»¬å…è®¸ä½ ä½¿ç”¨å€¼ä½†ä¸è·å–å…¶æ‰€æœ‰æƒ

  ![&String s pointing at String s1](assets/&String s pointing at String s1.svg)

#### 4.2.2 å€Ÿç”¨ï¼ˆborrowingï¼‰

+ æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªå¼•ç”¨çš„è¡Œä¸ºç§°ä¸º **å€Ÿç”¨**ï¼ˆ*borrowing*ï¼‰ã€‚æ­£å¦‚ç°å®ç”Ÿæ´»ä¸­ï¼Œå¦‚æœä¸€ä¸ªäººæ‹¥æœ‰æŸæ ·ä¸œè¥¿ï¼Œä½ å¯ä»¥ä»ä»–é‚£é‡Œå€Ÿæ¥ã€‚å½“ä½ ä½¿ç”¨å®Œæ¯•ï¼Œå¿…é¡»è¿˜å›å»ã€‚æˆ‘ä»¬å¹¶ä¸æ‹¥æœ‰å®ƒ

+ å¦‚æœæˆ‘ä»¬å°è¯•ä¿®æ”¹å€Ÿç”¨çš„å˜é‡å‘¢ï¼Ÿ

  ```rust
  fn main() {
      let s = String::from("hello");
  
      change(&s);
  }
  
  fn change(some_string: &String) {
      some_string.push_str(", world");
  }
  ```

  ```rust
  $ cargo run
     Compiling ownership v0.1.0 (file:///projects/ownership)
  error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
   --> src/main.rs:8:5
    |
  7 | fn change(some_string: &String) {
    |                        ------- help: consider changing this to be a mutable reference: `&mut String`
  8 |     some_string.push_str(", world");
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable
  
  For more information about this error, try `rustc --explain E0596`.
  error: could not compile `ownership` due to previous error
  ```

  æ­£å¦‚å˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼Œå¼•ç”¨ä¹Ÿä¸€æ ·ã€‚ï¼ˆé»˜è®¤ï¼‰ä¸å…è®¸ä¿®æ”¹å¼•ç”¨çš„å€¼ï¼ˆå³ä¸èƒ½ä¹±ä¿®æ”¹å€Ÿæ¥çš„ä¸œè¥¿ï¼‰ã€‚

#### 4.2.3 å¯å˜å¼•ç”¨

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªå°è°ƒæ•´å°±èƒ½å…è®¸æˆ‘ä»¬ä¿®æ”¹ä¸€ä¸ªå€Ÿç”¨çš„å€¼ï¼Œè¿™å°±æ˜¯ **å¯å˜å¼•ç”¨**

+ é¦–å…ˆï¼Œæˆ‘ä»¬å¿…é¡»å°† `s` æ”¹ä¸º `mut`ã€‚ç„¶ååœ¨è°ƒç”¨ `change` å‡½æ•°çš„åœ°æ–¹åˆ›å»ºä¸€ä¸ªå¯å˜å¼•ç”¨ `&mut s`ï¼Œå¹¶æ›´æ–°å‡½æ•°ç­¾åä»¥æ¥å—ä¸€ä¸ªå¯å˜å¼•ç”¨ `some_string: &mut String`ã€‚è¿™å°±éå¸¸æ¸…æ¥šåœ°è¡¨æ˜ï¼Œ`change` å‡½æ•°å°†æ”¹å˜å®ƒæ‰€å€Ÿç”¨çš„å€¼ã€‚

+ å¯å˜å¼•ç”¨æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶ï¼šå¦‚æœä½ æœ‰ä¸€ä¸ªå¯¹è¯¥å˜é‡çš„å¯å˜å¼•ç”¨ï¼Œä½ å°±ä¸èƒ½å†åˆ›å»ºå¯¹è¯¥å˜é‡çš„å¼•ç”¨ã€‚è¿™äº›å°è¯•åˆ›å»ºä¸¤ä¸ª `s` çš„å¯å˜å¼•ç”¨çš„ä»£ç ä¼šå¤±è´¥

  ```rust
  fn main() {
      let mut s = String::from("hello");
  
      let r1 = &mut s;
      let r2 = &mut s;
  
      println!("{}, {}", r1, r2);
  }
  ```

  ```rust
  $ cargo run
     Compiling ownership v0.1.0 (file:///projects/ownership)
  error[E0499]: cannot borrow `s` as mutable more than once at a time
   --> src/main.rs:5:14
    |
  4 |     let r1 = &mut s;
    |              ------ first mutable borrow occurs here
  5 |     let r2 = &mut s;
    |              ^^^^^^ second mutable borrow occurs here
  6 | 
  7 |     println!("{}, {}", r1, r2);
    |                        -- first borrow later used here
  
  For more information about this error, try `rustc --explain E0499`.
  error: could not compile `ownership` due to previous error
  ```

  è¿™ä¸€é™åˆ¶ä»¥ä¸€ç§éå¸¸å°å¿ƒè°¨æ…çš„æ–¹å¼å…è®¸å¯å˜æ€§ï¼Œé˜²æ­¢åŒä¸€æ—¶é—´å¯¹åŒä¸€æ•°æ®å­˜åœ¨å¤šä¸ªå¯å˜å¼•ç”¨ã€‚æ–° Rustacean ä»¬ç»å¸¸éš¾ä»¥é€‚åº”è¿™ä¸€ç‚¹ï¼Œå› ä¸ºå¤§éƒ¨åˆ†è¯­è¨€ä¸­å˜é‡ä»»ä½•æ—¶å€™éƒ½æ˜¯å¯å˜çš„ã€‚è¿™ä¸ªé™åˆ¶çš„å¥½å¤„æ˜¯ Rust å¯ä»¥åœ¨ç¼–è¯‘æ—¶å°±é¿å…æ•°æ®ç«äº‰ã€‚**æ•°æ®ç«äº‰**ï¼ˆ*data race*ï¼‰ç±»ä¼¼äºç«æ€æ¡ä»¶ï¼Œå®ƒå¯ç”±è¿™ä¸‰ä¸ªè¡Œä¸ºé€ æˆï¼š

  + ä¸¤ä¸ªæˆ–æ›´å¤šæŒ‡é’ˆåŒæ—¶è®¿é—®åŒä¸€æ•°æ®ã€‚
  + è‡³å°‘æœ‰ä¸€ä¸ªæŒ‡é’ˆè¢«ç”¨æ¥å†™å…¥æ•°æ®ã€‚
  + æ²¡æœ‰åŒæ­¥æ•°æ®è®¿é—®çš„æœºåˆ¶ã€‚

+ æ•°æ®ç«äº‰ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼Œéš¾ä»¥åœ¨è¿è¡Œæ—¶è¿½è¸ªï¼Œå¹¶ä¸”éš¾ä»¥è¯Šæ–­å’Œä¿®å¤ï¼›Rust é¿å…äº†è¿™ç§æƒ…å†µçš„å‘ç”Ÿï¼Œå› ä¸ºå®ƒç”šè‡³ä¸ä¼šç¼–è¯‘å­˜åœ¨æ•°æ®ç«äº‰çš„ä»£ç ï¼

+ å¯ä»¥ä½¿ç”¨å¤§æ‹¬å·æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸï¼Œä»¥å…è®¸æ‹¥æœ‰å¤šä¸ªå¯å˜å¼•ç”¨ï¼Œåªæ˜¯ä¸èƒ½ **åŒæ—¶** æ‹¥æœ‰

  ```rust
  fn main() {
      let mut s = String::from("hello");
  
      {
          let r1 = &mut s;
      } // r1 åœ¨è¿™é‡Œç¦»å¼€äº†ä½œç”¨åŸŸï¼Œæ‰€ä»¥æˆ‘ä»¬å®Œå…¨å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„å¼•ç”¨
  
      let r2 = &mut s;
  }
  ```

+ **ä¸å¯ä»¥åŒæ—¶æ‹¥æœ‰**ä¸€ä¸ªå¯å˜å¼•ç”¨å’Œä¸€ä¸ªä¸å¯å˜çš„å¼•ç”¨

  ```rust
  fn main() {
      let mut s = String::from("hello");
  
      let r1 = &s; // æ²¡é—®é¢˜
      let r2 = &s; // æ²¡é—®é¢˜
      let r3 = &mut s; // å¤§é—®é¢˜
  
      println!("{}, {}, and {}", r1, r2, r3);
  }
  ```

  ```rust
  $ cargo run
     Compiling ownership v0.1.0 (file:///projects/ownership)
  error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
   --> src/main.rs:6:14
    |
  4 |     let r1 = &s; // no problem
    |              -- immutable borrow occurs here
  5 |     let r2 = &s; // no problem
  6 |     let r3 = &mut s; // BIG PROBLEM
    |              ^^^^^^ mutable borrow occurs here
  7 | 
  8 |     println!("{}, {}, and {}", r1, r2, r3);
    |                                -- immutable borrow later used here
  
  For more information about this error, try `rustc --explain E0502`.
  error: could not compile `ownership` due to previous error
  ```

#### 4.2.4 æ‚¬ç©ºå¼•ç”¨ï¼ˆDangling Referencesï¼‰

+ ä¸€ä¸ªæŒ‡é’ˆå¼•ç”¨äº†å†…å­˜ä¸­çš„æŸä¸ªåœ°å€ï¼Œè€Œè¿™å—å†…å­˜å¯èƒ½å·²ç»é‡Šæ”¾å¹¶åˆ†é…ç»™å…¶å®ƒæŒæœ‰è€…äº†

+ åœ¨ Rust ä¸­ç¼–è¯‘å™¨ç¡®ä¿å¼•ç”¨æ°¸è¿œä¹Ÿä¸ä¼šå˜æˆæ‚¬å‚çŠ¶æ€

  + å½“ä½ å¼•ç”¨äº†æŸäº›æ•°æ®ï¼Œç¼–è¯‘å™¨ç¡®ä¿æ•°æ®ä¸ä¼šåœ¨å…¶å¼•ç”¨ä¹‹å‰ç¦»å¼€ä½œç”¨åŸŸ

    ```rust
    fn main() {
        let reference_to_nothing = dangle();
    }
    
    fn dangle() -> &String {
        let s = String::from("hello");
    
        &s
    }
    ```

    ```rust
    $ cargo run
       Compiling ownership v0.1.0 (file:///projects/ownership)
    error[E0106]: missing lifetime specifier
     --> src/main.rs:5:16
      |
    5 | fn dangle() -> &String {
      |                ^ expected named lifetime parameter
      |
      = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
    help: consider using the `'static` lifetime
      |
    5 | fn dangle() -> &'static String {
      |                ~~~~~~~~
    
    For more information about this error, try `rustc --explain E0106`.
    error: could not compile `ownership` due to previous error
    ```

    æˆ‘ä»¬å°è¯•åˆ›å»ºä¸€ä¸ªæ‚¬å‚å¼•ç”¨ï¼ŒRust ä¼šé€šè¿‡ä¸€ä¸ªç¼–è¯‘æ—¶é”™è¯¯æ¥é¿å…

    ```rust
    fn main() {
        let reference_to_nothing = dangle();
    }
    
    fn dangle() -> &String { // dangle è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²çš„å¼•ç”¨
    
        let s = String::from("hello"); // s æ˜¯ä¸€ä¸ªæ–°å­—ç¬¦ä¸²
    
        &s // è¿”å›å­—ç¬¦ä¸² s çš„å¼•ç”¨
    } // è¿™é‡Œ s ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚å…¶å†…å­˜è¢«é‡Šæ”¾ã€‚
      // å±é™©ï¼
    ```

#### 4.2.5 å¼•ç”¨çš„è§„åˆ™

- åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œ**è¦ä¹ˆ** åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œ**è¦ä¹ˆ** åªèƒ½æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨ã€‚
- å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„ã€‚



### 4.3 Sliceç±»å‹ï¼ˆåˆ‡ç‰‡ï¼‰

> *slice* å…è®¸ä½ å¼•ç”¨é›†åˆä¸­ä¸€æ®µè¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸ç”¨å¼•ç”¨æ•´ä¸ªé›†åˆã€‚slice æ˜¯ä¸€ç±»å¼•ç”¨ï¼Œæ‰€ä»¥å®ƒä¸æŒæœ‰æ‰€æœ‰æƒ

+ ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥æ”¶ä¸€ä¸ªç”¨ç©ºæ ¼åˆ†éš”å•è¯çš„å­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›åœ¨è¯¥å­—ç¬¦ä¸²ä¸­æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªå•è¯ã€‚å¦‚æœå‡½æ•°åœ¨è¯¥å­—ç¬¦ä¸²ä¸­å¹¶æœªæ‰¾åˆ°ç©ºæ ¼ï¼Œåˆ™æ•´ä¸ªå­—ç¬¦ä¸²å°±æ˜¯ä¸€ä¸ªå•è¯ï¼Œæ‰€ä»¥åº”è¯¥è¿”å›æ•´ä¸ªå­—ç¬¦ä¸²

+ æˆ‘ä»¬å¹¶æ²¡æœ‰ä¸€ä¸ªçœŸæ­£è·å– **éƒ¨åˆ†** å­—ç¬¦ä¸²çš„åŠæ³•ã€‚ä¸è¿‡ï¼Œæˆ‘ä»¬å¯ä»¥è¿”å›å•è¯ç»“å°¾çš„ç´¢å¼•ï¼Œç»“å°¾ç”±ä¸€ä¸ªç©ºæ ¼è¡¨ç¤º

  ```rust
  fn main() {
      let mut s = String::from("hello world");
      let word_index = first_world(&s);
      s.clear(); // è¿™æ¸…ç©ºäº†å­—ç¬¦ä¸²ï¼Œä½¿å…¶ç­‰äº ""
      // word_index åœ¨æ­¤å¤„çš„å€¼ä»ç„¶æ˜¯ 5ï¼Œ
      // ä½†æ˜¯æ²¡æœ‰æ›´å¤šçš„å­—ç¬¦ä¸²è®©æˆ‘ä»¬å¯ä»¥æœ‰æ•ˆåœ°åº”ç”¨æ•°å€¼ 5ã€‚word_index çš„å€¼ç°åœ¨å®Œå…¨æ²¡æœ‰æ„ä¹‰
      println!("{}", word_index)
  }
  
  fn first_world(s: &String) -> usize {
      let bytes = s.as_bytes();
  
      for (i, &item) in bytes.iter().enumerate() {
          if item == b' ' {
              return i;
          }
      }
      s.len()
  }
  ```

   `iter` æ–¹æ³•è¿”å›é›†åˆä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œè€Œ `enumerate` åŒ…è£…äº† `iter` çš„ç»“æœï¼Œå°†è¿™äº›å…ƒç´ ä½œä¸ºå…ƒç»„çš„ä¸€éƒ¨åˆ†æ¥è¿”å›ã€‚`enumerate` è¿”å›çš„å…ƒç»„ä¸­ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ç´¢å¼•ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯é›†åˆä¸­å…ƒç´ çš„å¼•ç”¨ã€‚

   `enumerate` æ–¹æ³•è¿”å›ä¸€ä¸ªå…ƒç»„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¨¡å¼æ¥è§£æ„ã€‚åœ¨ `for` å¾ªç¯ä¸­ï¼Œæˆ‘ä»¬æŒ‡å®šäº†ä¸€ä¸ªæ¨¡å¼ï¼Œå…¶ä¸­å…ƒç»„ä¸­çš„ `i` æ˜¯ç´¢å¼•è€Œå…ƒç»„ä¸­çš„ `&item` æ˜¯å•ä¸ªå­—èŠ‚ã€‚å› ä¸ºæˆ‘ä»¬ä» `.iter().enumerate()` ä¸­è·å–äº†é›†åˆå…ƒç´ çš„å¼•ç”¨ï¼Œæ‰€ä»¥æ¨¡å¼ä¸­ä½¿ç”¨äº† `&`ã€‚

  åœ¨ `for` å¾ªç¯ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡å­—èŠ‚çš„å­—é¢å€¼è¯­æ³•æ¥å¯»æ‰¾ä»£è¡¨ç©ºæ ¼çš„å­—èŠ‚ã€‚å¦‚æœæ‰¾åˆ°äº†ä¸€ä¸ªç©ºæ ¼ï¼Œè¿”å›å®ƒçš„ä½ç½®ã€‚å¦åˆ™ï¼Œä½¿ç”¨ `s.len()` è¿”å›å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚

  æˆ‘ä»¬è¿”å›äº†ä¸€ä¸ªç‹¬ç«‹çš„ `usize`ï¼Œä¸è¿‡å®ƒåªåœ¨ `&String` çš„ä¸Šä¸‹æ–‡ä¸­æ‰æ˜¯ä¸€ä¸ªæœ‰æ„ä¹‰çš„æ•°å­—ã€‚æ¢å¥è¯è¯´ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªä¸ `String` ç›¸åˆ†ç¦»çš„å€¼ï¼Œæ— æ³•ä¿è¯å°†æ¥å®ƒä»ç„¶æœ‰æ•ˆã€‚

  è¿™ä¸ªç¨‹åºç¼–è¯‘æ—¶æ²¡æœ‰ä»»ä½•é”™è¯¯ï¼Œè€Œä¸”åœ¨è°ƒç”¨ `s.clear()` ä¹‹åä½¿ç”¨ `word` ä¹Ÿä¸ä¼šå‡ºé”™ã€‚å› ä¸º `word` ä¸ `s` çŠ¶æ€å®Œå…¨æ²¡æœ‰è”ç³»ï¼Œæ‰€ä»¥ `word `ä»ç„¶åŒ…å«å€¼ `5`ã€‚å¯ä»¥å°è¯•ç”¨å€¼ `5` æ¥æå–å˜é‡ `s` çš„ç¬¬ä¸€ä¸ªå•è¯ï¼Œä¸è¿‡è¿™æ˜¯æœ‰ bug çš„ï¼Œå› ä¸ºåœ¨æˆ‘ä»¬å°† `5` ä¿å­˜åˆ° `word` ä¹‹å `s` çš„å†…å®¹å·²ç»æ”¹å˜ã€‚æˆ‘ä»¬ä¸å¾—ä¸æ—¶åˆ»æ‹…å¿ƒ `word` çš„ç´¢å¼•ä¸ `s` ä¸­çš„æ•°æ®ä¸å†åŒæ­¥ï¼Œè¿™å¾ˆå•°å—¦ä¸”æ˜“å‡ºé”™ã€‚

#### 4.3.1 å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼ˆsliceï¼‰

+ **å­—ç¬¦ä¸² slice**ï¼ˆ*string slice*ï¼‰æ˜¯ `String` ä¸­ä¸€éƒ¨åˆ†å€¼çš„å¼•ç”¨ï¼Œå®ƒçœ‹èµ·æ¥åƒè¿™æ ·

  ```rust
  fn main() {
      let s = String::from("hello world");
  
      let hello = &s[0..5];
      let world = &s[6..11];
  }
  ```

+ å½¢å¼ï¼š[starting_index..ending_index]

  + starting_indexå°±æ˜¯åˆ‡ç‰‡èµ·å§‹ä½ç½®çš„ç´¢å¼•å€¼
  + ending_indexæ˜¯åˆ‡ç‰‡ç»ˆæ­¢ä½ç½®çš„ä¸‹ä¸€ä¸ªç´¢å¼•å€¼

  ![slice](assets\slice.svg)

  + å­—ç¬¦ä¸² slice range çš„ç´¢å¼•å¿…é¡»ä½äºæœ‰æ•ˆçš„ UTF-8 å­—ç¬¦è¾¹ç•Œå†…
  + å¦‚æœå°è¯•ä»ä¸€ä¸ªå¤šå­—èŠ‚å­—ç¬¦çš„ä¸­é—´ä½ç½®åˆ›å»ºå­—ç¬¦ä¸² sliceï¼Œåˆ™ç¨‹åºå°†ä¼šå› é”™è¯¯è€Œé€€å‡º

+ ä½¿ç”¨å­—ç¬¦ä¸²åˆ‡ç‰‡é‡å†™ä¾‹å­

  ```rust
  fn main() { 
  
      let mut s = String::from("hello world");
      let word_index = first_word(&s);
  
      s.clear(); // é”™è¯¯
      println!("{}", word_index);
  }
  
  fn first_word(s: &String) -> &str {
  
      let bytes = s.as_bytes();
  
      for(i, &item) in bytes.iter().enumerate() {
          if item == b' '{
              return &s[..i];
          }
      }
      &s[..]
  }
  ```

  ```rust
  $ cargo run
     Compiling ownership v0.1.0 (file:///projects/ownership)
  error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
    --> src/main.rs:18:5
     |
  16 |     let word = first_word(&s);
     |                           -- immutable borrow occurs here
  17 | 
  18 |     s.clear(); // error!
     |     ^^^^^^^^^ mutable borrow occurs here
  19 | 
  20 |     println!("the first word is: {}", word);
     |                                       ---- immutable borrow later used here
  
  For more information about this error, try `rustc --explain E0502`.
  error: could not compile `ownership` due to previous error
  ```

  å›å¿†ä¸€ä¸‹å€Ÿç”¨è§„åˆ™ï¼Œå½“æ‹¥æœ‰æŸå€¼çš„ä¸å¯å˜å¼•ç”¨æ—¶ï¼Œå°±ä¸èƒ½å†è·å–ä¸€ä¸ªå¯å˜å¼•ç”¨ã€‚å› ä¸º `clear` éœ€è¦æ¸…ç©º `String`ï¼Œå®ƒå°è¯•è·å–ä¸€ä¸ªå¯å˜å¼•ç”¨ã€‚åœ¨è°ƒç”¨ `clear` ä¹‹åçš„ `println!` ä½¿ç”¨äº† `word` ä¸­çš„å¼•ç”¨ï¼Œæ‰€ä»¥è¿™ä¸ªä¸å¯å˜çš„å¼•ç”¨åœ¨æ­¤æ—¶å¿…é¡»ä»ç„¶æœ‰æ•ˆã€‚Rust ä¸å…è®¸ `clear` ä¸­çš„å¯å˜å¼•ç”¨å’Œ `word` ä¸­çš„ä¸å¯å˜å¼•ç”¨åŒæ—¶å­˜åœ¨ï¼Œå› æ­¤ç¼–è¯‘å¤±è´¥ã€‚Rust ä¸ä»…ä½¿å¾—æˆ‘ä»¬çš„ API ç®€å•æ˜“ç”¨ï¼Œä¹Ÿåœ¨ç¼–è¯‘æ—¶å°±æ¶ˆé™¤äº†ä¸€æ•´ç±»çš„é”™è¯¯ï¼

#### 4.3.2 å­—ç¬¦ä¸²å­—é¢å€¼å°±æ˜¯ slice

+ å­—ç¬¦ä¸²å­—é¢å€¼è¢«ç›´æ¥å­˜å‚¨åœ¨äºŒè¿›åˆ¶ç¨‹åºä¸­
  + `let word = "hello world";`
    + å˜é‡ s çš„ç±»å‹æ˜¯ `&str`ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŒ‡å‘äºŒè¿›åˆ¶ç¨‹åºç‰¹å®šä½ç½®çš„åˆ‡ç‰‡
    + `&str`æ˜¯ä¸å¯å˜å¼•ç”¨ï¼Œæ‰€ä»¥å­—ç¬¦ä¸²å­—é¢å€¼ä¹Ÿæ˜¯ä¸å¯å˜çš„



#### 4.3.3 å°†å­—ç¬¦ä¸² sliceä½œä¸ºå‚æ•°ä¼ é€’

+ `fn first_word(s: &String) -> &str {`

+ è€Œæ›´æœ‰ç»éªŒçš„ Rustacean ä¼šé‡‡ç”¨`&str`ä½œä¸ºå‚æ•°ç±»å‹ï¼Œå› ä¸ºè¿™æ ·å°±å¯ä»¥åŒæ—¶æ¥æ”¶`String`å’Œ`&str`ç±»å‹çš„å‚æ•°äº†

  + `fn first_word(s: &str) -> &str {`
    + ä½¿ç”¨å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œç›´æ¥è°ƒç”¨è¯¥å‡½æ•°
    + ä½¿ç”¨`String`ï¼Œå¯ä»¥åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„`String`åˆ‡ç‰‡æ¥è°ƒç”¨è¯¥å‡½æ•°

+ å®šä¹‰å‡½æ•°æ—¶ä½¿ç”¨å­—ç¬¦ä¸²åˆ‡ç‰‡æ¥ä»£æ›¿å­—ç¬¦ä¸²å¼•ç”¨ä¼šä½¿æˆ‘ä»¬çš„APIæ›´åŠ é€šç”¨ï¼Œä¸”ä¸ä¼šæŸå¤±ä»»ä½•åŠŸèƒ½

  ```rust
  fn main() {
      let my_string = String::from("hello world");
  
      // `first_word` é€‚ç”¨äº `String`ï¼ˆçš„ sliceï¼‰ï¼Œæ•´ä½“æˆ–å…¨éƒ¨
      let word = first_word(&my_string[0..6]);
      let word = first_word(&my_string[..]);
      // `first_word` ä¹Ÿé€‚ç”¨äº `String` çš„å¼•ç”¨ï¼Œ
      // è¿™ç­‰ä»·äºæ•´ä¸ª `String` çš„ slice
      let word = first_word(&my_string);
  
      let my_string_literal = "hello world";
  
      // `first_word` é€‚ç”¨äºå­—ç¬¦ä¸²å­—é¢å€¼ï¼Œæ•´ä½“æˆ–å…¨éƒ¨
      let word = first_word(&my_string_literal[0..6]);
      let word = first_word(&my_string_literal[..]);
  
      // å› ä¸ºå­—ç¬¦ä¸²å­—é¢å€¼å·²ç» **æ˜¯** å­—ç¬¦ä¸² slice äº†ï¼Œ
      // è¿™ä¹Ÿæ˜¯é€‚ç”¨çš„ï¼Œæ— éœ€ slice è¯­æ³•ï¼
      let word = first_word(my_string_literal);
  }
  ```

  

#### 4.3.4 å…¶å®ƒç±»å‹çš„ slice

+ å°±è·Ÿæˆ‘ä»¬æƒ³è¦è·å–å­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†é‚£æ ·ï¼Œæˆ‘ä»¬ä¹Ÿä¼šæƒ³è¦å¼•ç”¨æ•°ç»„çš„ä¸€éƒ¨åˆ†

  ```rust
  #![allow(unused)]
  fn main() {
  let a = [1, 2, 3, 4, 5];
  
  let slice = &a[1..3];
  
  assert_eq!(slice, &[2, 3]);
  }
  ```

  è¿™ä¸ª slice çš„ç±»å‹æ˜¯ `&[i32]`ã€‚å®ƒè·Ÿå­—ç¬¦ä¸² slice çš„å·¥ä½œæ–¹å¼ä¸€æ ·ï¼Œé€šè¿‡å­˜å‚¨é›†åˆä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨å’Œä¸€ä¸ªé›†åˆæ€»é•¿åº¦ã€‚ä½ å¯ä»¥å¯¹å…¶ä»–æ‰€æœ‰é›†åˆä½¿ç”¨è¿™ç±» slice



## 5ã€ä½¿ç”¨ç»“æ„ä½“ç»„ç»‡ç›¸å…³è”çš„æ•°æ®

> *struct*ï¼Œæˆ–è€… *structure*ï¼Œæ˜¯ä¸€ä¸ªè‡ªå®šä¹‰æ•°æ®ç±»å‹ï¼Œå…è®¸ä½ åŒ…è£…å’Œå‘½åå¤šä¸ªç›¸å…³çš„å€¼ï¼Œä»è€Œå½¢æˆä¸€ä¸ªæœ‰æ„ä¹‰çš„ç»„åˆã€‚å¦‚æœä½ ç†Ÿæ‚‰ä¸€é—¨é¢å‘å¯¹è±¡è¯­è¨€ï¼Œ*struct* å°±åƒå¯¹è±¡ä¸­çš„æ•°æ®å±æ€§ã€‚

### 5.1 ç»“æ„ä½“çš„å®šä¹‰å’Œå®ä¾‹åŒ–

#### 5.1.1 åˆ›å»ºstruct

+ ä½¿ç”¨`struct`å…³é”®å­—ï¼Œå¹¶ä¸ºæ•´ä¸ª`struct`å‘½å

+ åœ¨èŠ±æ‹¬å·å†…ï¼Œä¸ºæ‰€æœ‰å­—æ®µï¼ˆFieldï¼‰å®šä¹‰åç§°å’Œç±»å‹

  ```rust
  struct User {
      username: String,
      email: String,
      sign_in_count: u64,
      active: bool,
  }
  ```

#### 5.1.2 å®ä¾‹åŒ–struct

+ æƒ³è¦ä½¿ç”¨`struct`ï¼Œéœ€è¦åˆ›å»º`struct`çš„å®ä¾‹

  + ä¸ºæ¯ä¸ªå­—æ®µæŒ‡å®šå…·ä½“å€¼
  + æ— éœ€æŒ‰å£°æ˜çš„é¡ºåºè¿›è¡ŒæŒ‡å®š

  ```rust
  fn main() {
      let user1 = User {
          email: String::from("someone@example.com"),
          username: String::from("someusername123"),
          active: true,
          sign_in_count: 1,
      };
  }
  ```

#### 5.1.3 å–å¾—structé‡Œé¢çš„æŸä¸ªå€¼

+ ä½¿ç”¨ç‚¹æ ‡è®°æ³•

  ```rust
  struct User {
      active: bool,
      username: String,
      email: String,
      sign_in_count: u64,
  }
  
  fn main() {
      let mut user1 = User {
          email: String::from("someone@example.com"),
          username: String::from("someusername123"),
          active: true,
          sign_in_count: 1,
      };
  
      user1.email = String::from("anotheremail@example.com");
  }
  ```

+ ä¸€æ—¦`struct`çš„å®ä¾‹æ˜¯å¯å˜çš„ï¼Œé‚£ä¹ˆå®ä¾‹ä¸­æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯å˜çš„ï¼ŒRust å¹¶ä¸å…è®¸åªå°†æŸä¸ªå­—æ®µæ ‡è®°ä¸ºå¯å˜

+ å¦å¤–éœ€è¦æ³¨æ„åŒå…¶ä»–ä»»ä½•è¡¨è¾¾å¼ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å‡½æ•°ä½“çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ä¸­æ„é€ ä¸€ä¸ªç»“æ„ä½“çš„æ–°å®ä¾‹ï¼Œæ¥éšå¼åœ°è¿”å›è¿™ä¸ªå®ä¾‹

  ```rust
  struct User {
      active: bool,
      username: String,
      email: String,
      sign_in_count: u64,
  }
  
  fn build_user(email: String, username: String) -> User {
      User {
          email: email,
          username: username,
          active: true,
          sign_in_count: 1,
      }
  }
  
  fn main() {
      let user1 = build_user(
          String::from("someone@example.com"),
          String::from("someusername123"),
      );
  }
  ```

+ ä¸ºå‡½æ•°å‚æ•°èµ·ä¸ç»“æ„ä½“å­—æ®µç›¸åŒçš„åå­—æ˜¯å¯ä»¥ç†è§£çš„ï¼Œä½†æ˜¯ä¸å¾—ä¸é‡å¤ `email` å’Œ `username` å­—æ®µåç§°ä¸å˜é‡æœ‰äº›å•°å—¦ã€‚å¦‚æœç»“æ„ä½“æœ‰æ›´å¤šå­—æ®µï¼Œé‡å¤æ¯ä¸ªåç§°å°±æ›´åŠ çƒ¦äººäº†ã€‚å¹¸è¿çš„æ˜¯ï¼Œæœ‰ä¸€ä¸ªæ–¹ä¾¿çš„ç®€å†™è¯­æ³•ï¼

#### 5.1.4 å­—æ®µåˆå§‹åŒ–ç®€å†™è¯­æ³•

+ å½“å‚æ•°åä¸å­—æ®µåéƒ½å®Œå…¨ç›¸åŒï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ **å­—æ®µåˆå§‹åŒ–ç®€å†™è¯­æ³•**ï¼ˆ*field init shorthand*ï¼‰æ¥é‡å†™

  ```rust
  struct User {
      active: bool,
      username: String,
      email: String,
      sign_in_count: u64,
  }
  
  fn build_user(email: String, username: String) -> User {
      User {
          email,
          username,
          active: true,
          sign_in_count: 1,
      }
  }
  
  fn main() {
      let user1 = build_user(
          String::from("someone@example.com"),
          String::from("someusername123"),
      );
  }
  ```

#### 5.1.5 structæ›´æ–°è¯­æ³•

+ å½“ä½ æƒ³åŸºäºæŸä¸ª`struct`å®ä¾‹æ¥åˆ›å»ºä¸€ä¸ªæ–°å®ä¾‹çš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨ **ç»“æ„ä½“æ›´æ–°è¯­æ³•**ï¼ˆ*struct update syntax*ï¼‰å®ç°

  ```rust
  struct User {
      active: bool,
      username: String,
      email: String,
      sign_in_count: u64,
  }
  
  fn main() {
      // --snip--
  
      let user1 = User {
          email: String::from("someone@example.com"),
          username: String::from("someusername123"),
          active: true,
          sign_in_count: 1,
      };
  	
      // ä¸ä½¿ç”¨æ›´æ–°è¯­æ³•
      let user2 = User {
          active: user1.active,
          username: user1.username,
          email: String::from("another@example.com"),
          sign_in_count: user1.sign_in_count,
      };
      
      //ä½¿ç”¨æ›´æ–°è¯­æ³•
      let user2 = User {
          email: String::from("another@example.com"),
          ..user1
      };
  }
  ```

#### 5.1.6 Tuple structs

+ å¯å®šä¹‰ç±»ä¼¼`tuple`çš„`struct`ï¼Œå«åšå…ƒç»„ç»“æ„ä½“ï¼ˆ*tuple structs*ï¼‰

  + `Tuple structs`æœ‰ç€ç»“æ„ä½“åç§°æä¾›çš„å«ä¹‰ï¼Œä½†æ²¡æœ‰å…·ä½“çš„å­—æ®µåï¼Œåªæœ‰å­—æ®µçš„ç±»å‹
  + å½“ä½ æƒ³ç»™æ•´ä¸ªå…ƒç»„å–ä¸€ä¸ªåå­—ï¼Œå¹¶ä½¿å…ƒç»„æˆä¸ºä¸å…¶ä»–å…ƒç»„ä¸åŒçš„ç±»å‹æ—¶ï¼Œå…ƒç»„ç»“æ„ä½“æ˜¯å¾ˆæœ‰ç”¨çš„ï¼Œè¿™æ—¶åƒå¸¸è§„ç»“æ„ä½“é‚£æ ·ä¸ºæ¯ä¸ªå­—æ®µå‘½åå°±æ˜¾å¾—å¤šä½™å’Œå½¢å¼åŒ–äº†

+ å®šä¹‰ `Tuple structs`ï¼šä½¿ç”¨`struct`å…³é”®å­—ï¼Œåè¾¹æ˜¯åå­—ï¼Œä»¥åŠé‡Œé¢å…ƒç´ çš„ç±»å‹

  ```rust
  struct Color(i32, i32, i32);
  struct Point(i32, i32, i32);
  
  fn main() {
      let black = Color(0, 0, 0);
      let origin = Point(0, 0, 0);
  }
  ```

+ `black` å’Œ `origin` å€¼çš„ç±»å‹ä¸åŒï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸åŒçš„å…ƒç»„ç»“æ„ä½“çš„å®ä¾‹

+ å…ƒç»„ç»“æ„ä½“å®ä¾‹ç±»ä¼¼äºå…ƒç»„ï¼Œä½ å¯ä»¥å°†å®ƒä»¬è§£æ„ä¸ºå•ç‹¬çš„éƒ¨åˆ†ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ `.` åè·Ÿç´¢å¼•æ¥è®¿é—®å•ç‹¬çš„å€¼

#### 5.1.7 æ²¡æœ‰ä»»ä½•å­—æ®µçš„ç±»å•å…ƒç»“æ„ä½“ï¼ˆ*unit-like structs*ï¼‰

+ å®šä¹‰ä¸€ä¸ªæ²¡æœ‰ä»»ä½•å­—æ®µçš„ç»“æ„ä½“ï¼å®ƒä»¬è¢«ç§°ä¸º **ç±»å•å…ƒç»“æ„ä½“**ï¼ˆ*unit-like structs*ï¼‰,å› ä¸ºå®ƒä»¬ç±»ä¼¼äº `()`ï¼Œå³â€œå…ƒç»„ç±»å‹â€ä¸­æåˆ°çš„ unit ç±»å‹

+ ç±»å•å…ƒç»“æ„ä½“å¸¸å¸¸åœ¨ä½ æƒ³è¦åœ¨æŸä¸ªç±»å‹ä¸Šå®ç° trait ä½†ä¸éœ€è¦åœ¨ç±»å‹ä¸­å­˜å‚¨æ•°æ®çš„æ—¶å€™å‘æŒ¥ä½œç”¨

  ```rust
  struct AlwaysEqual;
  
  fn main() {
      let subject = AlwaysEqual;
  }
  ```

#### 5.1.8 structæ•°æ®çš„æ‰€æœ‰æƒ

```rust
struct User {
active: bool,
username: &str,
email: &str,
sign_in_count: u64,
}
```

+ è¿™é‡Œçš„å­—æ®µä½¿ç”¨äº†`String`è€Œä¸æ˜¯`&str`
  + è¯¥`struct`å®ä¾‹æ‹¥æœ‰å…¶æ‰€æœ‰çš„æ•°æ®
  + åªè¦`struct`å®ä¾‹æ˜¯æœ‰æ•ˆçš„ï¼Œé‚£ä¹ˆé‡Œé¢çš„å­—æ®µæ•°æ®ä¹Ÿæ˜¯æœ‰æ•ˆçš„
  
+ `struct`é‡Œä¹Ÿå¯ä»¥å­˜æ”¾å¼•ç”¨ï¼Œä½†è¿™éœ€è¦ä½¿ç”¨å£°æ˜å‘¨æœŸï¼ˆlifetimesï¼‰
  + ç”Ÿå‘½å‘¨æœŸä¿è¯åªè¦`struct`å®ä¾‹æ˜¯æœ‰æ•ˆçš„ï¼Œé‚£ä¹ˆé‡Œé¢çš„å¼•ç”¨ä¹Ÿæ˜¯æœ‰æ•ˆçš„
  + å¦‚æœ`struct`é‡Œé¢å­˜å‚¨å¼•ç”¨ï¼Œè€Œä¸ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå°±ä¼šæŠ¥é”™
  
  ```rust
  struct User {
      active: bool,
      username: &str,
      email: &str,
      sign_in_count: u64,
  }
  
  fn main() {
      let user1 = User {
          email: "someone@example.com",
          username: "someusername123",
          active: true,
          sign_in_count: 1,
      };
  }
  
  ```
  
  ```rust
  $ cargo run
     Compiling structs v0.1.0 (file:///projects/structs)
  error[E0106]: missing lifetime specifier
   --> src/main.rs:3:15
    |
  3 |     username: &str,
    |               ^ expected named lifetime parameter
    |
  help: consider introducing a named lifetime parameter
    |
  1 ~ struct User<'a> {
  2 |     active: bool,
  3 ~     username: &'a str,
    |
  
  error[E0106]: missing lifetime specifier
   --> src/main.rs:4:12
    |
  4 |     email: &str,
    |            ^ expected named lifetime parameter
    |
  help: consider introducing a named lifetime parameter
    |
  1 ~ struct User<'a> {
  2 |     active: bool,
  3 |     username: &str,
  4 ~     email: &'a str,
    |
  
  For more information about this error, try `rustc --explain E0106`.
  error: could not compile `structs` due to 2 previous errors
  ```



### 5.2 ç»“æ„ä½“ç¤ºä¾‹ç¨‹åº

ä½¿ç”¨ Cargo æ–°å»ºä¸€ä¸ªå«åš *rectangles* çš„äºŒè¿›åˆ¶ç¨‹åºï¼Œå®ƒè·å–ä»¥åƒç´ ä¸ºå•ä½çš„é•¿æ–¹å½¢çš„å®½åº¦å’Œé«˜åº¦ï¼Œå¹¶è®¡ç®—å‡ºé•¿æ–¹å½¢çš„é¢ç§¯

```rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}

```

è¿™ä¸ªç¤ºä¾‹ä»£ç åœ¨è°ƒç”¨ `area` å‡½æ•°æ—¶ä¼ å…¥æ¯ä¸ªç»´åº¦ï¼Œè™½ç„¶å¯ä»¥æ­£ç¡®è®¡ç®—å‡ºé•¿æ–¹å½¢çš„é¢ç§¯ï¼Œä½†æˆ‘ä»¬ä»ç„¶å¯ä»¥ä¿®æ”¹è¿™æ®µä»£ç æ¥ä½¿å®ƒçš„æ„ä¹‰æ›´åŠ æ˜ç¡®ï¼Œå¹¶ä¸”å¢åŠ å¯è¯»æ€§

è¿™äº›ä»£ç çš„é—®é¢˜çªæ˜¾åœ¨ `area` çš„ç­¾åä¸Šï¼š

```rust
fn area(width: u32, height: u32) -> u32 {
```

å‡½æ•° `area` æœ¬åº”è¯¥è®¡ç®—ä¸€ä¸ªé•¿æ–¹å½¢çš„é¢ç§¯ï¼Œä¸è¿‡å‡½æ•°å´æœ‰ä¸¤ä¸ªå‚æ•°ã€‚è¿™ä¸¤ä¸ªå‚æ•°æ˜¯ç›¸å…³è”çš„ï¼Œä¸è¿‡ç¨‹åºæœ¬èº«å´æ²¡æœ‰è¡¨ç°å‡ºè¿™ä¸€ç‚¹ã€‚å°†é•¿åº¦å’Œå®½åº¦ç»„åˆåœ¨ä¸€èµ·å°†æ›´æ˜“æ‡‚ä¹Ÿæ›´æ˜“å¤„ç†ã€‚ç¬¬ä¸‰ç« çš„å…ƒç»„ç±»å‹ éƒ¨åˆ†å·²ç»è®¨è®ºè¿‡äº†ä¸€ç§å¯è¡Œçš„æ–¹æ³•ï¼šå…ƒç»„ã€‚

#### 5.2.1 ä½¿ç”¨å…ƒç»„é‡æ„

```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```

åœ¨æŸç§ç¨‹åº¦ä¸Šè¯´ï¼Œè¿™ä¸ªç¨‹åºæ›´å¥½ä¸€ç‚¹äº†ã€‚å…ƒç»„å¸®åŠ©æˆ‘ä»¬å¢åŠ äº†ä¸€äº›ç»“æ„æ€§ï¼Œå¹¶ä¸”ç°åœ¨åªéœ€ä¼ ä¸€ä¸ªå‚æ•°ã€‚ä¸è¿‡åœ¨å¦ä¸€æ–¹é¢ï¼Œè¿™ä¸ªç‰ˆæœ¬å´æœ‰ä¸€ç‚¹ä¸æ˜ç¡®äº†ï¼šå…ƒç»„å¹¶æ²¡æœ‰ç»™å‡ºå…ƒç´ çš„åç§°ï¼Œæ‰€ä»¥è®¡ç®—å˜å¾—æ›´è´¹è§£äº†ï¼Œå› ä¸ºä¸å¾—ä¸ä½¿ç”¨ç´¢å¼•æ¥è·å–å…ƒç»„çš„æ¯ä¸€éƒ¨åˆ†

åœ¨è®¡ç®—é¢ç§¯æ—¶å°†å®½å’Œé«˜å¼„æ··å€’æ— å…³ç´§è¦ï¼Œä¸è¿‡å½“åœ¨å±å¹•ä¸Šç»˜åˆ¶é•¿æ–¹å½¢æ—¶å°±æœ‰é—®é¢˜äº†ï¼æˆ‘ä»¬å¿…é¡»ç‰¢è®° `width` çš„å…ƒç»„ç´¢å¼•æ˜¯ `0`ï¼Œ`height` çš„å…ƒç»„ç´¢å¼•æ˜¯ `1`ã€‚å¦‚æœå…¶ä»–äººè¦ä½¿ç”¨è¿™äº›ä»£ç ï¼Œä»–ä»¬å¿…é¡»è¦ææ¸…æ¥šè¿™ä¸€ç‚¹ï¼Œå¹¶ä¹Ÿè¦ç‰¢è®°äºå¿ƒã€‚å¾ˆå®¹æ˜“å¿˜è®°æˆ–è€…æ··æ·†è¿™äº›å€¼è€Œé€ æˆé”™è¯¯ï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰åœ¨ä»£ç ä¸­ä¼ è¾¾æ•°æ®çš„æ„å›¾

#### 5.2.2 ä½¿ç”¨ç»“æ„ä½“é‡æ„ï¼šèµ‹äºˆæ›´å¤šæ„ä¹‰

æˆ‘ä»¬ä½¿ç”¨ç»“æ„ä½“ä¸ºæ•°æ®å‘½åæ¥ä¸ºå…¶èµ‹äºˆæ„ä¹‰ã€‚æˆ‘ä»¬å¯ä»¥å°†æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨çš„å…ƒç»„è½¬æ¢æˆä¸€ä¸ªæœ‰æ•´ä½“åç§°è€Œä¸”æ¯ä¸ªéƒ¨åˆ†ä¹Ÿæœ‰å¯¹åº”åå­—çš„ç»“æ„ä½“

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```

è¿™é‡Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªç»“æ„ä½“å¹¶ç§°å…¶ä¸º `Rectangle`ã€‚åœ¨å¤§æ‹¬å·ä¸­å®šä¹‰äº†å­—æ®µ `width` å’Œ `height`ï¼Œç±»å‹éƒ½æ˜¯ `u32`ã€‚æ¥ç€åœ¨ `main` ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå…·ä½“çš„ `Rectangle` å®ä¾‹ï¼Œå®ƒçš„å®½æ˜¯ 30ï¼Œé«˜æ˜¯ 50

å‡½æ•° `area` ç°åœ¨è¢«å®šä¹‰ä¸ºæ¥æ”¶ä¸€ä¸ªåå« `rectangle` çš„å‚æ•°ï¼Œå…¶ç±»å‹æ˜¯ä¸€ä¸ªç»“æ„ä½“ `Rectangle` å®ä¾‹çš„ä¸å¯å˜å€Ÿç”¨ã€‚ç¬¬å››ç« è®²åˆ°è¿‡ï¼Œæˆ‘ä»¬å¸Œæœ›å€Ÿç”¨ç»“æ„ä½“è€Œä¸æ˜¯è·å–å®ƒçš„æ‰€æœ‰æƒï¼Œè¿™æ · `main` å‡½æ•°å°±å¯ä»¥ä¿æŒ `rect1` çš„æ‰€æœ‰æƒå¹¶ç»§ç»­ä½¿ç”¨å®ƒï¼Œæ‰€ä»¥è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨å‡½æ•°ç­¾åå’Œè°ƒç”¨çš„åœ°æ–¹ä¼šæœ‰ `&`

`area` å‡½æ•°è®¿é—® `Rectangle` å®ä¾‹çš„ `width` å’Œ `height` å­—æ®µï¼ˆæ³¨æ„ï¼Œè®¿é—®å¯¹ç»“æ„ä½“çš„å¼•ç”¨çš„å­—æ®µä¸ä¼šç§»åŠ¨å­—æ®µçš„æ‰€æœ‰æƒï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆä½ ç»å¸¸çœ‹åˆ°å¯¹ç»“æ„ä½“çš„å¼•ç”¨ï¼‰ã€‚`area` çš„å‡½æ•°ç­¾åç°åœ¨æ˜ç¡®çš„é˜è¿°äº†æˆ‘ä»¬çš„æ„å›¾ï¼šä½¿ç”¨ `Rectangle` çš„ `width` å’Œ `height` å­—æ®µï¼Œè®¡ç®— `Rectangle` çš„é¢ç§¯ã€‚è¿™è¡¨æ˜å®½é«˜æ˜¯ç›¸äº’è”ç³»çš„ï¼Œå¹¶ä¸ºè¿™äº›å€¼æä¾›äº†æè¿°æ€§çš„åç§°è€Œä¸æ˜¯ä½¿ç”¨å…ƒç»„çš„ç´¢å¼•å€¼ `0` å’Œ `1` ã€‚ç»“æ„ä½“èƒœåœ¨æ›´æ¸…æ™°æ˜äº†

#### 5.2.3 é€šè¿‡æ´¾ç”Ÿ trait å¢åŠ å®ç”¨åŠŸèƒ½

åœ¨è°ƒè¯•ç¨‹åºæ—¶æ‰“å°å‡º `Rectangle` å®ä¾‹æ¥æŸ¥çœ‹å…¶æ‰€æœ‰å­—æ®µçš„å€¼éå¸¸æœ‰ç”¨ã€‚ç¤ºä¾‹ 5-11 åƒå‰é¢ç« èŠ‚é‚£æ ·å°è¯•ä½¿ç”¨ `println!` å®ã€‚ä½†è¿™å¹¶ä¸è¡Œ

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}
```

å½“æˆ‘ä»¬è¿è¡Œè¿™ä¸ªä»£ç æ—¶ï¼Œä¼šå‡ºç°å¸¦æœ‰å¦‚ä¸‹æ ¸å¿ƒä¿¡æ¯çš„é”™è¯¯

```rust
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```

`println!` å®èƒ½å¤„ç†å¾ˆå¤šç±»å‹çš„æ ¼å¼ï¼Œä¸è¿‡ï¼Œ`{}` é»˜è®¤å‘Šè¯‰ `println!` ä½¿ç”¨è¢«ç§°ä¸º `Display` çš„æ ¼å¼ï¼šæ„åœ¨æä¾›ç»™ç›´æ¥ç»ˆç«¯ç”¨æˆ·æŸ¥çœ‹çš„è¾“å‡ºã€‚ç›®å‰ä¸ºæ­¢è§è¿‡çš„åŸºæœ¬ç±»å‹éƒ½é»˜è®¤å®ç°äº† `Display`ï¼Œå› ä¸ºå®ƒå°±æ˜¯å‘ç”¨æˆ·å±•ç¤º `1` æˆ–å…¶ä»–ä»»ä½•åŸºæœ¬ç±»å‹çš„å”¯ä¸€æ–¹å¼ã€‚ä¸è¿‡å¯¹äºç»“æ„ä½“ï¼Œ`println!` åº”è¯¥ç”¨æ¥è¾“å‡ºçš„æ ¼å¼æ˜¯ä¸æ˜ç¡®çš„ï¼Œå› ä¸ºè¿™æœ‰æ›´å¤šæ˜¾ç¤ºçš„å¯èƒ½æ€§ï¼šæ˜¯å¦éœ€è¦é€—å·ï¼Ÿéœ€è¦æ‰“å°å‡ºå¤§æ‹¬å·å—ï¼Ÿæ‰€æœ‰å­—æ®µéƒ½åº”è¯¥æ˜¾ç¤ºå—ï¼Ÿç”±äºè¿™ç§ä¸ç¡®å®šæ€§ï¼ŒRust ä¸ä¼šå°è¯•çŒœæµ‹æˆ‘ä»¬çš„æ„å›¾ï¼Œæ‰€ä»¥ç»“æ„ä½“å¹¶æ²¡æœ‰æä¾›ä¸€ä¸ª `Display` å®ç°æ¥ä½¿ç”¨ `println!` ä¸ `{}` å ä½ç¬¦

ä½†æ˜¯å¦‚æœæˆ‘ä»¬ç»§ç»­é˜…è¯»é”™è¯¯ï¼Œå°†ä¼šå‘ç°è¿™ä¸ªæœ‰å¸®åŠ©çš„ä¿¡æ¯ï¼š

```rust
= help: the trait `std::fmt::Display` is not implemented for `Rectangle`
= note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
```

è®©æˆ‘ä»¬æ¥è¯•è¯•ï¼ç°åœ¨ `println!` å®è°ƒç”¨çœ‹èµ·æ¥åƒ `println!("rect1 is {:?}", rect1);` è¿™æ ·ã€‚åœ¨ `{}` ä¸­åŠ å…¥ `:?` æŒ‡ç¤ºç¬¦å‘Šè¯‰ `println!` æˆ‘ä»¬æƒ³è¦ä½¿ç”¨å«åš `Debug` çš„è¾“å‡ºæ ¼å¼ã€‚`Debug` æ˜¯ä¸€ä¸ª traitï¼Œå®ƒå…è®¸æˆ‘ä»¬ä»¥ä¸€ç§å¯¹å¼€å‘è€…æœ‰å¸®åŠ©çš„æ–¹å¼æ‰“å°ç»“æ„ä½“ï¼Œä»¥ä¾¿å½“æˆ‘ä»¬è°ƒè¯•ä»£ç æ—¶èƒ½çœ‹åˆ°å®ƒçš„å€¼

è¿™æ ·è°ƒæ•´åå†æ¬¡è¿è¡Œç¨‹åºåï¼Œä»ç„¶èƒ½çœ‹åˆ°ä¸€ä¸ªé”™è¯¯

```rust
error[E0277]: `Rectangle` doesn't implement `Debug`
```

ä¸è¿‡ç¼–è¯‘å™¨åˆä¸€æ¬¡ç»™å‡ºäº†ä¸€ä¸ªæœ‰å¸®åŠ©çš„ä¿¡æ¯ï¼š

```rust
= help: the trait `Debug` is not implemented for `Rectangle`
= note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
```

Rust **ç¡®å®** åŒ…å«äº†æ‰“å°å‡ºè°ƒè¯•ä¿¡æ¯çš„åŠŸèƒ½ï¼Œä¸è¿‡æˆ‘ä»¬å¿…é¡»ä¸ºç»“æ„ä½“æ˜¾å¼é€‰æ‹©è¿™ä¸ªåŠŸèƒ½ã€‚ä¸ºæ­¤ï¼Œåœ¨ç»“æ„ä½“å®šä¹‰ä¹‹å‰åŠ ä¸Šå¤–éƒ¨å±æ€§ `#[derive(Debug)]`

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
```

å¦ä¸€ç§ä½¿ç”¨ `Debug` æ ¼å¼æ‰“å°æ•°å€¼çš„æ–¹æ³•æ˜¯ä½¿ç”¨ `dbg!` å®ã€‚`dbg!` å®æ¥æ”¶ä¸€ä¸ªè¡¨è¾¾å¼çš„æ‰€æœ‰æƒï¼ˆä¸ `println!` å®ç›¸åï¼Œåè€…æ¥æ”¶çš„æ˜¯å¼•ç”¨ï¼‰ï¼Œæ‰“å°å‡ºä»£ç ä¸­è°ƒç”¨ dbg! å®æ—¶æ‰€åœ¨çš„æ–‡ä»¶å’Œè¡Œå·ï¼Œä»¥åŠè¯¥è¡¨è¾¾å¼çš„ç»“æœå€¼ï¼Œå¹¶è¿”å›è¯¥å€¼çš„æ‰€æœ‰æƒ

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```

æˆ‘ä»¬å¯ä»¥æŠŠ `dbg!` æ”¾åœ¨è¡¨è¾¾å¼ `30 * scale` å‘¨å›´ï¼Œå› ä¸º `dbg!` è¿”å›è¡¨è¾¾å¼çš„å€¼çš„æ‰€æœ‰æƒï¼Œæ‰€ä»¥ `width` å­—æ®µå°†è·å¾—ç›¸åŒçš„å€¼ï¼Œå°±åƒæˆ‘ä»¬åœ¨é‚£é‡Œæ²¡æœ‰ `dbg!` è°ƒç”¨ä¸€æ ·ã€‚æˆ‘ä»¬ä¸å¸Œæœ› `dbg!` æ‹¥æœ‰ `rect1` çš„æ‰€æœ‰æƒï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨ä¸‹ä¸€æ¬¡è°ƒç”¨ `dbg!` æ—¶ä¼ é€’ä¸€ä¸ªå¼•ç”¨ã€‚ä¸‹é¢æ˜¯è¿™ä¸ªä¾‹å­çš„è¾“å‡ºç»“æœï¼š

```rust
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &rect1 = Rectangle {
    width: 60,
    height: 50,
}
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç¬¬ä¸€ç‚¹è¾“å‡ºæ¥è‡ª *src/main.rs* ç¬¬ 10 è¡Œï¼Œæˆ‘ä»¬æ­£åœ¨è°ƒè¯•è¡¨è¾¾å¼ `30 * scale`ï¼Œå…¶ç»“æœå€¼æ˜¯60ï¼ˆä¸ºæ•´æ•°å®ç°çš„ `Debug` æ ¼å¼åŒ–æ˜¯åªæ‰“å°å®ƒä»¬çš„å€¼ï¼‰ã€‚åœ¨ *src/main.rs* ç¬¬ 14è¡Œ çš„ `dbg!` è°ƒç”¨è¾“å‡º `&rect1` çš„å€¼ï¼Œå³ `Rectangle` ç»“æ„ã€‚è¿™ä¸ªè¾“å‡ºä½¿ç”¨äº†æ›´ä¸ºæ˜“è¯»çš„ `Debug` æ ¼å¼ã€‚å½“ä½ è¯•å›¾å¼„æ¸…æ¥šä½ çš„ä»£ç åœ¨åšä»€ä¹ˆæ—¶ï¼Œ`dbg!` å®å¯èƒ½çœŸçš„å¾ˆæœ‰å¸®åŠ©!

é™¤äº† `Debug` traitï¼ŒRust è¿˜ä¸ºæˆ‘ä»¬æä¾›äº†å¾ˆå¤šå¯ä»¥é€šè¿‡ `derive` å±æ€§æ¥ä½¿ç”¨çš„ traitï¼Œä»–ä»¬å¯ä»¥ä¸ºæˆ‘ä»¬çš„è‡ªå®šä¹‰ç±»å‹å¢åŠ å®ç”¨çš„è¡Œä¸º

#### 5.2.4 æ€»ç»“

+ `std::fmt::Display`
+ `std::fmt::Debug`
+ `#[derive(Debug)]`
+ `{:?}`
+ `{:#?}`



### 5.3 struct æ–¹æ³•

#### 5.3.1 æ–¹æ³•çš„åˆ›å»ºè§„åˆ™

+ **æ–¹æ³•**ï¼ˆmethodï¼‰ä¸å‡½æ•°ç±»ä¼¼ï¼šå®ƒä»¬ä½¿ç”¨ `fn` å…³é”®å­—å’Œåç§°å£°æ˜ï¼Œå¯ä»¥æ‹¥æœ‰å‚æ•°å’Œè¿”å›å€¼ï¼ŒåŒæ—¶åŒ…å«åœ¨æŸå¤„è°ƒç”¨è¯¥æ–¹æ³•æ—¶ä¼šæ‰§è¡Œçš„ä»£ç ã€‚

+ ä¸è¿‡æ–¹æ³•ä¸å‡½æ•°æ˜¯ä¸åŒçš„ï¼š

  + å®ƒä»¬åœ¨ç»“æ„ä½“çš„ä¸Šä¸‹æ–‡ä¸­è¢«å®šä¹‰ï¼ˆæˆ–è€…æ˜¯æšä¸¾æˆ– trait å¯¹è±¡çš„ä¸Šä¸‹æ–‡ï¼‰
  + ç¬¬ä¸€ä¸ªå‚æ•°æ€»æ˜¯ `self`ï¼Œå®ƒä»£è¡¨è°ƒç”¨è¯¥æ–¹æ³•çš„ç»“æ„ä½“å®ä¾‹

  ```rust
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }
  
  impl Rectangle {
      fn area(&self) -> u32 {
          self.width * self.height
      }
  }
  
  fn main() {
      let rect1 = Rectangle {
          width: 30,
          height: 50,
      };
  
      println!(
          "The area of the rectangle is {} square pixels.",
          rect1.area()
      );
  }
  ```

+ åœ¨`impl`å—é‡Œå®šä¹‰æ–¹æ³•

+ æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°å¯ä»¥æ˜¯`&self`ï¼Œä¹Ÿå¯ä»¥è·å¾—å…¶æ‰€æœ‰æƒæˆ–å¯å˜å€Ÿç”¨ã€‚å’Œå…¶å®ƒå‚æ•°ä¸€æ ·

+ æ›´è‰¯å¥½çš„ä»£ç ç»„ç»‡

#### 5.3.2 æ–¹æ³•è°ƒç”¨çš„è¿ç®—ç¬¦

+ C/C++ï¼š`object -> something()` å°±å’Œ `(*object).something()`ä¸€æ ·ï¼Œéœ€è¦å…ˆè§£å¼•ç”¨ï¼ˆdereferenceï¼‰
+ Rustæ²¡æœ‰ `->`è¿ç®—ç¬¦
+ Rustä¼šè‡ªåŠ¨å¼•ç”¨æˆ–è§£å¼•ç”¨
  + åœ¨è°ƒç”¨æ–¹æ³•æ—¶å°±ä¼šå‘ç”Ÿè¿™ç§è¡Œä¸º
+ åœ¨è°ƒç”¨æ–¹æ³•æ—¶ï¼ŒRustæ ¹æ®æƒ…å†µè‡ªåŠ¨æ·»åŠ `&`ã€`&mut`æˆ–`*`ï¼Œä»¥ä¾¿ object å¯ä»¥åŒ¹é…æ–¹æ³•çš„ç­¾å
+ ä¸‹é¢ä¸¤è¡Œä»£ç æ•ˆæœç›¸åŒ
  + `p1.distance(&p2);`
  + `(&p1).distance(&p2);`

#### 5.3.3 æ–¹æ³•å‚æ•°

æ–¹æ³•å¯ä»¥æœ‰å¤šä¸ªå‚æ•°

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```

#### 5.3.4 å…³è”å‡½æ•°

+ å¯ä»¥åœ¨`impl`å—é‡Œå®šä¹‰ä¸æŠŠ`self`ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°çš„å‡½æ•°ï¼Œå®ƒä»¬å«åšå…³è”å‡½æ•°ï¼ˆä¸æ˜¯æ–¹æ³•ï¼‰

  + ä¾‹å¦‚ï¼š`String::from()`

+ å…³è”å‡½æ•°é€šå¸¸ç”¨äºæ„é€ å™¨

  ```rust
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }
  
  impl Rectangle {
      fn square(size: u32) -> Self {
          Self {
              width: size,
              height: size,
          }
      }
  }
  
  fn main() {
      let sq = Rectangle::square(3);
  }
  ```

+ `::`ç¬¦å·

  + å…³è”å‡½æ•°
  + æ¨¡å—åˆ›å»ºçš„å‘½åç©ºé—´

#### 5.3.4 å¤šä¸ª impl å—

+ æ¯ä¸ª`struct`å…è®¸æ‹¥æœ‰å¤šä¸ª`impl`å—

  ```rust
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }
  
  impl Rectangle {
      fn area(&self) -> u32 {
          self.width * self.height
      }
  }
  
  impl Rectangle {
      fn can_hold(&self, other: &Rectangle) -> bool {
          self.width > other.width && self.height > other.height
      }
  }
  
  fn main() {
      let rect1 = Rectangle {
          width: 30,
          height: 50,
      };
      let rect2 = Rectangle {
          width: 10,
          height: 40,
      };
      let rect3 = Rectangle {
          width: 60,
          height: 45,
      };
  
      println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
      println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
  }
  ```

> ç»“æ„ä½“è®©ä½ å¯ä»¥åˆ›å»ºå‡ºåœ¨ä½ çš„é¢†åŸŸä¸­æœ‰æ„ä¹‰çš„è‡ªå®šä¹‰ç±»å‹ã€‚é€šè¿‡ç»“æ„ä½“ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç›¸å…³è”çš„æ•°æ®ç‰‡æ®µè”ç³»èµ·æ¥å¹¶å‘½åå®ƒä»¬ï¼Œè¿™æ ·å¯ä»¥ä½¿å¾—ä»£ç æ›´åŠ æ¸…æ™°ã€‚åœ¨ `impl` å—ä¸­ï¼Œä½ å¯ä»¥å®šä¹‰ä¸ä½ çš„ç±»å‹ç›¸å…³è”çš„å‡½æ•°ï¼Œè€Œæ–¹æ³•æ˜¯ä¸€ç§ç›¸å…³è”çš„å‡½æ•°ï¼Œè®©ä½ æŒ‡å®šç»“æ„ä½“çš„å®ä¾‹æ‰€å…·æœ‰çš„è¡Œä¸ºã€‚

ä½†ç»“æ„ä½“å¹¶ä¸æ˜¯åˆ›å»ºè‡ªå®šä¹‰ç±»å‹çš„å”¯ä¸€æ–¹æ³•ï¼šè®©æˆ‘ä»¬è½¬å‘ Rust çš„æšä¸¾åŠŸèƒ½ï¼Œä¸ºä½ çš„å·¥å…·ç®±å†æ·»ä¸€ä¸ªå·¥å…·



## 6ã€æšä¸¾ä¸æ¨¡å¼åŒ¹é…

**æšä¸¾**ï¼ˆ*enumerations*ï¼‰ï¼Œä¹Ÿè¢«ç§°ä½œ *enums*ã€‚æšä¸¾å…è®¸ä½ é€šè¿‡åˆ—ä¸¾å¯èƒ½çš„ **æˆå‘˜**ï¼ˆ*variants*ï¼‰ æ¥å®šä¹‰ä¸€ä¸ªç±»å‹ã€‚

### 6.1 æšä¸¾çš„å®šä¹‰

+ IPåœ°å€ï¼šIPv4ã€IPv6

  ```rust
  enum IpAddrKind {
      V4,
      V6,
  }
  ```

  `V4` å’Œ `V6`ï¼Œè¢«ç§°ä¸ºæšä¸¾çš„ **æˆå‘˜**ï¼ˆ*variants*ï¼‰

#### 6.1.1 æšä¸¾å€¼

å¯ä»¥åƒè¿™æ ·åˆ›å»º `IpAddrKind` ä¸¤ä¸ªä¸åŒæˆå‘˜çš„å®ä¾‹ï¼š

```rust
let four = IpAddrKind::V4
let six = IpAddrKind::V6
```

==æ³¨æ„æšä¸¾çš„æˆå‘˜ä½äºå…¶æ ‡è¯†ç¬¦çš„å‘½åç©ºé—´ä¸­ï¼Œå¹¶ä½¿ç”¨ä¸¤ä¸ªå†’å·åˆ†å¼€==ã€‚è¿™ä¹ˆè®¾è®¡çš„ç›Šå¤„æ˜¯ç°åœ¨ `IpAddrKind::V4` å’Œ `IpAddrKind::V6` éƒ½æ˜¯ `IpAddrKind` ç±»å‹çš„ã€‚ä¾‹å¦‚ï¼Œæ¥ç€å¯ä»¥å®šä¹‰ä¸€ä¸ªå‡½æ•°æ¥è·å–ä»»ä½• `IpAddrKind`ï¼š

```rust
fn route(ip_kind: IpAddrKind) {}
```

ç°åœ¨å¯ä»¥ä½¿ç”¨ä»»ä¸€æˆå‘˜æ¥è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼š

```rust
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```

#### 6.1.2 å°†æ•°æ®é™„åŠ åˆ°æšä¸¾çš„å˜ä½“ä¸­

ä½¿ç”¨æšä¸¾ç”šè‡³è¿˜æœ‰æ›´å¤šä¼˜åŠ¿ã€‚è¿›ä¸€æ­¥è€ƒè™‘ä¸€ä¸‹æˆ‘ä»¬çš„ IP åœ°å€ç±»å‹ï¼Œç›®å‰æ²¡æœ‰ä¸€ä¸ªå­˜å‚¨å®é™… IP åœ°å€ **æ•°æ®** çš„æ–¹æ³•ï¼›åªçŸ¥é“å®ƒæ˜¯ä»€ä¹ˆ **ç±»å‹** çš„ã€‚è€ƒè™‘åˆ°å·²ç»åœ¨ç¬¬äº”ç« å­¦ä¹ è¿‡ç»“æ„ä½“äº†ï¼Œä½ å¯èƒ½ä¼šåƒè¿™æ ·å¤„ç†é—®é¢˜ï¼š

```rust
fn main() {
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
}
```

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ç§æ›´ç®€æ´çš„æ–¹å¼æ¥è¡¨è¾¾ç›¸åŒçš„æ¦‚å¿µï¼Œä»…ä»…ä½¿ç”¨æšä¸¾å¹¶å°†æ•°æ®ç›´æ¥æ”¾è¿›æ¯ä¸€ä¸ªæšä¸¾æˆå‘˜è€Œä¸æ˜¯å°†æšä¸¾ä½œä¸ºç»“æ„ä½“çš„ä¸€éƒ¨åˆ†ã€‚`IpAddr` æšä¸¾çš„æ–°å®šä¹‰è¡¨æ˜äº† `V4` å’Œ `V6` æˆå‘˜éƒ½å…³è”äº† `String` å€¼ï¼š

```rust
fn main() {
    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
}
```

ä¼˜ç‚¹ï¼š

+ ä¸éœ€è¦é¢å¤–ä½¿ç”¨`struct`
+ æ¯ä¸ªå˜ä½“å¯ä»¥æ‹¥æœ‰ä¸åŒçš„ç±»å‹ä»¥åŠå…³è”çš„æ•°æ®é‡

ç”¨æšä¸¾æ›¿ä»£ç»“æ„ä½“è¿˜æœ‰å¦ä¸€ä¸ªä¼˜åŠ¿ï¼šæ¯ä¸ªæˆå‘˜å¯ä»¥å¤„ç†ä¸åŒç±»å‹å’Œæ•°é‡çš„æ•°æ®ã€‚IPv4 ç‰ˆæœ¬çš„ IP åœ°å€æ€»æ˜¯å«æœ‰å››ä¸ªå€¼åœ¨ 0 å’Œ 255 ä¹‹é—´çš„æ•°å­—éƒ¨åˆ†ã€‚å¦‚æœæˆ‘ä»¬æƒ³è¦å°† `V4` åœ°å€å­˜å‚¨ä¸ºå››ä¸ª `u8` å€¼è€Œ `V6` åœ°å€ä»ç„¶è¡¨ç°ä¸ºä¸€ä¸ª `String`ï¼Œè¿™å°±ä¸èƒ½ä½¿ç”¨ç»“æ„ä½“äº†ã€‚æšä¸¾åˆ™å¯ä»¥è½»æ˜“çš„å¤„ç†è¿™ä¸ªæƒ…å†µï¼š

```rust
fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
}
```

#### 6.1.3 æ ‡å‡†åº“ä¸­çš„IpAddr

äº‹å®è¯æ˜å­˜å‚¨å’Œç¼–ç  IP åœ°å€å®åœ¨æ˜¯å¤ªå¸¸è§äº†ä»¥è‡³äºæ ‡å‡†åº“æä¾›äº†ä¸€ä¸ªå¼€ç®±å³ç”¨çš„å®šä¹‰ï¼è®©æˆ‘ä»¬çœ‹çœ‹æ ‡å‡†åº“æ˜¯å¦‚ä½•å®šä¹‰ `IpAddr` çš„ï¼šå®ƒæ­£æœ‰ç€è·Ÿæˆ‘ä»¬å®šä¹‰å’Œä½¿ç”¨çš„ä¸€æ ·çš„æšä¸¾å’Œæˆå‘˜ï¼Œä¸è¿‡å®ƒå°†æˆå‘˜ä¸­çš„åœ°å€æ•°æ®åµŒå…¥åˆ°äº†ä¸¤ä¸ªä¸åŒå½¢å¼çš„ç»“æ„ä½“ä¸­ï¼Œå®ƒä»¬å¯¹ä¸åŒçš„æˆå‘˜çš„å®šä¹‰æ˜¯ä¸åŒçš„ï¼š

```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

å¯ä»¥å°†ä»»æ„ç±»å‹çš„æ•°æ®æ”¾å…¥æšä¸¾æˆå‘˜ä¸­ï¼šä¾‹å¦‚å­—ç¬¦ä¸²ã€æ•°å­—ç±»å‹æˆ–è€…ç»“æ„ä½“ã€‚ç”šè‡³å¯ä»¥åŒ…å«å¦ä¸€ä¸ªæšä¸¾ï¼å¦å¤–ï¼Œæ ‡å‡†åº“ä¸­çš„ç±»å‹é€šå¸¸å¹¶ä¸æ¯”ä½ è®¾æƒ³å‡ºæ¥çš„è¦å¤æ‚å¤šå°‘ã€‚

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

#### 6.1.4 ä¸ºæšä¸¾å®šä¹‰æ–¹æ³•

ç»“æ„ä½“å’Œæšä¸¾è¿˜æœ‰å¦ä¸€ä¸ªç›¸ä¼¼ç‚¹ï¼šå°±åƒå¯ä»¥ä½¿ç”¨ `impl` æ¥ä¸ºç»“æ„ä½“å®šä¹‰æ–¹æ³•é‚£æ ·ï¼Œä¹Ÿå¯ä»¥åœ¨æšä¸¾ä¸Šå®šä¹‰æ–¹æ³•ã€‚è¿™æ˜¯ä¸€ä¸ªå®šä¹‰äºæˆ‘ä»¬ `Message` æšä¸¾ä¸Šçš„å«åš `call` çš„æ–¹æ³•ï¼š

```rust
fn main() {
    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32, i32),
    }

    impl Message {
        fn call(&self) {
            // åœ¨è¿™é‡Œå®šä¹‰æ–¹æ³•ä½“
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
}
```

#### 6.1.5 Optionæšä¸¾

+ å®šä¹‰äºæ ‡å‡†åº“ä¸­
+ åœ¨`Prelude`ï¼ˆé¢„å¯¼å…¥æ¨¡å—ï¼‰ä¸­
+ æè¿°äº†ï¼šæŸä¸ªå€¼å¯èƒ½å­˜åœ¨ï¼ˆæŸç§ç±»å‹ï¼‰æˆ–ä¸å­˜åœ¨çš„æƒ…å†µ

Rust å¹¶æ²¡æœ‰å¾ˆå¤šå…¶ä»–è¯­è¨€ä¸­æœ‰çš„ç©ºå€¼åŠŸèƒ½ã€‚**ç©ºå€¼**ï¼ˆ*Null* ï¼‰æ˜¯ä¸€ä¸ªå€¼ï¼Œå®ƒä»£è¡¨æ²¡æœ‰å€¼ã€‚åœ¨æœ‰ç©ºå€¼çš„è¯­è¨€ä¸­ï¼Œå˜é‡æ€»æ˜¯è¿™ä¸¤ç§çŠ¶æ€ä¹‹ä¸€ï¼šç©ºå€¼å’Œéç©ºå€¼ã€‚

Nullå¼•ç”¨ï¼šThe Billion Dollar Mistake

ç©ºå€¼çš„é—®é¢˜åœ¨äºå½“ä½ å°è¯•åƒä¸€ä¸ªéç©ºå€¼é‚£æ ·ä½¿ç”¨ä¸€ä¸ªç©ºå€¼ï¼Œä¼šå‡ºç°æŸç§å½¢å¼çš„é”™è¯¯ã€‚å› ä¸ºç©ºå’Œéç©ºçš„å±æ€§æ— å¤„ä¸åœ¨ï¼Œéå¸¸å®¹æ˜“å‡ºç°è¿™ç±»é”™è¯¯ã€‚

ç©ºå€¼å°è¯•è¡¨è¾¾çš„æ¦‚å¿µä»ç„¶æ˜¯æœ‰æ„ä¹‰çš„ï¼šç©ºå€¼æ˜¯ä¸€ä¸ªå› ä¸ºæŸç§åŸå› ç›®å‰æ— æ•ˆæˆ–ç¼ºå¤±çš„å€¼ã€‚

é—®é¢˜ä¸åœ¨äºæ¦‚å¿µè€Œåœ¨äºå…·ä½“çš„å®ç°ã€‚ä¸ºæ­¤ï¼ŒRust å¹¶æ²¡æœ‰ç©ºå€¼ï¼Œä¸è¿‡å®ƒç¡®å®æ‹¥æœ‰ä¸€ä¸ªå¯ä»¥ç¼–ç å­˜åœ¨æˆ–ä¸å­˜åœ¨æ¦‚å¿µçš„æšä¸¾ã€‚è¿™ä¸ªæšä¸¾æ˜¯ `Option<T>`ï¼Œå®ƒåœ¨æ ‡å‡†åº“ä¸­å®šä¹‰ã€‚

```rust
enum Option<T> {
    Some(T),
    None,
}
```

Optionæšä¸¾åŒ…å«åœ¨`Prelude`ï¼ˆé¢„å¯¼å…¥æ¨¡å—ï¼‰ä¸­ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ï¼š

+ `Option<T>`
+ `Some(T)`
+ `None`

`Option<T>` æ¯” `Null` å¥½åœ¨å“ªï¼Ÿ

+ `Option<T>` å’Œ `T` æ˜¯ä¸åŒçš„ç±»å‹ï¼Œä¸å¯ä»¥æŠŠ `Option<T>`ç›´æ¥å½“æˆ`T`

  ```rust
  let x: i8 = 5;
  let y: Option<i8> = Some(5);
  
  let sum = x + y;
  ```

  ```rust
  $ cargo run
     Compiling enums v0.1.0 (file:///projects/enums)
  error[E0277]: cannot add `Option<i8>` to `i8`
   --> src/main.rs:5:17
    |
  5 |     let sum = x + y;
    |                 ^ no implementation for `i8 + Option<i8>`
    |
    = help: the trait `Add<Option<i8>>` is not implemented for `i8`
  
  For more information about this error, try `rustc --explain E0277`.
  error: could not compile `enums` due to previous error
  ```

é”™è¯¯ä¿¡æ¯æ„å‘³ç€ Rust ä¸çŸ¥é“è¯¥å¦‚ä½•å°† `Option<i8>` ä¸ `i8` ç›¸åŠ ï¼Œå› ä¸ºå®ƒä»¬çš„ç±»å‹ä¸åŒã€‚å½“åœ¨ Rust ä¸­æ‹¥æœ‰ä¸€ä¸ªåƒ `i8` è¿™æ ·ç±»å‹çš„å€¼æ—¶ï¼Œç¼–è¯‘å™¨ç¡®ä¿å®ƒæ€»æ˜¯æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„å€¼ã€‚æˆ‘ä»¬å¯ä»¥è‡ªä¿¡ä½¿ç”¨è€Œæ— éœ€åšç©ºå€¼æ£€æŸ¥ã€‚åªæœ‰å½“ä½¿ç”¨ `Option<i8>`ï¼ˆæˆ–è€…ä»»ä½•ç”¨åˆ°çš„ç±»å‹ï¼‰çš„æ—¶å€™éœ€è¦æ‹…å¿ƒå¯èƒ½æ²¡æœ‰å€¼ï¼Œè€Œç¼–è¯‘å™¨ä¼šç¡®ä¿æˆ‘ä»¬åœ¨ä½¿ç”¨å€¼ä¹‹å‰å¤„ç†äº†ä¸ºç©ºçš„æƒ…å†µã€‚

æ¢å¥è¯è¯´ï¼Œåœ¨å¯¹ `Option<T>` è¿›è¡Œ `T` çš„è¿ç®—ä¹‹å‰å¿…é¡»å°†å…¶è½¬æ¢ä¸º `T`



### 6.2 matchæ§åˆ¶æµç»“æ„

Rust æœ‰ä¸€ä¸ªå«åš `match` çš„æä¸ºå¼ºå¤§çš„æ§åˆ¶æµè¿ç®—ç¬¦ï¼Œå®ƒå…è®¸æˆ‘ä»¬å°†ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—çš„æ¨¡å¼ç›¸æ¯”è¾ƒï¼Œå¹¶æ ¹æ®ç›¸åŒ¹é…çš„æ¨¡å¼æ‰§è¡Œç›¸åº”ä»£ç ã€‚æ¨¡å¼å¯ç”±å­—é¢å€¼ã€å˜é‡ã€é€šé…ç¬¦å’Œè®¸å¤šå…¶ä»–å†…å®¹æ„æˆã€‚

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

fn main() {}
```

#### 6.2.1 ç»‘å®šå€¼çš„æ¨¡å¼

åŒ¹é…åˆ†æ”¯çš„å¦ä¸€ä¸ªæœ‰ç”¨çš„åŠŸèƒ½æ˜¯å¯ä»¥ç»‘å®šåŒ¹é…çš„æ¨¡å¼çš„éƒ¨åˆ†å€¼ã€‚è¿™ä¹Ÿå°±æ˜¯å¦‚ä½•ä»æšä¸¾æˆå‘˜ä¸­æå–å€¼çš„

```rust
#[derive(Debug)] // è¿™æ ·å¯ä»¥ç«‹åˆ»çœ‹åˆ°å·çš„åç§°
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}

fn main() {
    let state = value_in_cents(Coin::Quarter(UsState::Alaska));
    println!("{}", state)
}

```

#### 6.2.2 åŒ¹é… Option\<T>

æˆ‘ä»¬åœ¨ä¹‹å‰çš„éƒ¨åˆ†ä¸­ä½¿ç”¨ `Option<T>` æ—¶ï¼Œæ˜¯ä¸ºäº†ä» `Some` ä¸­å–å‡ºå…¶å†…éƒ¨çš„ `T` å€¼ï¼›æˆ‘ä»¬è¿˜å¯ä»¥åƒå¤„ç† `Coin` æšä¸¾é‚£æ ·ä½¿ç”¨ `match` å¤„ç† `Option<T>`ï¼åªä¸è¿‡è¿™å›æ¯”è¾ƒçš„ä¸å†æ˜¯ç¡¬å¸ï¼Œè€Œæ˜¯ `Option<T>` çš„æˆå‘˜ï¼Œä½† `match` è¡¨è¾¾å¼çš„å·¥ä½œæ–¹å¼ä¿æŒä¸å˜ã€‚

æ¯”å¦‚æˆ‘ä»¬æƒ³è¦ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒè·å–ä¸€ä¸ª `Option<i32>` ï¼Œå¦‚æœå…¶ä¸­å«æœ‰ä¸€ä¸ªå€¼ï¼Œå°†å…¶åŠ ä¸€ã€‚å¦‚æœå…¶ä¸­æ²¡æœ‰å€¼ï¼Œå‡½æ•°åº”è¯¥è¿”å› `None` å€¼ï¼Œè€Œä¸å°è¯•æ‰§è¡Œä»»ä½•æ“ä½œã€‚

```rust
fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
```

#### 6.2.3 matchåŒ¹é…å¿…é¡»ç©·ä¸¾æ‰€æœ‰çš„å¯èƒ½

`match` è¿˜æœ‰å¦ä¸€æ–¹é¢éœ€è¦è®¨è®ºï¼šè¿™äº›åˆ†æ”¯å¿…é¡»è¦†ç›–äº†æ‰€æœ‰çš„å¯èƒ½æ€§ã€‚è€ƒè™‘ä¸€ä¸‹ `plus_one` å‡½æ•°çš„è¿™ä¸ªç‰ˆæœ¬ï¼Œå®ƒæœ‰ä¸€ä¸ª bug å¹¶ä¸èƒ½ç¼–è¯‘ï¼š

```rust
fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
```

```rust
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --> src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option<i32>`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
```

Rust çŸ¥é“æˆ‘ä»¬æ²¡æœ‰è¦†ç›–æ‰€æœ‰å¯èƒ½çš„æƒ…å†µç”šè‡³çŸ¥é“å“ªäº›æ¨¡å¼è¢«å¿˜è®°äº†ï¼Rust ä¸­çš„åŒ¹é…æ˜¯ **ç©·å°½çš„**ï¼ˆ*exhaustive*ï¼‰ï¼šå¿…é¡»ç©·ä¸¾åˆ°æœ€åçš„å¯èƒ½æ€§æ¥ä½¿ä»£ç æœ‰æ•ˆã€‚ç‰¹åˆ«çš„åœ¨è¿™ä¸ª `Option<T>` çš„ä¾‹å­ä¸­ï¼ŒRust é˜²æ­¢æˆ‘ä»¬å¿˜è®°æ˜ç¡®çš„å¤„ç† `None` çš„æƒ…å†µï¼Œè¿™è®©æˆ‘ä»¬å…äºå‡è®¾æ‹¥æœ‰ä¸€ä¸ªå®é™…ä¸Šä¸ºç©ºçš„å€¼ï¼Œä»è€Œä½¿ä¹‹å‰æåˆ°çš„ä»·å€¼äº¿ä¸‡çš„é”™è¯¯ä¸å¯èƒ½å‘ç”Ÿã€‚

#### 6.2.4 é€šé…æ¨¡å¼å’Œ _ å ä½ç¬¦

æˆ‘ä»¬å¸Œæœ›å¯¹ä¸€äº›ç‰¹å®šçš„å€¼é‡‡å–ç‰¹æ®Šæ“ä½œï¼Œè€Œå¯¹å…¶ä»–çš„å€¼é‡‡å–é»˜è®¤æ“ä½œã€‚è¿™æ—¶ï¼Œå¯ä»¥ä½¿ç”¨é€šé…æ¨¡å¼otheræˆ– _ å ä½ç¬¦æ¥æ›¿ä»£å…¶ä½™æ²¡åˆ—å‡ºçš„å€¼ã€‚

```rust
fn main() {
    let v = 1u8;

    match v {
        1 => println!("one"),
        3 => println!("three"),
        5 => println!("five"),
        7 => println!("seven"),
        _other => println!("{}", _other),
    }

    match v {
        1 => println!("one"),
        3 => println!("three"),
        5 => println!("five"),
        7 => println!("seven"),
        _ => (),
    }
}
```

`other`å’Œ`_`çš„ä½œç”¨æ˜¯ç±»ä¼¼çš„ï¼Œåªä¸è¿‡ä½¿ç”¨`other`å¯ä»¥è·å–åˆ°å€¼ã€‚



### 6.3 if let ç®€æ´æ§åˆ¶æµ

`if let`å¤„ç†åªå…³å¿ƒä¸€ç§åŒ¹é…è€Œå¿½ç•¥å…¶å®ƒåŒ¹é…çš„æƒ…å†µ

```rust
fn main() {
    let v = Some(0u8);
    match v {
        Some(3) => println!("three"),
        _ => (),
    }

    if let Some(3) = v {
        println!("three");
    }
}
```

`if let` è¯­æ³•è·å–é€šè¿‡ç­‰å·åˆ†éš”çš„ä¸€ä¸ªæ¨¡å¼å’Œä¸€ä¸ªè¡¨è¾¾å¼ã€‚å®ƒçš„å·¥ä½œæ–¹å¼ä¸ `match` ç›¸åŒï¼Œè¿™é‡Œçš„è¡¨è¾¾å¼å¯¹åº” `match` è€Œæ¨¡å¼åˆ™å¯¹åº”ç¬¬ä¸€ä¸ªåˆ†æ”¯ã€‚

ä½¿ç”¨ `if let` æ„å‘³ç€ç¼–å†™æ›´å°‘ä»£ç ï¼Œæ›´å°‘çš„ç¼©è¿›å’Œæ›´å°‘çš„æ ·æ¿ä»£ç ã€‚ç„¶è€Œï¼Œè¿™æ ·ä¼šå¤±å» `match` å¼ºåˆ¶è¦æ±‚çš„ç©·å°½æ€§æ£€æŸ¥ã€‚`match` å’Œ `if let` ä¹‹é—´çš„é€‰æ‹©ä¾èµ–ç‰¹å®šçš„ç¯å¢ƒä»¥åŠå¢åŠ ç®€æ´åº¦å’Œå¤±å»ç©·å°½æ€§æ£€æŸ¥çš„æƒè¡¡å–èˆã€‚

å¯ä»¥è®¤ä¸º `if let` æ˜¯ `match` çš„ä¸€ä¸ªè¯­æ³•ç³–ï¼Œå®ƒå½“å€¼åŒ¹é…æŸä¸€æ¨¡å¼æ—¶æ‰§è¡Œä»£ç è€Œå¿½ç•¥æ‰€æœ‰å…¶ä»–å€¼ã€‚

å¯ä»¥åœ¨ `if let` ä¸­åŒ…å«ä¸€ä¸ª `else`ã€‚`else` å—ä¸­çš„ä»£ç ä¸ `match` è¡¨è¾¾å¼ä¸­çš„ `_` åˆ†æ”¯å—ä¸­çš„ä»£ç ç›¸åŒï¼Œè¿™æ ·çš„ `match` è¡¨è¾¾å¼å°±ç­‰åŒäº `if let` å’Œ `else`ã€‚ 

```rust
fn main() {
    let v = Some(0u8);
    match v {
        Some(3) => println!("three"),
        _ => (),
    }

    if let Some(3) = v {
        println!("three");
    } else {
        println!("others");
    }
}
```



## 7ã€Packageã€Crateã€Module

Rustçš„ä»£ç ç»„ç»‡

+ ä»£ç ç»„ç»‡ä¸»è¦åŒ…æ‹¬ï¼š

  + å“ªäº›ç»†èŠ‚å¯ä»¥æš´éœ²ï¼Œå“ªäº›ç»†èŠ‚æ˜¯ç§æœ‰çš„

  + ä½œç”¨åŸŸå†…å“ªäº›åç§°æ˜¯æœ‰æ•ˆçš„

+ æ¨¡å—ç³»ç»Ÿï¼š

  + Packageï¼ˆåŒ…ï¼‰ï¼šCargoçš„ç‰¹æ€§ï¼Œè®©ä½ æ„å»ºã€æµ‹è¯•ã€å…±äº«crate
  + Crateï¼ˆå•å…ƒåŒ…ï¼‰ï¼šä¸€ä¸ªæ¨¡å—æ ‘ï¼Œå®ƒå¯ä»¥äº§ç”Ÿä¸€ä¸ªlibraryæˆ–å¯æ‰§è¡Œæ–‡ä»¶
  + Moduleï¼ˆæ¨¡å—ï¼‰ã€useï¼šè®©ä½ æ§åˆ¶ä»£ç çš„ç»„ç»‡ã€ä½œç”¨åŸŸã€ç§æœ‰è·¯å¾„
  + Pathï¼ˆè·¯å¾„ï¼‰ï¼šä¸º`struct`ã€`function`æˆ–`module`ç­‰é¡¹å‘½åçš„æ–¹å¼

### 7.1 Packageå’ŒCrate

crate æ˜¯ Rust åœ¨ç¼–è¯‘æ—¶æœ€å°çš„ä»£ç å•ä½ã€‚å¦‚æœä½ ç”¨ `rustc` è€Œä¸æ˜¯ `cargo` æ¥ç¼–è¯‘ä¸€ä¸ªæ–‡ä»¶ï¼ˆç¬¬ä¸€ç« æˆ‘ä»¬è¿™ä¹ˆåšè¿‡ï¼‰ï¼Œç¼–è¯‘å™¨è¿˜æ˜¯ä¼šå°†é‚£ä¸ªæ–‡ä»¶è®¤ä½œä¸€ä¸ª crateã€‚ crate å¯ä»¥åŒ…å«æ¨¡å—ï¼Œæ¨¡å—å¯ä»¥å®šä¹‰åœ¨å…¶ä»–æ–‡ä»¶ï¼Œç„¶åå’Œ crate ä¸€èµ·ç¼–è¯‘ã€‚

#### 7.1.1 Crate

+ Crateçš„ç±»å‹

  + binary

  + library

+ Crate Root

  + æ˜¯æºä»£ç æ–‡ä»¶

  + Rustç¼–è¯‘å™¨ä»è¿™é‡Œå¼€å§‹ï¼Œç»„æˆä½ çš„Crateçš„æ ¹Module

#### 7.1.2 Package

+ åŒ…å«1ä¸ª`Cargo.toml`ï¼Œå®ƒæè¿°äº†å¦‚ä½•æ„å»ºè¿™äº›Crates
+ åªèƒ½åŒ…å« 0 - 1ä¸ª library crate
+ å¯ä»¥åŒ…å«ä»»æ„æ•°é‡çš„ binary crate
+ ä½†å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ª crate ï¼ˆlibrary æˆ– binaryï¼‰

#### 7.1.3 Cargoçš„æƒ¯ä¾‹

+ src / main.rs
  + binary crate çš„ crate root
  + crate åä¸ package åç›¸åŒ
+ src / lib.rs
  + package åŒ…å«ä¸€ä¸ª library crate
  + library crate çš„ crate root
  + crate åä¸ package åç›¸åŒ
+ Cargo æŠŠ crate root æ–‡ä»¶äº¤ç»™ rustc æ¥æ„å»º library æˆ– binary
+ ä¸€ä¸ª Package å¯ä»¥åŒæ—¶åŒ…å« src / main.rs å’Œ src / lib.rs
  + ä¸€ä¸ª binary crateï¼Œä¸€ä¸ª library crate
  + åç§°ä¸ package åç›¸åŒ
+ ä¸€ä¸ª Package å¯ä»¥æœ‰å¤šä¸ª binary crate
  + æ–‡ä»¶æ”¾åœ¨ src / binä¸‹
  + æ¯ä¸ªæ–‡ä»¶æ˜¯å•ç‹¬çš„ binary crate

#### 7.1.4 Crateçš„ä½œç”¨

+ å°†ç›¸å…³åŠŸèƒ½ç»„åˆåˆ°ä¸€ä¸ªä½œç”¨åŸŸå†…ï¼Œä¾¿äºåœ¨é¡¹ç›®é—´è¿›è¡Œå…±äº«
  + é˜²æ­¢å‘½åå†²çª
+ ä¾‹å¦‚ `rand crate`ï¼Œè®¿é—®å®ƒçš„åŠŸèƒ½éœ€è¦é€šè¿‡å®ƒçš„åå­—ï¼š`rand`



### 7.2 å®šä¹‰moduleæ¥æ§åˆ¶ä½œç”¨åŸŸå’Œç§æœ‰æ€§

#### 7.2.1 Module

+ åœ¨ä¸€ä¸ª crate å†…ï¼Œå°†ä»£ç è¿›è¡Œåˆ†ç»„
+ å¢åŠ å¯è¯»æ€§ï¼Œæ˜“äºå¤ç”¨
+ æ§åˆ¶æ¡ç›®ï¼ˆitemï¼‰ç§æœ‰æ€§ã€‚`public`ã€`private`

#### 7.2.2 å»ºç«‹Module

+ ä½¿ç”¨ `mod`å…³é”®å­—
+ moduleå¯ä»¥åµŒå¥—
+ å¯åŒ…å«å…¶å®ƒé¡¹ï¼ˆstructã€enumã€å¸¸é‡ã€traitã€å‡½æ•°ç­‰ï¼‰çš„å®šä¹‰

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}
        fn serve_order() {}
        fn take_payment() {}
    }
}
```

```rust
crate
 â””â”€â”€ front_of_house
     â”œâ”€â”€ hosting
     â”‚   â”œâ”€â”€ add_to_waitlist
     â”‚   â””â”€â”€ seat_at_table
     â””â”€â”€ serving
         â”œâ”€â”€ take_order
         â”œâ”€â”€ serve_order
         â””â”€â”€ take_payment
```

`src/main.rs` å’Œ `src/lib.rs` å«åš crate rootã€‚ä¹‹æ‰€ä»¥è¿™æ ·å«å®ƒä»¬æ˜¯å› ä¸ºè¿™ä¸¤ä¸ªæ–‡ä»¶çš„å†…å®¹éƒ½åˆ†åˆ«åœ¨ crate æ¨¡å—ç»“æ„çš„æ ¹ç»„æˆäº†ä¸€ä¸ªåä¸º `crate` çš„æ¨¡å—ï¼Œè¯¥ç»“æ„è¢«ç§°ä¸º *æ¨¡å—æ ‘*ï¼ˆ*module tree*ï¼‰



### 7.3 è·¯å¾„ï¼ˆPathï¼‰

ä¸ºäº†åœ¨Rustçš„æ¨¡å—ä¸­æ‰¾åˆ°æŸä¸ªæ¡ç›®ï¼Œéœ€è¦ä½¿ç”¨è·¯å¾„ã€‚è·¯å¾„æœ‰ä¸¤ç§å½¢å¼ï¼š

- **ç»å¯¹è·¯å¾„**ï¼ˆ*absolute path*ï¼‰ä» crate root å¼€å§‹ï¼Œä»¥ crate åæˆ–è€…å­—é¢å€¼ `crate` å¼€å¤´ã€‚
- **ç›¸å¯¹è·¯å¾„**ï¼ˆ*relative path*ï¼‰ä»å½“å‰æ¨¡å—å¼€å§‹ï¼Œä»¥ `self`ã€`super` æˆ–å½“å‰æ¨¡å—çš„æ ‡è¯†ç¬¦å¼€å¤´ã€‚

ç»å¯¹è·¯å¾„å’Œç›¸å¯¹è·¯å¾„éƒ½åè·Ÿä¸€ä¸ªæˆ–å¤šä¸ªç”±åŒå†’å·ï¼ˆ`::`ï¼‰åˆ†å‰²çš„æ ‡è¯†ç¬¦ã€‚

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    
    crate::front_of_house::hosting::add_to_waitlist();

    front_of_house::hosting::add_to_waitlist();
    
}
```

```rust
cr   
   Compiling path_demo v0.1.0 (E:\Files\Learning\BackEnd\Rust\Code\path_demo)
error[E0603]: module `hosting` is private
 --> src\lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --> src\lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --> src\lib.rs:11:21
   |
11 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --> src\lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `path_demo` due to 2 previous errors
```

é”™è¯¯ä¿¡æ¯è¯´ `hosting` æ¨¡å—æ˜¯ç§æœ‰çš„ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬æ‹¥æœ‰ `hosting` æ¨¡å—å’Œ `add_to_waitlist` å‡½æ•°çš„çš„æ­£ç¡®è·¯å¾„ï¼Œä½†æ˜¯ Rust ä¸è®©æˆ‘ä»¬ä½¿ç”¨ï¼Œå› ä¸ºå®ƒä¸èƒ½è®¿é—®ç§æœ‰ç‰‡æ®µã€‚

#### 7.3.1 ç§æœ‰è¾¹ç•Œï¼ˆprivacy boundaryï¼‰

+ æ¨¡å—ä¸ä»…å¯ä»¥ç”¨ç»„ç»‡ä»£ç ï¼Œè¿˜å¯ä»¥å®šä¹‰ç§æœ‰è¾¹ç•Œ
+ å¦‚æœæƒ³æŠŠå‡½æ•°æˆ–`struct`ç­‰è®¾ä¸ºç§æœ‰ï¼Œå¯ä»¥å°†å®ƒæ”¾åˆ°æŸä¸ªæ¨¡å—ä¸­
+ Rustä¸­æ‰€æœ‰çš„æ¡ç›®ï¼ˆå‡½æ•°ã€æ–¹æ³•ã€structã€enumã€æ¨¡å—ã€å¸¸é‡ï¼‰é»˜è®¤æ˜¯ç§æœ‰çš„
+ çˆ¶çº§æ¨¡å—æ— æ³•è®¿é—®å­æ¨¡å—ä¸­çš„ç§æœ‰æ¡ç›®
+ å­æ¨¡å—é‡Œå¯ä»¥ä½¿ç”¨æ‰€æœ‰ç¥–å…ˆæ¨¡å—ä¸­çš„æ¡ç›®
+ å¯ä»¥è°ƒç”¨åŒçº§æ¨¡å—ä¸­çš„ç§æœ‰æ¡ç›®

#### 7.3.2 pubå…³é”®å­—

+ ä½¿ç”¨ `pub`å…³é”®å­—æ¥å°†æŸäº›æ¡ç›®æ ‡è®°ä¸ºå…¬å…±çš„

  ```rust
  mod front_of_house {
      pub mod hosting {
          pub fn add_to_waitlist() {}
      }
  }
  
  pub fn eat_at_restaurant() {
  
      crate::front_of_house::hosting::add_to_waitlist();
  
      front_of_house::hosting::add_to_waitlist();
      
  }
  ```

#### 7.3.3 superå…³é”®å­—

+ superå…³é”®å­—ç”¨æ¥è®¿é—®çˆ¶çº§æ¨¡å—è·¯å¾„ä¸­çš„å†…å®¹ï¼Œç±»ä¼¼æ–‡ä»¶ç³»ç»Ÿä¸­çš„ `..`

  ```rust
  fn serve_order() {}
  
  mod back_of_house {
  
      fn fix_incorrect_order() {
          cook_order();
          super::serve_order();
          crate::serve_order();
      }
  
      fn cook_order() {}
  }
  ```

#### 7.3.4 pub struct

+ å°†`pub`å…³é”®å­—æ”¾åœ¨`struct`å‰

  + `struct`ä¸ºå…¬å…±çš„
  + `struct`çš„å­—æ®µé»˜è®¤æ˜¯ç§æœ‰çš„

+ `struct`çš„å­—æ®µéœ€è¦å•ç‹¬è®¾ç½®`pub`æ¥å˜æˆå…±æœ‰çš„

  ```rust
  mod back_of_house {
      pub struct Breakfast {
          pub toast: String,
          seasonal_fruit: String,
      }
  
      impl Breakfast {
          pub fn summer(toast: &str) -> Breakfast {
              Breakfast {
                  toast: String::from(toast),
                  seasonal_fruit: String::from("peaches"),
              }
          }
      }
  }
  
  pub fn eat_at_restaurant() {
      let mut meal = back_of_house::Breakfast::summer("Rye");
      meal.toast = String::from("Wheat");
      println!("I' d like {} toast please", meal.toast);
      meal.seasonal_fruit = String::from("blueberries"); // æ— æ³•è®¿é—®ç§æœ‰å­—æ®µ
  }
  ```

#### 7.3.5 pub enum

+ å°†`pub`å…³é”®å­—æ”¾åœ¨`enum`å‰

  + `enum`æ˜¯å…¬å…±çš„
  + `enum`çš„å˜ä½“ä¹Ÿéƒ½æ˜¯å…¬å…±çš„

  ```rust
  mod back_of_house {
      pub enum Appetizer {
          Soup,
          Salad,
      }
  }
  ```

  

### 7.4 useå…³é”®å­—

+ `use`å…³é”®å­—å¯ä»¥å°†è·¯å¾„å¯¼å…¥åˆ°ä½œç”¨åŸŸå†…

  + ä»»éµå®ˆç§æœ‰æ€§è§„åˆ™

  ```rust
  mod front_of_house {
      pub mod hosting {
          pub fn add_to_waitlist() {}
          fn some_function() {}
      }
  }
  use crate::front_of_house::hosting;
  
  pub fn eat_at_restaurant() {
      hosting::add_to_waitlist();
      hosting::add_to_waitlist();
      hosting::add_to_waitlist();
      // hosting::some_function();
  }
  ```

+ ä½¿ç”¨`use`æ¥æŒ‡å®šç›¸å¯¹è·¯å¾„

#### 7.4.1 useçš„ä¹ æƒ¯ç”¨æ³•

+ å‡½æ•°ï¼šå°†å‡½æ•°çš„çˆ¶çº§æ¨¡å—å¼•å…¥ä½œç”¨åŸŸï¼ˆæŒ‡å®šåˆ°çˆ¶çº§ï¼‰

+ `struct`ã€`enum`ã€å…¶å®ƒï¼šæŒ‡å®šå®Œæ•´è·¯å¾„ï¼ˆæŒ‡å®šåˆ°æœ¬èº«ï¼‰

+ åŒåæ¡ç›®ï¼šæŒ‡å®šåˆ°çˆ¶çº§

+ å¯ä»¥ä½¿ç”¨ `as`å…³é”®å­—æä¾›æ–°çš„åç§°

  ```rust
  use std::fmt;
  use std::io;
  
  fn f1() -> fmt::Result {}
  
  fn f2() -> io::Result {}
  
  
  
  use std::fmt::Result as fmtResult;
  use std::io::Result as ioResult;
  
  fn f1() -> fmtResult {}
  
  fn f2() -> ioResult {}
  ```

#### 7.4.2 ä½¿ç”¨ pub use é‡æ–°å¯¼å‡ºåç§°

+ ä½¿ç”¨`use`å°†è·¯å¾„ï¼ˆåç§°ï¼‰å¯¼å…¥åˆ°ä½œç”¨åŸŸå†…åï¼Œè¯¥åç§°åœ¨æ­¤ä½œç”¨åŸŸå†…æ˜¯ç§æœ‰çš„

+ `pub use`ï¼šé‡å¯¼å‡º

  + å°†è¯¥æ¡ç›®å¼•å…¥ä½œç”¨åŸŸ
  + è¯¥æ¡ç›®å¯ä»¥è¢«å¤–éƒ¨ä»£ç å¼•å…¥åˆ°å®ƒä»¬çš„ä½œç”¨åŸŸ

  ```rust
  pub use crate::front_of_house::hosting;
  ```

#### 7.4.3 ä½¿ç”¨å¤–éƒ¨åŒ…ï¼ˆpackageï¼‰

+ å¯¼å…¥è¿‡ç¨‹

  1. `Cargo.toml`æ·»åŠ ä¾èµ–çš„åŒ…ï¼ˆpackageï¼‰
     + <a href = "https://crates.io/">https://crates.io/</a> 

  1. ä½¿ç”¨`use`å°†ç‰¹å®šæ¡ç›®å¼•å…¥ä½œç”¨åŸŸ

     ```rust
     Cargo.toml :
     [dependencies]
     rand = "0.8.5"
     
     main.rs : 
     use rand::Rng;
     ```

+ æ ‡å‡†åº“ï¼ˆstdï¼‰ä¹Ÿè¢«å½“åšå¤–éƒ¨åŒ…

  + ä¸éœ€è¦ä¿®æ”¹`Cargo.toml`æ¥åŒ…å«`std`

  + éœ€è¦ä½¿ç”¨`use`å°†`std`ä¸­çš„ç‰¹å®šæ¡ç›®å¼•å…¥å½“å‰ä½œç”¨åŸŸ

    ```rust
    use std::collections::HashMap;
    ```

#### 7.4.4 ä½¿ç”¨åµŒå¥—è·¯å¾„æ¸…ç†å¤§é‡çš„useè¯­å¥

+ å¦‚æœä½¿ç”¨åŒä¸€ä¸ªåŒ…æˆ–æ¨¡å—ä¸‹çš„å¤šä¸ªæ¡ç›®

  ```rust
  use std::cmp::Ordering;
  use std::io;
  ```

+ å¯ä½¿ç”¨åµŒå¥—è·¯å¾„åœ¨åŒä¸€è¡Œå†…å°†ä¸Šè¿°æ¡ç›®è¿›è¡Œå¼•å…¥

  + `è·¯å¾„ç›¸åŒçš„éƒ¨åˆ†::{è·¯å¾„å·®å¼‚çš„éƒ¨åˆ†}`

  ```rust
  use std::cmp::Ordering;
  use std::io;
  use std::{cmp::Ordering, io};
  ```

+ å¦‚æœä¸¤ä¸ª`use`è·¯å¾„ä¹‹ä¸€æ˜¯å¦ä¸€ä¸ªçš„å­è·¯å¾„

  + ä½¿ç”¨`self`

  ```rust
  use std::io;
  use std::io::Write;
  use std::io::{self, Write};
  ```

#### 7.4.5 é€šé…ç¬¦ *

+ ä½¿ç”¨`*`å¯ä»¥æŠŠè·¯å¾„ä¸­æ‰€æœ‰çš„å…¬å…±æ¡ç›®éƒ½å¼•å…¥åˆ°ä½œç”¨åŸŸ

  ```rust
  use std::collections::*;
  ```

  

### 7.5 å°†æ¨¡å—æ‹†åˆ†ä¸ºä¸åŒæ–‡ä»¶

#### 7.5.1 å°†æ¨¡å—å†…å®¹ç§»åŠ¨åˆ°å…¶å®ƒæ–‡ä»¶

+ æ¨¡å—å®šä¹‰æ—¶ï¼Œå¦‚æœæ¨¡å—ååè¾¹æ˜¯`;`ï¼Œè€Œä¸æ˜¯ä»£ç å—
  + Rustä¼šä»ä¸æ¨¡å—åŒåçš„æ–‡ä»¶ä¸­åŠ è½½å†…å®¹
  + æ¨¡å—æ ‘çš„ç»“æ„ä¸ä¼šå‘ç”Ÿå˜åŒ–
+ éšç€æ¨¡å—é€æ¸å˜å¤§ï¼Œè¯¥æŠ€æœ¯è®©ä½ å¯ä»¥æŠŠæ¨¡å—çš„å†…å®¹ç§»åŠ¨åˆ°å…¶å®ƒæ–‡ä»¶ä¸­



## 8ã€å¸¸ç”¨çš„é›†åˆ

Rust æ ‡å‡†åº“ä¸­åŒ…å«ä¸€ç³»åˆ—è¢«ç§°ä¸º **é›†åˆ**ï¼ˆ*collections*ï¼‰çš„éå¸¸æœ‰ç”¨çš„æ•°æ®ç»“æ„ã€‚å¤§éƒ¨åˆ†å…¶ä»–æ•°æ®ç±»å‹éƒ½ä»£è¡¨ä¸€ä¸ªç‰¹å®šçš„å€¼ï¼Œä¸è¿‡é›†åˆå¯ä»¥åŒ…å«å¤šä¸ªå€¼ã€‚ä¸åŒäºå†…å»ºçš„æ•°ç»„å’Œå…ƒç»„ç±»å‹ï¼Œè¿™äº›é›†åˆæŒ‡å‘çš„æ•°æ®æ˜¯å‚¨å­˜åœ¨å †ä¸Šçš„ï¼Œè¿™æ„å‘³ç€æ•°æ®çš„æ•°é‡ä¸å¿…åœ¨ç¼–è¯‘æ—¶å°±å·²çŸ¥ï¼Œå¹¶ä¸”è¿˜å¯ä»¥éšç€ç¨‹åºçš„è¿è¡Œå¢é•¿æˆ–ç¼©å°ã€‚

- *vector* å…è®¸æˆ‘ä»¬ä¸€ä¸ªæŒ¨ç€ä¸€ä¸ªåœ°å‚¨å­˜ä¸€ç³»åˆ—æ•°é‡å¯å˜çš„å€¼
- **å­—ç¬¦ä¸²**ï¼ˆ*string*ï¼‰æ˜¯å­—ç¬¦çš„é›†åˆã€‚æˆ‘ä»¬ä¹‹å‰è§è¿‡ `String` ç±»å‹ï¼Œä¸è¿‡åœ¨æœ¬ç« æˆ‘ä»¬å°†æ·±å…¥äº†è§£ã€‚
- **å“ˆå¸Œ map**ï¼ˆ*hash map*ï¼‰å…è®¸æˆ‘ä»¬å°†å€¼ä¸ä¸€ä¸ªç‰¹å®šçš„é”®ï¼ˆkeyï¼‰ç›¸å…³è”ã€‚è¿™æ˜¯ä¸€ä¸ªå«åš *map* çš„æ›´é€šç”¨çš„æ•°æ®ç»“æ„çš„ç‰¹å®šå®ç°ã€‚

### 8.1 ä½¿ç”¨Vectorå­˜å‚¨å¤šä¸ªå€¼

+ `Vec<T>`ï¼Œå«åš`Vector`
  + ç”±æ ‡å‡†åº“æä¾›
  + å¯å­˜å‚¨å¤šä¸ªå€¼
  + åªèƒ½å­˜å‚¨ç›¸åŒç±»å‹çš„æ•°æ®
  + å€¼åœ¨å†…å­˜ä¸­è¿ç»­å­˜æ”¾

#### 8.1.1 åˆ›å»ºVector

+ `Vec::new`å‡½æ•°

  ```rust
  let v: Vec<i32> = Vec::new();
  ```

+ ä½¿ç”¨åˆå§‹å€¼åˆ›å»º`Vec<T>`ï¼Œä½¿ç”¨`vec!`å®

  ```rust
  let v = vec![1, 2, 3];
  ```

#### 8.1.2 æ›´æ–°Vector

+ å‘`Vector`æ·»åŠ å…ƒç´ ï¼Œä½¿ç”¨`push`æ–¹æ³•

  ```rust
  let mut v = Vec::new();
  v.push(1);
  v.push(2);
  v.push(3);
  v.push(4);
  ```

#### 8.1.3 åˆ é™¤Vector

+ ä¸ä»»ä½•å…¶å®ƒ`struct`ä¸€æ ·ï¼Œå½“`Vector`ç¦»å¼€ä½œç”¨åŸŸå

  + å®ƒå°±è¢«æ¸…ç†æ‰äº†
  + å®ƒæ‰€æœ‰çš„å…ƒç´ ä¹Ÿè¢«æ¸…ç†æ‰äº†

  ```rust
  {
      let v = vec![1, 2, 3, 4];
  
      // å¤„ç†å˜é‡ v
  } // <- è¿™é‡Œ v ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ
  ```

#### 8.1.4 è¯»å–Vectorçš„å…ƒç´ 

+ ä¸¤ç§æ–¹å¼å¯ä»¥å¼•ç”¨`Vector`é‡Œçš„å€¼

  + ç´¢å¼•
  + `get`æ–¹æ³•

+ ç´¢å¼• vs `get`å¤„ç†è®¿é—®è¶Šç•Œ

  + ç´¢å¼•ï¼španic
  + `get`ï¼šè¿”å›None

  ```rust
  
  let v = vec![1, 2, 3, 4];
  let third: &i32 = &v[2];
  println!("The third element is: {}", third);
  
  match v.get(2) {
      Some(third) => println!("The third element is: {}", third),
      None => println!("There is no third element"),
  }
  ```

#### 8.1.5 æ‰€æœ‰æƒå’Œå€Ÿç”¨è§„åˆ™

+ ä¸èƒ½åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸå†…åŒæ—¶æ‹¥æœ‰å¯å˜å’Œä¸å¯å˜å¼•ç”¨

  ```rust
  let mut v = vec![1, 2, 3, 4, 5];
  let first = &v[0];
  v.push(6);
  println!("The first element is: {}", first);
  ```

  ```rust
  error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
  ```

  ä¸ºä»€ä¹ˆç¬¬ä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨ä¼šå…³å¿ƒ vector ç»“å°¾çš„å˜åŒ–ï¼Ÿä¸èƒ½è¿™ä¹ˆåšçš„åŸå› æ˜¯ç”±äº vector çš„å·¥ä½œæ–¹å¼ï¼šåœ¨ vector çš„ç»“å°¾å¢åŠ æ–°å…ƒç´ æ—¶ï¼Œåœ¨æ²¡æœ‰è¶³å¤Ÿç©ºé—´å°†æ‰€æœ‰å…ƒç´ ä¾æ¬¡ç›¸é‚»å­˜æ”¾çš„æƒ…å†µä¸‹ï¼Œå¯èƒ½ä¼šè¦æ±‚åˆ†é…æ–°å†…å­˜å¹¶å°†è€çš„å…ƒç´ æ‹·è´åˆ°æ–°çš„ç©ºé—´ä¸­ã€‚è¿™æ—¶ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨å°±æŒ‡å‘äº†è¢«é‡Šæ”¾çš„å†…å­˜ã€‚å€Ÿç”¨è§„åˆ™é˜»æ­¢ç¨‹åºé™·å…¥è¿™ç§çŠ¶å†µã€‚

#### 8.1.6 éå†Vectorä¸­çš„å€¼

+ forå¾ªç¯

  ```rust
  let v = vec![1, 2, 3, 4, 5];
  for i in &v {
      println!("{}", i);
  }
  
  let mut v = vec![1, 2, 3, 4, 5];
  for i in &mut v {
      *i += 50;
  }
  for i in &v {
      println!("{}", i);
  }
  ```

#### 8.1.7 ä½¿ç”¨æšä¸¾æ¥å­˜å‚¨å¤šç§æ•°æ®ç±»å‹

+ `Enum`çš„å˜ä½“å¯ä»¥é™„åŠ ä¸åŒç±»å‹çš„æ•°æ®

+ `Enum`çš„å˜ä½“å®šä¹‰åœ¨åŒä¸€ä¸ª`enum`ç±»å‹ä¸‹

  ```rust
  enum SpreadsheetCell {
      Int(i32),
      Float(f64),
      Text(String),
  }
  
  let row = vec![
      SpreadsheetCell::Int(3),
      SpreadsheetCell::Float(11.22),
      SpreadsheetCell::Text(String::from("bule")),
  ];
  ```
  
  Rust åœ¨ç¼–è¯‘æ—¶å°±å¿…é¡»å‡†ç¡®çš„çŸ¥é“ vector ä¸­ç±»å‹çš„åŸå› åœ¨äºå®ƒéœ€è¦çŸ¥é“å‚¨å­˜æ¯ä¸ªå…ƒç´ åˆ°åº•éœ€è¦å¤šå°‘å†…å­˜ã€‚ç¬¬äºŒä¸ªå¥½å¤„æ˜¯å¯ä»¥å‡†ç¡®çš„çŸ¥é“è¿™ä¸ª vector ä¸­å…è®¸ä»€ä¹ˆç±»å‹ã€‚å¦‚æœ Rust å…è®¸ vector å­˜æ”¾ä»»æ„ç±»å‹ï¼Œé‚£ä¹ˆå½“å¯¹ vector å…ƒç´ æ‰§è¡Œæ“ä½œæ—¶ä¸€ä¸ªæˆ–å¤šä¸ªç±»å‹çš„å€¼å°±æœ‰å¯èƒ½ä¼šé€ æˆé”™è¯¯ã€‚ä½¿ç”¨æšä¸¾å¤–åŠ  match æ„å‘³ç€ Rust èƒ½åœ¨ç¼–è¯‘æ—¶å°±ä¿è¯æ€»æ˜¯ä¼šå¤„ç†æ‰€æœ‰å¯èƒ½çš„æƒ…å†µ
  
  

### 8.2 å­—ç¬¦ä¸²

å­—ç¬¦ä¸²æ˜¯æ–°æ™‹ Rustacean ä»¬é€šå¸¸ä¼šè¢«å›°ä½çš„é¢†åŸŸï¼Œè¿™æ˜¯ç”±äºä¸‰æ–¹é¢ç†ç”±çš„ç»“åˆï¼šRust å€¾å‘äºç¡®ä¿æš´éœ²å‡ºå¯èƒ½çš„é”™è¯¯ï¼Œå­—ç¬¦ä¸²æ˜¯æ¯”å¾ˆå¤šç¨‹åºå‘˜æ‰€æƒ³è±¡çš„è¦æ›´ä¸ºå¤æ‚çš„æ•°æ®ç»“æ„ï¼Œä»¥åŠ UTF-8ã€‚æ‰€æœ‰è¿™äº›è¦ç´ ç»“åˆèµ·æ¥å¯¹äºæ¥è‡ªå…¶ä»–è¯­è¨€èƒŒæ™¯çš„ç¨‹åºå‘˜å°±å¯èƒ½æ˜¾å¾—å¾ˆå›°éš¾äº†ã€‚

#### 8.2.1 ä»€ä¹ˆæ˜¯å­—ç¬¦ä¸²

+ ç‰¹ç‚¹

  + `Byte`çš„é›†åˆ

  + æä¾›äº†ä¸€äº›æ–¹æ³•
    + å¯ä»¥å°†`byte`è§£æä¸ºæ–‡æœ¬

+ Rustçš„**æ ¸å¿ƒè¯­è¨€å±‚é¢**ï¼Œåªæœ‰ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹ï¼šå­—ç¬¦ä¸²åˆ‡ç‰‡`str`ï¼ˆæˆ–`&str`ï¼‰

+ å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼šå¯¹å­˜å‚¨åœ¨å…¶å®ƒåœ°æ–¹ï¼ŒUTF-8ç¼–ç çš„å­—ç¬¦ä¸²çš„å¼•ç”¨

  + å­—ç¬¦ä¸²å­—é¢å€¼ï¼šå­˜å‚¨åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œä¹Ÿæ˜¯å­—ç¬¦ä¸²åˆ‡ç‰‡

+ `String`ç±»å‹

  + æ¥è‡ª**æ ‡å‡†åº“**è€Œä¸æ˜¯æ ¸å¿ƒè¯­è¨€
  + å¯å¢é•¿ã€å¯ä¿®æ”¹ã€å¯æ‹¥æœ‰
  + UTF-8ç¼–ç 

+ é€šå¸¸è¯´çš„å­—ç¬¦ä¸²æ˜¯æŒ‡`String`å’Œ`&str`ä¸¤ç§ç±»å‹

  + æ ‡å‡†åº“é‡Œç”¨çš„å¤š
  + UTF-8ç¼–ç 

+ å…¶å®ƒç±»å‹çš„å­—ç¬¦ä¸²ï¼šOsStringã€OsStrã€CStringã€CStr

  + `String` vs `Str`åç¼€ï¼šæ‹¥æœ‰æˆ–å€Ÿç”¨çš„å˜ä½“
  + å¯å­˜å‚¨ä¸åŒç¼–ç çš„æ–‡æœ¬æˆ–åœ¨å†…å­˜ä¸­ä»¥ä¸åŒçš„å½¢å¼å±•ç°

+ Library crateé’ˆå¯¹å­˜å‚¨å­—ç¬¦ä¸²å¯æä¾›æ›´å¤šçš„é€‰é¡¹

#### 8.2.2 åˆ›å»ºä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼ˆStringï¼‰

+ å¾ˆå¤š`Vec<T>`çš„æ“ä½œéƒ½å¯ä»¥ç”¨äº`String`

+ `String::new()`å‡½æ•°

  ```rust
  let mut s = String::new();
  ```

+ ä½¿ç”¨åˆå§‹å€¼æ¥åˆ›å»º`String`

  + `to_string()`æ–¹æ³•ï¼Œå¯ç”¨äºå®ç°äº†`Display trait`çš„ç±»å‹ï¼ŒåŒ…æ‹¬å­—ç¬¦ä¸²å­—é¢å€¼

    ```rust
    let data = "initial contents";
    let s = data.to_string();
    
    let s1 = "initial contents".to_string();
    ```

  + `String::from()`å‡½æ•°ï¼Œä»å­—é¢å€¼åˆ›å»º`String`

    ```rust
    let s2 = String::from("initial contents");
    ```

  + UTF-8

    ```rust
    let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
    let hello = String::from("DobrÃ½ den");
    let hello = String::from("Hello");
    let hello = String::from("×©Ö¸××œ×•Ö¹×");
    let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
    let hello = String::from("ã“ã‚“ã«ã¡ã¯");
    let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
    let hello = String::from("ä½ å¥½");
    let hello = String::from("OlÃ¡");
    let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
    let hello = String::from("Hola");
    ```

#### 8.2.3 æ›´æ–°String

+ `push_str()`æ–¹æ³•ï¼šå¯ä»¥å°†ä¸€ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡é™„åŠ åˆ°`String`

  ```rust
  let mut s = String::from("foo");
  s.push_str("bar");
  println!("{}", s);
  
  let mut s1 = String::from("foo");
  let s2 = "bar";
  s1.push_str(s2);
  println!("s2 is {}", s2);
  ```

+ `push()`æ–¹æ³•ï¼šæŠŠå•ä¸ªå­—ç¬¦é™„åŠ åˆ°`String`

  ```rust
  let mut s = String::from("foo");
  s.push_str("bar");
  s.push('!');
  println!("{}", s);
  ```

+ `+`ï¼šè¿æ¥å­—ç¬¦ä¸²

  + ä½¿ç”¨äº†ç±»ä¼¼è¿™ä¸ªç­¾åçš„æ–¹æ³•`fn add(self, s: &str) -> String {...}`
    + æ ‡å‡†åº“ä¸­çš„`add`æ–¹æ³•ä½¿ç”¨äº†æ³›å‹
    + åªèƒ½æŠŠ`&str`æ·»åŠ åˆ°`String`
    + è§£å¼•ç”¨å¼ºåˆ¶è½¬æ¢ï¼ˆderef coercionï¼‰

  ```rust
  let s1 = String::from("Hello, ");
  let s2 = String::from("world");
  let s3 = s1 + &s2;
  println!("{}", s3);
  println!("{}", s1); // æ³¨æ„ s1 è¢«ç§»åŠ¨äº†ï¼Œä¸èƒ½ç»§ç»­ä½¿ç”¨
  println!("{}", s2);
  ```

+ `format!`ï¼šè¿æ¥å¤šä¸ªå­—ç¬¦ä¸²

  + å’Œ`println!()`ç±»ä¼¼ï¼Œä½†è¿”å›å­—ç¬¦ä¸²
  + ä¸ä¼šè·å¾—å‚æ•°çš„æ‰€æœ‰æƒ

  ```rust
  let s1 = String::from("tic");
  let s2 = String::from("tac");
  let s3 = String::from("toe");
  
  // let s3 = s1 + "-" + &s2 + "-" + &s3;
  // println!("{}", s3);
  
  let s = format!("{}-{}-{}", s1, s2, s3);
  println!("{}", s);
  ```

#### 8.2.4 å¯¹StringæŒ‰ç´¢å¼•çš„å½¢å¼è¿›è¡Œè®¿é—®

+ æŒ‰ç´¢å¼•è¯­æ³•è®¿é—®`String`çš„æŸéƒ¨åˆ†ï¼Œä¼šæŠ¥é”™

  ```rust
  let s1 = String::from("hello");
  let h = s1[0];
  ```

  ```rust
  error[E0277]: the type `String` cannot be indexed by `{integer}`
  ```

  Rustçš„å­—ç¬¦ä¸²æ˜¯ä¸æ”¯æŒç´¢å¼•è¯­æ³•è®¿é—®çš„

+ å†…éƒ¨è¡¨ç¤º

  + `String`æ˜¯å¯¹`Vec<u8>`çš„åŒ…è£…

    + `len()`æ–¹æ³•

    ```rust
    let len = String::from("Hola").len();
    println!("{}", len); // 4
    
    let len = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ").len();
    println!("{}", len); // 24
    
    let hello = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";
    let answer = &hello[0];
    // Ğ—: 208 151
    ```

    å½“ä½¿ç”¨ UTF-8 ç¼–ç æ—¶ï¼Œ`Ğ—` çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ `208`ï¼Œç¬¬äºŒä¸ªæ˜¯ `151`ï¼Œæ‰€ä»¥ `answer` å®é™…ä¸Šåº”è¯¥æ˜¯ `208`ï¼Œä¸è¿‡ `208` è‡ªèº«å¹¶ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å­—æ¯ã€‚è¿”å› `208` å¯ä¸æ˜¯ä¸€ä¸ªè¯·æ±‚å­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªå­—æ¯çš„äººæ‰€å¸Œæœ›çœ‹åˆ°çš„ï¼Œä¸è¿‡å®ƒæ˜¯ Rust åœ¨å­—èŠ‚ç´¢å¼• 0 ä½ç½®æ‰€èƒ½æä¾›çš„å”¯ä¸€æ•°æ®ã€‚ç”¨æˆ·é€šå¸¸ä¸ä¼šæƒ³è¦ä¸€ä¸ªå­—èŠ‚å€¼è¢«è¿”å›ï¼Œå³ä¾¿è¿™ä¸ªå­—ç¬¦ä¸²åªæœ‰æ‹‰ä¸å­—æ¯ï¼š å³ä¾¿ `&"hello"[0]` æ˜¯è¿”å›å­—èŠ‚å€¼çš„æœ‰æ•ˆä»£ç ï¼Œå®ƒä¹Ÿåº”å½“è¿”å› `104` è€Œä¸æ˜¯ `h`ã€‚

    ä¸ºäº†é¿å…è¿”å›æ„å¤–çš„å€¼å¹¶é€ æˆä¸èƒ½ç«‹åˆ»å‘ç°çš„ bugï¼ŒRust æ ¹æœ¬ä¸ä¼šç¼–è¯‘è¿™äº›ä»£ç ï¼Œå¹¶åœ¨å¼€å‘è¿‡ç¨‹ä¸­åŠæ—©æœç»äº†è¯¯ä¼šçš„å‘ç”Ÿã€‚

+ å­—èŠ‚ã€æ ‡é‡å€¼å’Œå­—å½¢ç°‡ï¼ˆBytesã€Scalar Valuesã€Grapheme Clustersï¼‰

  + Rustæœ‰ä¸‰ç§çœ‹å¾…å­—ç¬¦ä¸²çš„æ–¹å¼
    + å­—èŠ‚
    + è¡¨é‡å€¼
    + å­—å½¢ç°‡ï¼ˆæœ€æ¥è¿‘â€œå­—æ¯â€çš„æ¦‚å¿µï¼‰

  ```rust
  let w = "à¤¨à¤®à¤¸à¥à¤¤à¥‡"; // æ¢µæ–‡ä¹¦å†™çš„å°åº¦è¯­å•è¯
  for b in w.bytes() { // å­—èŠ‚
      println!("{}", b);
  }
  
  for b in w.chars() { // æ ‡é‡å€¼
      println!("{}", b);
  }
  
  use unicode_segmentation::UnicodeSegmentation;
  for g in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".graphemes(true) { // å­—å½¢ç°‡
      println!("{}", g);
  }
  ```

+ Rustä¸å…è®¸å¯¹`String`è¿›è¡Œç´¢å¼•çš„æœ€åä¸€ä¸ªåŸå› 

  + ç´¢å¼•æ“ä½œåº”æ¶ˆè€—ä¸€ä¸ªå¸¸é‡æ—¶é—´ (O(1))
  + è€Œ`String`æ— æ³•ä¿è¯ï¼šéœ€è¦éå†æ‰€æœ‰å†…å®¹ï¼Œæ¥ç¡®å®šæœ‰å¤šå°‘ä¸ªåˆæ³•çš„å­—ç¬¦

#### 8.2.5 å­—ç¬¦ä¸²slice

+ å¯ä»¥ä½¿ç”¨`[]`å’Œ**ä¸€ä¸ªèŒƒå›´**æ¥åˆ›å»ºå­—ç¬¦ä¸²çš„åˆ‡ç‰‡

  + å¿…é¡»è°¨æ…ä½¿ç”¨
  + å¦‚æœåˆ‡å‰²æ—¶è·¨è¶Šäº†å­—ç¬¦è¾¹ç•Œï¼Œç¨‹åºå°±ä¼š`panic`

  ```rust
  let hello = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";
  let s = &hello[0..4];
  println!("{}", s); // Ğ—Ğ´
  
  let s1 = &hello[0..3];
  println!("{}", s1); // panic
  // byte index 3 is not a char boundary
  ```

#### 8.2.6 éå†Stringçš„æ–¹æ³•

+ å¯¹äºæ ‡é‡å€¼ï¼š`char()`æ–¹æ³•
+ å¯¹äºå­—èŠ‚ï¼š`byte()`æ–¹æ³•
+ å¯¹äºå­—å½¢ç°‡ï¼šå¾ˆå¤æ‚ï¼Œæ ‡å‡†åº“æœªæä¾›

#### 8.2.7 Stringå¹¶ä¸ç®€å•

+ Rusté€‰æ‹©å°†æ­£ç¡®å¤„ç†`String`æ•°æ®ä½œä¸ºæ‰€æœ‰Rustç¨‹åºçš„é»˜è®¤è¡Œä¸º
  + ç¨‹åºå‘˜å¿…é¡»åœ¨å¤„ç†`UTF-8`æ•°æ®ä¹‹å‰æŠ•å…¥æ›´å¤šçš„ç²¾åŠ›
+ å¯ä»¥é˜²æ­¢åœ¨å¼€å‘åæœŸå¤„ç†æ¶‰åŠé`ASCII`å­—ç¬¦çš„é”™è¯¯



### 8.3 HashMap<K, V>

`HashMap<K, V>` ç±»å‹å‚¨å­˜äº†ä¸€ä¸ªé”®ç±»å‹ `K` å¯¹åº”ä¸€ä¸ªå€¼ç±»å‹ `V` çš„æ˜ å°„ã€‚å®ƒé€šè¿‡ä¸€ä¸ª **å“ˆå¸Œå‡½æ•°**ï¼ˆ*hashing function*ï¼‰æ¥å®ç°æ˜ å°„ï¼Œå†³å®šå¦‚ä½•å°†é”®å’Œå€¼æ”¾å…¥å†…å­˜ä¸­ã€‚

+ é”®å€¼å¯¹çš„å½¢å¼å­˜å‚¨æ•°æ®ï¼Œä¸€ä¸ªé”®ï¼ˆKeyï¼‰å¯¹åº”ä¸€ä¸ªå€¼ï¼ˆValueï¼‰
+ `Hash`å‡½æ•°ï¼šå†³å®šå¦‚ä½•åœ¨å†…å­˜ä¸­å­˜æ”¾`K`å’Œ`V`

#### 8.3.1 åˆ›å»ºHashMap

+ åˆ›å»ºç©º`HashMap`ï¼š`new()`å‡½æ•°

+ æ·»åŠ æ•°æ®ï¼š`insert()`æ–¹æ³•

  ```rust
  use std::collections::HashMap;
  let mut scores = HashMap::new();
  scores.insert(String::from("Blue"), 10);
  scores.insert(String::from("Yellow"), 50);
  
  ```

+ `HashMap`ä½¿ç”¨çš„æ¯”è¾ƒå°‘ï¼Œå› æ­¤ä¸åœ¨`Prelude`ä¸­

+ æ ‡å‡†åº“å¯¹å…¶æ”¯æŒæ¯”è¾ƒå°‘ï¼Œæ²¡æœ‰å†…ç½®çš„å®æ¥åˆ›å»º`HashMap`

+ æ•°æ®å­˜å‚¨åœ¨`heap`ä¸Š

+ åŒæ„çš„ã€‚ä¸€ä¸ª`HashMap`ä¸­ï¼š

  + æ‰€æœ‰çš„`K`å¿…é¡»æ˜¯åŒä¸€ç§ç±»å‹
  + æ‰€æœ‰çš„`V`å¿…é¡»æ˜¯åŒä¸€ç§ç±»å‹

#### 8.3.2 å¦ä¸€ç§åˆ›å»ºHashMapçš„æ–¹å¼ï¼šcollectæ–¹æ³•

+ åœ¨å…ƒç´ ç±»å‹ä¸º`Tuple`çš„`Vector`ä¸Šä½¿ç”¨`collect`æ–¹æ³•ï¼Œå¯ä»¥ç»„å»ºä¸€ä¸ª`HashMap`

  + è¦æ±‚`Tuple`æœ‰ä¸¤ä¸ªå€¼ï¼šä¸€ä¸ªä½œä¸º`K`ï¼Œä¸€ä¸ªä½œä¸º`V`
  + `collect`æ–¹æ³•å¯ä»¥æŠŠæ•°æ®æ•´åˆæˆå¾ˆå¤šç§é›†åˆç±»å‹ï¼ŒåŒ…æ‹¬`HashMap`
    + è¿”å›å€¼éœ€è¦æ˜¾å¼æŒ‡æ˜ç±»å‹

  ```rust
  let teams = vec![String::from("Blue"), String::from("Yellow")];
  let intial_scores = vec![10, 50];
  
  let scores: HashMap<_, _> = teams.iter().zip(intial_scores.iter()).collect();
  
  println!("{:?}", scores); // {"Blue": 10, "Yellow": 50}
  ```

  `zip()`æ¥æ”¶ä¸€ä¸ªå‚æ•°ï¼Œå°†è°ƒç”¨è€…ä¸­çš„å…ƒç´ ä¸å‚æ•°ä¸­çš„å…ƒç´ ä¸€ä¸€å¯¹åº”ç»„æˆ`Tuple`ï¼Œè‹¥æ•°é‡ä¸åŒ¹é…ï¼Œå¤šçš„å…ƒç´ ä¼šè¢«ä¸¢å¼ƒã€‚`collect()`æ–¹æ³•å½¢æˆäº†ä¸€ä¸ª`HashMap`ï¼Œå…ƒç´ é¡ºåºå¹¶ä¸å›ºå®šï¼Œæ¯æ¬¡è¿è¡Œå¯èƒ½éƒ½ä¸ä¸€æ ·ã€‚å½“ç„¶`key -> value`çš„é¡ºåºæ˜¯ç”±`zip`ä¸€ä¸€å¯¹åº”çš„ï¼Œä¸æ˜¯ç”±`collect`å†³å®šçš„

#### 8.3.3 HashMapå’Œæ‰€æœ‰æƒ

+ å¯¹äºå®ç°äº†`Copy trait`çš„ç±»å‹ï¼ˆä¾‹å¦‚ i32ï¼‰ï¼Œå€¼ä¼šè¢«å¤åˆ¶åˆ°`HashMap`ä¸­

+ å¯¹äºæ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼ï¼ˆä¾‹å¦‚ Stringï¼‰ï¼Œå€¼ä¼šè¢«ç§»åŠ¨ï¼Œæ‰€æœ‰æƒä¼šè¢«è½¬ç§»ç»™`HashMap`

  ```rust
  let field_name = String::from("Favorite color");
  let field_valule = String::from("Blue");
  let mut map = HashMap::new();
  map.insert(field_name, field_valule);
  
  println!("{}: {}", field_name, field_valule); // borrow of moved value
  ```

+ å¦‚æœå°†å€¼çš„å¼•ç”¨æ’å…¥åˆ°`HashMap`ï¼Œå€¼æœ¬èº«ä¸ä¼šç§»åŠ¨

  + åœ¨`HashMap`æœ‰æ•ˆçš„æœŸé—´ï¼Œè¢«å¼•ç”¨çš„å€¼å¿…é¡»ä¿è¯æœ‰æ•ˆ

  ```rust
  let field_name = String::from("Favorite color");
  let field_valule = String::from("Blue");
  let mut map = HashMap::new();
  map.insert(&field_name, &field_valule);
  
  println!("{}: {}", field_name, field_valule); // correct
  ```

#### 8.3.4 è®¿é—®HashMapä¸­çš„å€¼

+ `get()`æ–¹æ³•

  + å‚æ•°ï¼š`K`
  + è¿”å›ï¼š`Option<&V>`

  ```rust
  let mut scores = HashMap::new();
  scores.insert(String::from("blue"), 10);
  scores.insert(String::from("Yellow"), 50);
  
  let team_name = String::from("blue");
  let score = scores.get(&team_name);
  
  match score {
      Some(s) => println!("{}", s),
      None => println!("team not exist"),
  }
  ```

#### 8.3.5 éå†HashMap

+ forå¾ªç¯

  ```rust
  let mut scores = HashMap::new();
  scores.insert(String::from("blue"), 10);
  scores.insert(String::from("Yellow"), 50);
  
  for (k, v) in &scores {
      println!("{}: {}", k, v);
  }
  ```

#### 8.3.6 æ›´æ–°HashMap<K, V>

+ `HashMap`å¤§å°å¯å˜

+ æ¯ä¸ª`K`åŒæ—¶åªèƒ½å¯¹åº”ä¸€ä¸ª`V`

+ æ›´æ–°`HashMap`ä¸­çš„æ•°æ®

  + `K`å·²ç»å­˜åœ¨ï¼Œå¯¹åº”ä¸€ä¸ª`V`
    + æ›¿æ¢ç°æœ‰çš„`V`
    + ä¿ç•™ç°æœ‰çš„`V`ï¼Œå¿½ç•¥æ–°çš„`V`
    + åˆå¹¶ç°æœ‰çš„`V`å’Œæ–°çš„`V`
  + `K`ä¸å­˜åœ¨
    + æ·»åŠ ä¸€å¯¹æ–°çš„`K, V`

+ æ›¿æ¢ç°æœ‰çš„`V`

  + å¦‚æœå‘`HashMap`æ’å…¥ä¸€å¯¹`Kã€V`ï¼Œç„¶ååœ¨æ’å…¥ç›¸åŒçš„`K`ï¼Œä½†æ˜¯`V`ä¸åŒï¼Œé‚£ä¹ˆåŸæ¥çš„`V`ä¼šè¢«æ›¿æ¢æ‰

    ```rust
    let mut scores = HashMap::new();
    scores.insert(String::from("blue"), 10);
    scores.insert(String::from("blue"), 20);
    
    println!("{:?}", scores); // {"blue": 20}
    ```

+ åªæœ‰`K`ä¸å¯¹åº”ä»»ä½•å€¼çš„æƒ…å†µä¸‹ï¼Œæ‰æ’å…¥`V`

  + `entry()`æ–¹æ³•ï¼šæ£€æŸ¥æŒ‡å®šçš„`K`æ˜¯å¦å¯¹åº”ä¸€ä¸ª`V`
    + å‚æ•°ä¸º`K`
    + è¿”å›`enum Entry`ï¼šä»£è¡¨å€¼æ˜¯å¦å­˜åœ¨
  + `Entry`çš„`or_insert()`æ–¹æ³•ï¼š
    + å¦‚æœ`K`å­˜åœ¨ï¼Œè¿”å›åˆ°å¯¹åº”çš„`V`çš„ä¸€ä¸ªå¯å˜å¼•ç”¨
    + å¦‚æœ`K`ä¸å­˜åœ¨ï¼Œå°†æ–¹æ³•å‚æ•°ä½œä¸º`K`çš„æ–°å€¼æ’è¿›å»ï¼Œè¿”å›åˆ°è¿™ä¸ªå€¼çš„å¯å˜å¼•ç”¨

  ```rust
  let mut scores = HashMap::new();
  scores.insert(String::from("blue"), 10);
  // scores.entry(String::from("yellow")).or_insert(50);
  let e = scores.entry(String::from("yellow"));
  println!("{:?}", e);
  e.or_insert(50);
  
  scores.entry(String::from("blue")).or_insert(50);
  println!("{:?}", scores);
  ```

+ åŸºäºç°æœ‰çš„`V`æ¥æ›´æ–°`V`

  ```rust
  let text = "hello world wonderful world";
  let mut map = HashMap::new();
  for word in text.split_whitespace() {
      let count = map.entry(word).or_insert(0);
      *count += 1;
  }
  println!("{:#?}", map); 
  // {
  //     "hello": 1,
  //     "world": 2,
  //     "wonderful": 1,
  // }
  ```

#### 8.3.7 Hashå‡½æ•°

+ é»˜è®¤æƒ…å†µä¸‹ï¼Œ`HashMap`ä½¿ç”¨åŠ å¯†åŠŸèƒ½å¼ºå¤§çš„`Hash`å‡½æ•°ï¼Œå¯ä»¥æŠµæŠ—æ‹’ç»æœåŠ¡ï¼ˆDosï¼‰æ”»å‡»
  + ä¸æ˜¯å¯ç”¨çš„æœ€å¿«çš„`Hash`ç®—æ³•
  + ä½†å…·æœ‰æ›´å¥½çš„å®‰å…¨æ€§
+ å¯ä»¥æŒ‡å®šä¸åŒçš„`hasher`æ¥åˆ‡æ¢åˆ°å¦ä¸€ä¸ªå‡½æ•°
  + `hasher`æ˜¯å®ç°äº†`BuildHasher trait`çš„ç±»å‹



## 9ã€é”™è¯¯å¤„ç†

é”™è¯¯æ˜¯è½¯ä»¶ä¸­ä¸å¯å¦è®¤çš„äº‹å®ï¼Œæ‰€ä»¥ Rust æœ‰ä¸€äº›å¤„ç†å‡ºé”™æƒ…å†µçš„ç‰¹æ€§ã€‚åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼ŒRust è¦æ±‚ä½ æ‰¿è®¤é”™è¯¯çš„å¯èƒ½æ€§ï¼Œå¹¶åœ¨ä½ çš„ä»£ç ç¼–è¯‘å‰é‡‡å–ä¸€äº›è¡ŒåŠ¨ã€‚è¿™ä¸€è¦æ±‚ä½¿ä½ çš„ç¨‹åºæ›´åŠ å¥å£®ï¼Œå› ä¸ºå®ƒå¯ä»¥ç¡®ä¿ä½ åœ¨å°†ä»£ç éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒä¹‹å‰å°±èƒ½å‘ç°é”™è¯¯å¹¶è¿›è¡Œé€‚å½“çš„å¤„ç†ã€‚

Rust å°†é”™è¯¯åˆ†ä¸ºä¸¤å¤§ç±»ï¼š**å¯æ¢å¤çš„**ï¼ˆ*recoverable*ï¼‰å’Œ **ä¸å¯æ¢å¤çš„**ï¼ˆ*unrecoverable*ï¼‰é”™è¯¯ã€‚å¯¹äºä¸€ä¸ªå¯æ¢å¤çš„é”™è¯¯ï¼Œæ¯”å¦‚æ–‡ä»¶æœªæ‰¾åˆ°çš„é”™è¯¯ï¼Œæˆ‘ä»¬å¾ˆå¯èƒ½åªæƒ³å‘ç”¨æˆ·æŠ¥å‘Šé—®é¢˜å¹¶é‡è¯•æ“ä½œã€‚ä¸å¯æ¢å¤çš„é”™è¯¯æ€»æ˜¯ bug å‡ºç°çš„å¾å…†ï¼Œæ¯”å¦‚è¯•å›¾è®¿é—®ä¸€ä¸ªè¶…è¿‡æ•°ç»„æœ«ç«¯çš„ä½ç½®ï¼Œå› æ­¤æˆ‘ä»¬è¦ç«‹å³åœæ­¢ç¨‹åºã€‚

å¤§å¤šæ•°è¯­è¨€å¹¶ä¸åŒºåˆ†è¿™ä¸¤ç§é”™è¯¯ï¼Œå¹¶é‡‡ç”¨ç±»ä¼¼å¼‚å¸¸è¿™æ ·æ–¹å¼ç»Ÿä¸€å¤„ç†ä»–ä»¬ã€‚Rust æ²¡æœ‰å¼‚å¸¸ã€‚ç›¸åï¼Œå®ƒæœ‰ `Result<T, E>` ç±»å‹ï¼Œç”¨äºå¤„ç†å¯æ¢å¤çš„é”™è¯¯ï¼Œè¿˜æœ‰ `panic!` å®ï¼Œåœ¨ç¨‹åºé‡åˆ°ä¸å¯æ¢å¤çš„é”™è¯¯æ—¶åœæ­¢æ‰§è¡Œã€‚

+ Rustçš„å¯é æ€§ï¼šé”™è¯¯å¤„ç†
  + å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼šåœ¨ç¼–è¯‘æ—¶æç¤ºé”™è¯¯å¹¶å¤„ç†
+ é”™è¯¯çš„åˆ†ç±»ï¼š
  + å¯æ¢å¤
    + ä¾‹å¦‚æ–‡ä»¶æœªæ‰¾åˆ°ï¼Œå¯å†æ¬¡å°è¯•
  + ä¸å¯æ¢å¤
    + bugï¼Œä¾‹å¦‚è®¿é—®çš„ç´¢å¼•è¶…å‡ºèŒƒå›´
+ Rustæ²¡æœ‰ç±»ä¼¼å¼‚å¸¸çš„æœºåˆ¶
  + å¯æ¢å¤é”™è¯¯ï¼š`Result<T,E>`
  + ä¸å¯æ¢å¤ï¼š`panic!`å®

### 9.1 ç”¨ panic! å¤„ç†ä¸å¯æ¢å¤çš„é”™è¯¯

+ å½“`panic!`å®æ‰§è¡Œï¼š
  + ä½ çš„ç¨‹åºä¼šæ‰“å°ä¸€ä¸ªé”™è¯¯ä¿¡æ¯
  + å±•å¼€ï¼ˆunwindï¼‰ã€æ¸…ç†è°ƒç”¨æ ˆï¼ˆStackï¼‰
  + é€€å‡ºç¨‹åº

> ### å¯¹åº” panic æ—¶çš„æ ˆå±•å¼€æˆ–ç»ˆæ­¢
>
> å½“å‡ºç° panic æ—¶ï¼Œç¨‹åºé»˜è®¤ä¼šå¼€å§‹ **å±•å¼€**ï¼ˆ*unwinding*ï¼‰ï¼Œè¿™æ„å‘³ç€ Rust ä¼šå›æº¯æ ˆå¹¶æ¸…ç†å®ƒé‡åˆ°çš„æ¯ä¸€ä¸ªå‡½æ•°çš„æ•°æ®ï¼Œä¸è¿‡è¿™ä¸ªå›æº¯å¹¶æ¸…ç†çš„è¿‡ç¨‹æœ‰å¾ˆå¤šå·¥ä½œã€‚å¦ä¸€ç§é€‰æ‹©æ˜¯ç›´æ¥ **ç»ˆæ­¢**ï¼ˆ*abort*ï¼‰ï¼Œè¿™ä¼šä¸æ¸…ç†æ•°æ®å°±é€€å‡ºç¨‹åºã€‚é‚£ä¹ˆç¨‹åºæ‰€ä½¿ç”¨çš„å†…å­˜éœ€è¦ç”±æ“ä½œç³»ç»Ÿæ¥æ¸…ç†ã€‚å¦‚æœä½ éœ€è¦é¡¹ç›®çš„æœ€ç»ˆäºŒè¿›åˆ¶æ–‡ä»¶è¶Šå°è¶Šå¥½ï¼Œpanic æ—¶é€šè¿‡åœ¨ *Cargo.toml* çš„ `[profile]` éƒ¨åˆ†å¢åŠ  `panic = 'abort'`ï¼Œå¯ä»¥ç”±å±•å¼€åˆ‡æ¢ä¸ºç»ˆæ­¢ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ æƒ³è¦åœ¨releaseæ¨¡å¼ä¸­ panic æ—¶ç›´æ¥ç»ˆæ­¢ï¼š
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```

+ é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“`panic`å‘ç”Ÿï¼š

  + ç¨‹åºå±•å¼€è°ƒç”¨æ ˆï¼ˆå·¥ä½œé‡å¤§ï¼‰
    + Rustæ²¿ç€è°ƒç”¨æ ˆå¾€å›èµ°
    + æ¸…ç†æ¯ä¸ªé‡åˆ°çš„å‡½æ•°ä¸­çš„æ•°æ®
  + ç«‹å³ç»ˆæ­¢è°ƒç”¨æ ˆ
    + ä¸è¿›è¡Œæ¸…ç†ï¼Œç›´æ¥åœæ­¢ç¨‹åº
    + å†…å­˜éœ€è¦OSè¿›è¡Œæ¸…ç†

+ æƒ³è®©äºŒè¿›åˆ¶æ–‡ä»¶æ›´å°ï¼ŒæŠŠè®¾ç½®ä»â€œå±•å¼€â€æ”¹ä¸ºâ€œç»ˆæ­¢â€

  + åœ¨`Cargo.toml`ä¸­é€‚å½“çš„`profile`éƒ¨åˆ†è®¾ç½®
    + `panic=abort`

  ```rust
  fn main() {
      // panic!("crash and burn");
  
      let v = vec![1, 2, 3];
      v[99];
  }
  ```

+ `panic!`å¯èƒ½å‡ºç°åœ¨ï¼š

  + æˆ‘ä»¬å†™çš„ä»£ç ä¸­
  + æˆ‘ä»¬æ‰€ä¾èµ–çš„ä»£ç ä¸­

+ å¯ä»¥é€šè¿‡è°ƒç”¨`panic!`çš„å‡½æ•°çš„å›æº¯ä¿¡æ¯æ¥å®šä½å¼•èµ·é—®é¢˜çš„ä»£ç 

  + é€šè¿‡è®¾ç½®ç¯å¢ƒå˜é‡`RUST_BACKTRACE`å¯å¾—åˆ°å›æº¯ä¿¡æ¯

  ```rust
  export RUST_BACKTRACE=1 && cr                 [11:11:32]
      Finished dev [unoptimized + debuginfo] target(s) in 0.00s
       Running `target/debug/panic_demo`
  thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:5:5
  stack backtrace:
     0: rust_begin_unwind
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/std/src/panicking.rs:584:5
     1: core::panicking::panic_fmt
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/panicking.rs:142:14
     2: core::panicking::panic_bounds_check
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/panicking.rs:84:5
     3: <usize as core::slice::index::SliceIndex<[T]>>::index
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/slice/index.rs:250:10
     4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/slice/index.rs:18:9
     5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/alloc/src/vec/mod.rs:2628:9
     6: panic_demo::main
               at ./src/main.rs:5:5
     7: core::ops::function::FnOnce::call_once
               at /rustc/897e37553bba8b42751c67658967889d11ecd120/library/core/src/ops/function.rs:248:5
  note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
  ```

  + ä¸ºäº†è·å–å¸¦æœ‰è°ƒè¯•ä¿¡æ¯çš„å›æº¯ï¼Œå¿…é¡»å¯ç”¨è°ƒè¯•ç¬¦å·ï¼ˆä¸å¸¦ `--release`ï¼‰

### 9.2 ç”¨Resultå¤„ç†å¯æ¢å¤çš„é”™è¯¯

> å¤§éƒ¨åˆ†é”™è¯¯å¹¶æ²¡æœ‰ä¸¥é‡åˆ°éœ€è¦ç¨‹åºå®Œå…¨åœæ­¢æ‰§è¡Œã€‚æœ‰æ—¶ï¼Œä¸€ä¸ªå‡½æ•°ä¼šå› ä¸ºä¸€ä¸ªå®¹æ˜“ç†è§£å¹¶åšå‡ºååº”çš„åŸå› å¤±è´¥ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå› ä¸ºæ‰“å¼€ä¸€ä¸ªå¹¶ä¸å­˜åœ¨çš„æ–‡ä»¶è€Œå¤±è´¥ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯èƒ½æƒ³è¦åˆ›å»ºè¿™ä¸ªæ–‡ä»¶ï¼Œè€Œä¸æ˜¯ç»ˆæ­¢è¿›ç¨‹ã€‚

#### 9.2.1 Resultæšä¸¾

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

+ `T`ï¼šæ“ä½œæˆåŠŸæƒ…å†µä¸‹ï¼Œ`Ok`å˜ä½“é‡Œè¿”å›çš„æ•°æ®çš„ç±»å‹

+ `E`ï¼šæ“ä½œå¤±è´¥æƒ…å†µä¸‹ï¼Œ`Err`å˜ä½“é‡Œè¿”å›çš„æ•°æ®çš„ç±»å‹

  ```rust
  let f = File::open("hello.txt");
  ```

#### 9.2.2 å¤„ç†Resultçš„ä¸€ç§æ–¹å¼ï¼šmatchè¡¨è¾¾å¼

+ å’Œ`Option`æšä¸¾ä¸€æ ·ï¼Œ`Result`åŠå…¶å˜ä½“ä¹Ÿæ˜¯ç”±`prelude`å¸¦å…¥ä½œç”¨åŸŸ

  ```rust
  let f = File::open("hello.txt");
  
  let f = match f {
      Ok(file) => file,
      Err(error) => {
          panic!("error opening file: {:?}", error)
      }
  };
  ```

+ åŒ¹é…ä¸åŒçš„é”™è¯¯
